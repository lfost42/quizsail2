[
  {
    "q": "Which Kubernetes resource provides layer 7 (HTTP/HTTPS) routing rules for external access to cluster services while enabling path-based and host-based routing?",
    "c": [
      "Ingress",
      "Service",
      "Endpoint",
      "NetworkPolicy",
      "LoadBalancer"
    ],
    "a": [
      "Ingress"
    ],
    "e": "Ingress resources define HTTP/HTTPS routing rules and integrate with Ingress controllers to expose services. Services (ClusterIP, NodePort, LoadBalancer) operate at layer 4, while NetworkPolicy controls network traffic flow. LoadBalancer is a Service type, not a separate resource."
  },
  {
    "q": "What is the primary purpose of Open Policy Agent (OPA) Gatekeeper in Kubernetes?",
    "c": [
      "To manage node scaling based on CPU usage",
      "To provide an integrated container registry",
      "To enforce policy-as-code by validating configurations during admission",
      "To offer a threat feed for container vulnerabilities",
      "To install an alternative container runtime in Kubernetes"
    ],
    "a": [
      "To enforce policy-as-code by validating configurations during admission"
    ],
    "e": "OPA Gatekeeper is a validating admission controller that enforces policies defined as code during resource creation or updates in Kubernetes. It ensures compliance by preventing non-compliant resources from being admitted to the cluster. Incorrect options, such as managing node scaling or providing a container registry, are unrelated to OPA Gatekeeper's functionality. Similarly, it does not handle threat feeds or runtime installation."
  },
  {
    "q": "Which Kubernetes component is responsible for persisting the cluster's state?",
    "c": [
      "kube-scheduler",
      "etcd",
      "kube-controller-manager",
      "kube-proxy",
      "kubelet"
    ],
    "a": [
      "etcd"
    ],
    "e": "etcd is a distributed key-value store that persists the Kubernetes cluster's state. It ensures that the cluster's configuration and data are consistent across all nodes."
  },
  {
    "q": "In managed Kubernetes services (e.g., EKS, GKE, AKS), who is responsible for managing the etcd cluster?",
    "c": [
      "The user manages etcd directly",
      "The cloud provider manages etcd",
      "etcd is not used in managed services",
      "A third-party vendor manages etcd",
      "The Kubernetes community manages etcd"
    ],
    "a": [
      "The cloud provider manages etcd"
    ],
    "e": "In managed Kubernetes services, the cloud provider is responsible for managing the etcd cluster, including backups, scaling, and availability. Users do not manage etcd directly. etcd is a core component of Kubernetes and is always used, but its management is abstracted away in managed services. The Kubernetes community develops etcd but does not manage individual clusters."
  },
  {
    "q": "Which of the following controllers are included in the Kubernetes kube-controller-manager? (Select all that apply)",
    "c": [
      "Node Controller",
      "ReplicaSet Controller",
      "Ingress Controller",
      "Cloud Controller Manager",
      "Service Account Controller"
    ],
    "a": [
      "Node Controller",
      "ReplicaSet Controller",
      "Service Account Controller"
    ],
    "e": "The kube-controller-manager runs several core controllers including the Node Controller, which manages node status; the ReplicaSet Controller, which ensures the desired number of pod replicas; and the Service Account Controller, which manages service account tokens. The Ingress Controller is typically deployed separately as an add-on and is not part of the kube-controller-manager. The Cloud Controller Manager is a separate component responsible for cloud-specific control loops and is not included in the kube-controller-manager."
  },
  {
    "q": "Why would you disable automounting of ServiceAccount tokens in a Kubernetes Pod?",
    "c": [
      "To reduce memory usage of the Pod",
      "To prevent the Pod from having unnecessary or unauthorized access to the Kubernetes API",
      "To improve the application's runtime performance",
      "To enable network policies enforcement",
      "To allow the Pod to use multiple ServiceAccounts simultaneously"
    ],
    "a": [
      "To prevent the Pod from having unnecessary or unauthorized access to the Kubernetes API"
    ],
    "e": "Disabling automounting of ServiceAccount tokens prevents the Pod from automatically receiving credentials that grant access to the Kubernetes API. This reduces the attack surface by limiting the Pod's ability to interact with the cluster unless explicitly required. The other options are incorrect because automounting tokens does not significantly affect memory usage or application performance, does not directly enable network policies, and Pods cannot use multiple ServiceAccounts simultaneously."
  },
  {
    "q": "Which Kubernetes resource is commonly used to integrate Open Policy Agent (OPA) for policy enforcement through admission control?",
    "c": [
      "ValidatingWebhookConfiguration",
      "MutatingWebhookConfiguration",
      "AdmissionController",
      "CustomResourceDefinition",
      "PolicyController"
    ],
    "a": [
      "ValidatingWebhookConfiguration"
    ],
    "e": "The 'ValidatingWebhookConfiguration' resource is used to register admission webhooks that validate requests to the Kubernetes API server. Open Policy Agent (OPA) leverages this mechanism to enforce custom policies by intercepting and validating API requests. 'MutatingWebhookConfiguration' is used for modifying requests, 'AdmissionController' is a general concept, 'CustomResourceDefinition' defines new resource types, and 'PolicyController' is not a standard Kubernetes resource."
  },
  {
    "q": "How do you scale a Kubernetes deployment named 'my-deployment' to 5 replicas using the CLI?",
    "c": [
      "kubectl scale deployment my-deployment --replicas=5",
      "kubectl update deployment my-deployment --replicas=5",
      "kubectl set deployment my-deployment replicas=5",
      "kubectl resize deployment my-deployment 5",
      "kubectl deploy my-deployment --replicas=5"
    ],
    "a": [
      "kubectl scale deployment my-deployment --replicas=5"
    ],
    "e": "The 'kubectl scale' command is used to adjust the number of replicas in a deployment. In this case, 'kubectl scale deployment my-deployment --replicas=5' will scale the deployment to 5 replicas."
  },
  {
    "q": "How do Kubernetes Secrets provide improved security compared to ConfigMaps?",
    "c": [
      "Secrets are encrypted by default in etcd",
      "Secrets are stored in a separate database from ConfigMaps",
      "Secrets are base64-encoded and can be encrypted at rest, whereas ConfigMaps are stored in plain text",
      "Secrets provide built-in versioning",
      "Secrets can only be accessed by cluster administrators"
    ],
    "a": [
      "Secrets are base64-encoded and can be encrypted at rest, whereas ConfigMaps are stored in plain text"
    ],
    "e": "Kubernetes Secrets are base64-encoded and can be configured to be encrypted at rest in etcd, providing better protection for sensitive data than ConfigMaps, which are stored as plain text in etcd. Secrets are not encrypted by default unless encryption at rest is enabled. They do not provide built-in versioning, and access controls depend on RBAC policies rather than restricting access solely to cluster admins."
  },
  {
    "q": "What is the role of the 'cluster-admin' ClusterRole?",
    "c": [
      "Read-only access to cluster resources",
      "Admin access limited to one namespace",
      "Full control over all resources in the cluster",
      "Access to manage nodes but not pods",
      "Limited to managing storage resources"
    ],
    "a": [
      "Full control over all resources in the cluster"
    ],
    "e": "The 'cluster-admin' ClusterRole grants full cluster-wide administrative permissions. When bound via a ClusterRoleBinding, it provides full control over all resources in the cluster. When bound via a RoleBinding, its permissions are limited to the namespace specified in the binding."
  },
  {
    "q": "What is the primary purpose of Role-Based Access Control (RBAC) in Kubernetes?",
    "c": [
      "To manage network policies for pods",
      "To control user and process access to Kubernetes resources",
      "To schedule pods efficiently across nodes",
      "To monitor cluster performance metrics",
      "To provide logging and audit capabilities"
    ],
    "a": [
      "To control user and process access to Kubernetes resources"
    ],
    "e": "RBAC in Kubernetes is designed to control and manage access permissions for users and processes to Kubernetes resources, ensuring that only authorized entities can perform specific actions. It does not manage network policies, scheduling, monitoring, or logging directly, although these areas may have their own mechanisms."
  },
  {
    "q": "What critical security objectives are achieved through regular vulnerability scanning of container images in Kubernetes environments?",
    "c": [
      "Optimizes container runtime performance metrics",
      "Reduces container image layer count",
      "Identifies and remediates known software vulnerabilities",
      "Ensures compliance with open-source licensing",
      "Accelerates container deployment pipelines"
    ],
    "a": [
      "Identifies and remediates known software vulnerabilities"
    ],
    "e": "Regular image scanning detects vulnerabilities in base images and dependencies, enabling remediation before deployment. This practice addresses CVE management and reduces attack surfaces, forming a crucial part of DevSecOps pipelines. Other options describe unrelated benefits: performance (option 1), licensing (option 4), and deployment speed (option 5) require different tooling and processes."
  },
  {
    "q": "In a Kubernetes audit policy, which 'level' setting logs only metadata about requests but excludes the request and response bodies?",
    "c": [
      "None",
      "Metadata",
      "Request",
      "RequestResponse",
      "Minimal"
    ],
    "a": [
      "Metadata"
    ],
    "e": "The 'Metadata' audit level records request metadata such as request method, resource, user, and timestamp but does not log the request or response bodies. 'None' disables logging. 'Request' logs the request body but not the response. 'RequestResponse' logs both request and response bodies. 'Minimal' is not a standard audit level in Kubernetes."
  },
  {
    "q": "What is an example of 'Information Disclosure' under the STRIDE threat model?",
    "c": [
      "A user deletes all records from a database",
      "A user reads sensitive data in a database without authorization",
      "A user denies performing a destructive action",
      "A user overflows a buffer to gain root access",
      "A user floods a network to make services unavailable"
    ],
    "a": [
      "A user reads sensitive data in a database without authorization"
    ],
    "e": "Information Disclosure refers to unauthorized access to sensitive data. This can occur when a user reads confidential information without proper authorization. Other options do not fit this category because they involve different types of threats: data deletion (Tampering), denial of actions (Denial of Service), privilege escalation (Elevation of Privileges), and network disruption (Denial of Service)."
  },
  {
    "q": "How do you configure a Kubernetes audit policy rule to log events for all resources within a specific namespace?",
    "c": [
      "Set 'namespace: <namespace>' in the policy rule",
      "Use 'namespaces: [\"<namespace>\"]' under the rule's 'namespaces' field",
      "Add 'resourceNames: [\"<namespace>\"]' to the rule",
      "Set 'level: Namespace' in the policy",
      "Specify 'namespaceSelector: {matchNames: [\"<namespace>\"]}'"
    ],
    "a": [
      "Use 'namespaces: [\"<namespace>\"]' under the rule's 'namespaces' field"
    ],
    "e": "In Kubernetes audit policies, the 'namespaces' field in a rule specifies the namespaces to which the rule applies, allowing you to log events for all resources within those namespaces. The other options are incorrect because 'namespace' is not a valid field, 'resourceNames' filters specific resource names rather than namespaces, 'level' defines log verbosity not scope, and 'namespaceSelector' is not used in audit policies."
  },
  {
    "q": "Which Kubernetes resource is used to enforce Pod Security Standards within a namespace?",
    "c": [
      "ReplicaSet",
      "ConfigMap",
      "ServiceAccount",
      "Pod Security Admission Controller"
    ],
    "a": [
      "Pod Security Admission Controller"
    ],
    "e": "The Pod Security Admission Controller is responsible for enforcing Pod Security Standards in Kubernetes. It ensures that pods comply with predefined security policies, enhancing cluster security."
  },
  {
    "q": "Which kube-apiserver configuration flag properly enables the ImagePolicyWebhook admission controller in modern Kubernetes versions (v1.10+)?",
    "c": [
      "--enable-admission-plugins=ImagePolicyWebhook",
      "--admission-control=ImagePolicyWebhook",
      "--admission-plugins=ImagePolicyWebhook",
      "--enable-image-policy",
      "--image-policy-webhook=true"
    ],
    "a": [
      "--enable-admission-plugins=ImagePolicyWebhook"
    ],
    "e": "In Kubernetes v1.10+, admission controllers are enabled using '--enable-admission-plugins'. The '--admission-control' flag was deprecated in favor of this new syntax. The ImagePolicyWebhook controller enables image verification through external webhooks, crucial for enforcing image registry policies."
  },
  {
    "q": "What is the effect of executing the command 'kubectl drain <node-name>' on a Kubernetes node?",
    "c": [
      "Deletes the node from the cluster",
      "Marks the node as unschedulable and evicts all pods safely",
      "Restarts the node",
      "Upgrades the node's Kubernetes version",
      "Cleans up unused container images on the node"
    ],
    "a": [
      "Marks the node as unschedulable and evicts all pods safely"
    ],
    "e": "'kubectl drain' prepares a node for maintenance by marking it unschedulable to prevent new pods from being scheduled and safely evicting all existing pods. It does not delete the node, restart it, upgrade Kubernetes, or clean images. This ensures workloads are gracefully moved before maintenance."
  },
  {
    "q": "According to the CIS Kubernetes Benchmark, which setting should be disabled on the kube-apiserver for security reasons?",
    "c": [
      "Anonymous authentication",
      "RBAC authorization",
      "TLS encryption",
      "Admission controllers",
      "Audit logging"
    ],
    "a": [
      "Anonymous authentication"
    ],
    "e": "Anonymous authentication should be disabled on the kube-apiserver to enhance security, as recommended by the CIS Kubernetes Benchmark. Enabling anonymous authentication allows unauthorized access to cluster resources, which is a significant security risk. Disabling it ensures that all interactions with the API server require proper authentication."
  },
  {
    "q": "In a Kubernetes audit policy, which log level should be set to capture the full content of both requests and responses?",
    "c": [
      "None",
      "Metadata",
      "Request",
      "RequestResponse",
      "Content"
    ],
    "a": [
      "RequestResponse"
    ],
    "e": "The 'RequestResponse' audit log level records both the metadata and the full content of requests and responses, providing comprehensive audit information. 'None' disables logging, 'Metadata' logs only metadata without content, 'Request' logs request content but not responses, and 'Content' is not a valid audit log level in Kubernetes."
  },
  {
    "q": "In Kubernetes Pod specifications, which field explicitly defines the container runtime class that should be used for pod execution?",
    "c": [
      "runtime",
      "runtimeClassName",
      "containerRuntime",
      "runtimeClass",
      "containerRuntimeClass"
    ],
    "a": [
      "runtimeClassName"
    ],
    "e": "The 'runtimeClassName' field in Pod specifications references a RuntimeClass object that defines container runtime configurations. This allows administrators to control runtime security parameters and isolation mechanisms. Other options like 'runtimeClass' or 'containerRuntimeClass' are invalid field names in the Kubernetes API."
  },
  {
    "q": "Which STRIDE threat category primarily addresses threats related to data integrity?",
    "c": [
      "Spoofing",
      "Tampering",
      "Repudiation",
      "Information Disclosure",
      "Denial of Service"
    ],
    "a": [
      "Tampering"
    ],
    "e": "The 'Tampering' category in STRIDE focuses on threats that compromise data integrity by unauthorized modification of data. Spoofing relates to identity, repudiation to denial of actions, information disclosure to confidentiality breaches, and denial of service to availability issues."
  },
  {
    "q": "What is the recommended method for storing sensitive data, such as passwords or tokens, in a Kubernetes environment?",
    "c": [
      "Hardcode them in application code",
      "Store them in ConfigMaps",
      "Use Kubernetes Secrets",
      "Store them in environment variables",
      "Include them in container images"
    ],
    "a": [
      "Use Kubernetes Secrets"
    ],
    "e": "Kubernetes Secrets are specifically designed to securely store sensitive data. They provide a secure way to manage and distribute sensitive information to pods, reducing the risk of data exposure compared to other methods like hardcoding or using environment variables."
  },
  {
    "q": "What is the correct kubectl command syntax to create a Role named 'pod-reader' with get/watch/list permissions on Pods in the current namespace?",
    "c": [
      "kubectl apply role",
      "kubectl create role pod-reader --verb=get,list,watch --resource=pods",
      "kubectl generate role",
      "kubectl new role",
      "kubectl init role"
    ],
    "a": [
      "kubectl create role pod-reader --verb=get,list,watch --resource=pods"
    ],
    "e": "The 'kubectl create role' command with proper flags creates RBAC Roles. The full syntax requires specifying verbs (--verb) and resources (--resource). This command creates non-namespaced Roles; for cluster-wide permissions, use 'kubectl create clusterrole' instead."
  },
  {
    "q": "Which Kubernetes control plane component is exclusively responsible for evaluating scheduling constraints and binding Pods to appropriate worker nodes?",
    "c": [
      "kube-controller-manager",
      "kube-scheduler",
      "kube-apiserver",
      "kubelet",
      "etcd"
    ],
    "a": [
      "kube-scheduler"
    ],
    "e": "The kube-scheduler evaluates Pod specifications against node resources, taints/tolerations, and affinity/anti-affinity rules to select optimal nodes. The kube-controller-manager handles node lifecycle controllers, while kubelets manage Pod execution on worker nodes."
  },
  {
    "q": "Which kubectl command lists all resource types within a specific namespace?",
    "c": [
      "kubectl get all --namespace=<namespace>",
      "kubectl get resources --namespace=<namespace>",
      "kubectl describe namespace <namespace>",
      "kubectl list namespace <namespace>",
      "kubectl get all <namespace>"
    ],
    "a": [
      "kubectl get all --namespace=<namespace>"
    ],
    "e": "The command 'kubectl get all --namespace=<namespace>' retrieves all resource types (pods, services, deployments, etc.) within the specified namespace. The other options are either invalid commands or do not list all resources. 'kubectl describe namespace' provides details about the namespace itself, not its resources."
  },
  {
    "q": "Which command is used to remove the 'apache2' package from a Debian-based Linux system?",
    "c": [
      "sudo apt-get install apache2",
      "sudo yum remove apache2",
      "sudo apt-get remove apache2",
      "sudo rpm -e apache2",
      "sudo dnf erase apache2"
    ],
    "a": [
      "sudo apt-get remove apache2"
    ],
    "e": "On Debian-based systems (such as Ubuntu), the package manager 'apt-get' is used to manage packages. The command 'sudo apt-get remove apache2' uninstalls the 'apache2' package but retains configuration files. 'sudo apt-get install apache2' installs the package. 'sudo yum remove apache2' and 'sudo dnf erase apache2' are used on Red Hat-based systems, not Debian-based. 'sudo rpm -e apache2' is also for RPM-based distributions and not applicable to Debian-based systems."
  },
  {
    "q": "What is an effective mitigation technique for 'Information Disclosure' threats in a Kubernetes environment?",
    "c": [
      "Implementing audit logging",
      "Encrypting data at rest and in transit",
      "Using rate limiting",
      "Implementing CAPTCHA",
      "Using prepared SQL statements"
    ],
    "a": [
      "Encrypting data at rest and in transit"
    ],
    "e": "Encrypting data at rest and in transit is crucial for protecting against Information Disclosure threats. This ensures that even if unauthorized access occurs, the data remains confidential and unreadable."
  },
  {
    "q": "What is the purpose of the '--allow-privileged' flag in the Kubernetes API server configuration?",
    "c": [
      "Allows pods to run privileged containers with elevated permissions",
      "Enables unauthenticated access to the API server",
      "Grants cluster-admin rights to all users",
      "Disables security contexts on pods",
      "Controls enforcement of network policies"
    ],
    "a": [
      "Allows pods to run privileged containers with elevated permissions"
    ],
    "e": "The '--allow-privileged' flag on the Kubernetes API server enables or disables the ability to create privileged containers, which have elevated permissions on the host and can perform sensitive operations. This flag does not affect authentication, user permissions, security contexts broadly, or network policy enforcement. Running privileged containers increases security risks and should be carefully controlled."
  },
  {
    "q": "What is Kyverno's primary function in a Kubernetes environment?",
    "c": [
      "A container scanning tool for malware detection",
      "A platform for automating cost optimizations",
      "An admission controller that enables writing and enforcing policies as Kubernetes resources",
      "An event streaming system for logs",
      "A vulnerability database maintained by CIS"
    ],
    "a": [
      "An admission controller that enables writing and enforcing policies as Kubernetes resources"
    ],
    "e": "Kyverno is a Kubernetes-native policy engine that functions as an admission controller. It allows administrators to define, validate, and enforce policies using Kubernetes Custom Resource Definitions (CRDs), making policy management declarative and integrated into the Kubernetes API. It is not a container scanning tool, cost optimization platform, log streaming system, or a vulnerability database. Its design simplifies policy enforcement without requiring external policy languages or frameworks."
  },
  {
    "q": "Upon identifying a vulnerable Docker image in your Kubernetes cluster, what is the recommended immediate action to mitigate the risk?",
    "c": [
      "Ignore the vulnerability",
      "Update the image tag to 'latest'",
      "Delete the pod using the vulnerable image",
      "Restart the Kubernetes cluster",
      "Rebuild the image without changes"
    ],
    "a": [
      "Delete the pod using the vulnerable image"
    ],
    "e": "The recommended immediate action is to delete the pod running the vulnerable image. This action helps mitigate the risk by removing the vulnerable container from your environment."
  },
  {
    "q": "How do you create a Secret from literal values in Kubernetes?",
    "c": [
      "kubectl create secret generic my-secret --from-literal=key1=value1",
      "kubectl create secret generic my-secret key1=value1",
      "kubectl create secret my-secret --literal key1=value1",
      "kubectl create secret tls my-secret --key1 value1",
      "kubectl secret create my-secret key1=value1"
    ],
    "a": [
      "kubectl create secret generic my-secret --from-literal=key1=value1"
    ],
    "e": "To create a Secret from literal values, you use the command `kubectl create secret generic my-secret --from-literal=key1=value1`. This command allows you to define key-value pairs directly in the command line, which are then stored as a Secret in Kubernetes."
  },
  {
    "q": "Which kubectl command is used to delete a deployment named 'my-app' in Kubernetes?",
    "c": [
      "kubectl remove deployment my-app",
      "kubectl delete deployment my-app",
      "kubectl destroy deployment my-app",
      "kubectl erase deployment my-app",
      "kubectl terminate deployment my-app"
    ],
    "a": [
      "kubectl delete deployment my-app"
    ],
    "e": "The correct command to delete a deployment in Kubernetes is 'kubectl delete deployment my-app'. This command removes the deployment resource and all associated pods. The other options are incorrect as they are not valid kubectl commands for deleting resources."
  },
  {
    "q": "Which methodology involves visualizing application components and interactions to identify potential security threats?",
    "c": [
      "Scrum methodology",
      "Data Flow Diagram (DFD) approach",
      "Waterfall model",
      "Incident Response Cycle",
      "Serverless microservices design"
    ],
    "a": [
      "Data Flow Diagram (DFD) approach"
    ],
    "e": "The Data Flow Diagram (DFD) approach is a visual representation technique used to map out data paths and interactions within systems, facilitating the identification and mitigation of security threats."
  },
  {
    "q": "What is the main function of the kubelet in a Kubernetes node?",
    "c": [
      "Managing pod networking",
      "Running containers on each node",
      "Storing cluster configuration",
      "Scheduling pods to nodes",
      "Managing the control plane"
    ],
    "a": [
      "Running containers on each node"
    ],
    "e": "The kubelet is responsible for running and managing containers on each node in a Kubernetes cluster. It ensures that the pods are running as expected and reports back to the control plane."
  },
  {
    "q": "How do you label a Kubernetes node with the key 'env' and value 'production'?",
    "c": [
      "kubectl label node <node-name> env:production",
      "kubectl label nodes <node-name> env=production",
      "kubectl annotate node <node-name> env=production",
      "kubectl set label node <node-name> env=production",
      "kubectl tag node <node-name> env=production"
    ],
    "a": [
      "kubectl label nodes <node-name> env=production"
    ],
    "e": "To label a Kubernetes node with the key 'env' and value 'production', you use the command `kubectl label nodes <node-name> env=production`. This command adds a label to the specified node, which can be used for filtering or selecting nodes for specific tasks."
  },
  {
    "q": "Which statement best describes the role of container scanning tools like Aqua Security or Clair?",
    "c": [
      "They manage multi-cluster ingress controllers",
      "They automate vulnerability detection in container images, typically before deployment",
      "They provide a database of open-source container licenses",
      "They specialize in high-availability cluster provisioning",
      "They replace Kubernetesâ€™ default scheduler"
    ],
    "a": [
      "They automate vulnerability detection in container images, typically before deployment"
    ],
    "e": "Container scanning tools such as Aqua Security and Clair analyze container images to identify known security vulnerabilities before these images are deployed. This process is a critical part of securing the container supply chain. They do not manage ingress controllers, provide license databases, handle cluster provisioning, or replace Kubernetes schedulers. Their focus is on vulnerability assessment to prevent deploying insecure containers."
  },
  {
    "q": "What command is used to update an image in a Kubernetes deployment?",
    "c": [
      "kubectl set image deployment/my-deployment my-container=my-image:tag",
      "kubectl update image deployment/my-deployment my-container=my-image:tag",
      "kubectl replace image deployment/my-deployment my-container=my-image:tag",
      "kubectl change image deployment/my-deployment my-container=my-image:tag",
      "kubectl edit deployment my-deployment"
    ],
    "a": [
      "kubectl set image deployment/my-deployment my-container=my-image:tag"
    ],
    "e": "The `kubectl set image` command is used to update the image for a specified container in a Kubernetes deployment. This command modifies the deployment configuration to use the new image, which triggers a rollout of the updated pods."
  },
  {
    "q": "How do you enable Pod Security Admission (PSA) in a Kubernetes cluster?",
    "c": [
      "Install the PSA plugin via kubectl",
      "Add 'PodSecurity' to the '--enable-admission-plugins' flag in the API server",
      "Apply a custom resource definition for PSA",
      "Use a third-party tool to enforce PSA",
      "Enable it in the kubelet configuration"
    ],
    "a": [
      "Add 'PodSecurity' to the '--enable-admission-plugins' flag in the API server"
    ],
    "e": "To enable Pod Security Admission (PSA), you need to add 'PodSecurity' to the '--enable-admission-plugins' flag when starting the API server. This ensures that the PodSecurity admission controller is active and enforcing pod security standards."
  },
  {
    "q": "What is the primary role of the kube-proxy component in Kubernetes?",
    "c": [
      "Managing network policies",
      "Providing service discovery and routing",
      "Scheduling pods to nodes",
      "Storing cluster state",
      "Monitoring node health"
    ],
    "a": [
      "Providing service discovery and routing"
    ],
    "e": "kube-proxy is responsible for maintaining network rules on each node to ensure service discovery and routing. It does not manage network policies or schedule pods."
  },
  {
    "q": "Which kubectl command provides detailed information about a specific Kubernetes node, including its status, capacity, and allocated resources?",
    "c": [
      "kubectl get node <node-name>",
      "kubectl describe node <node-name>",
      "kubectl inspect node <node-name>",
      "kubectl info node <node-name>",
      "kubectl logs node <node-name>"
    ],
    "a": [
      "kubectl describe node <node-name>"
    ],
    "e": "The command 'kubectl describe node <node-name>' shows detailed information about the node, such as labels, annotations, resource capacity, allocated resources, conditions, and events. 'kubectl get node' provides a summary list of nodes but not detailed info. 'kubectl inspect' and 'kubectl info' are not valid kubectl commands for nodes. 'kubectl logs' is used for retrieving logs from pods, not nodes."
  },
  {
    "q": "Which Kubernetes pod specification field prevents automatic mounting of the default ServiceAccount token?",
    "c": [
      "mountServiceAccountToken: false",
      "automountServiceAccountToken: false",
      "serviceAccountToken: disabled",
      "disableServiceAccountMount: true",
      "serviceAccountMountPolicy: none"
    ],
    "a": [
      "automountServiceAccountToken: false"
    ],
    "e": "automountServiceAccountToken: false in the pod spec prevents automatic mounting of the service account token, reducing attack surface. This security hardening measure is recommended when pods don't need Kubernetes API access, as noted in the Kubernetes service account documentation and security best practices guides."
  },
  {
    "q": "Is there a Kubernetes object specifically designed to limit the number of concurrent requests to the API server?",
    "c": [
      "ResourceQuota",
      "LimitRange",
      "PodDisruptionBudget",
      "PriorityClass",
      "There is no such object"
    ],
    "a": [
      "There is no such object"
    ],
    "e": "Kubernetes does not have an object specifically for limiting concurrent API server requests. Instead, this is typically controlled through API server configuration flags."
  },
  {
    "q": "What is a common use case for a Kubernetes CronJob?",
    "c": [
      "Running a database",
      "Serving web traffic",
      "Scheduling regular, recurring tasks",
      "Managing network policies",
      "Providing persistent storage"
    ],
    "a": [
      "Scheduling regular, recurring tasks"
    ],
    "e": "Kubernetes CronJobs are designed to schedule and run Jobs at specified times or intervals, similar to cron jobs in Unix-like systems. They are ideal for automating repetitive tasks such as backups, report generation, or periodic maintenance. Other options like running a database, serving web traffic, managing network policies, or providing persistent storage are outside the scope of CronJobs' functionality."
  },
  {
    "q": "What is the primary function of the Kubernetes 'LimitRange' resource?",
    "c": [
      "To limit the number of namespaces",
      "To set default resource requests and limits for pods in a namespace",
      "To restrict network access between pods",
      "To control access to the Kubernetes API",
      "To define storage classes"
    ],
    "a": [
      "To set default resource requests and limits for pods in a namespace"
    ],
    "e": "A LimitRange in Kubernetes is used to enforce constraints on resource usage within a namespace. It sets default resource requests and limits for pods, ensuring that they do not exceed specified thresholds. This helps in preventing resource over-allocation and maintaining cluster stability."
  },
  {
    "q": "What components are necessary to verify the integrity and authenticity of a container image?",
    "c": [
      "A checksum and the image manifest",
      "A digital signature, public key, and verification tool",
      "The Dockerfile used to build the image",
      "Access to the container registry logs",
      "The image's pull secret"
    ],
    "a": [
      "A digital signature, public key, and verification tool"
    ],
    "e": "To verify the integrity and authenticity of a container image, you need a digital signature, a public key to verify the signature, and a verification tool. This ensures that the image has not been tampered with and comes from a trusted source."
  },
  {
    "q": "How do you delete a Kubernetes namespace and all its associated resources?",
    "c": [
      "kubectl delete all --namespace=<namespace>",
      "kubectl delete namespace <namespace>",
      "kubectl remove namespace <namespace>",
      "kubectl clean namespace <namespace>",
      "kubectl purge namespace <namespace>"
    ],
    "a": [
      "kubectl delete namespace <namespace>"
    ],
    "e": "Deleting a namespace with `kubectl delete namespace <namespace>` removes the namespace and all resources within it. This includes pods, services, deployments, and other objects defined within that namespace."
  },
  {
    "q": "Which of the following are Kubernetes security best practices to follow during the Deploy phase? (Select all that apply)",
    "c": [
      "Implement network policies",
      "Run containers as root",
      "Use image tags like 'latest'",
      "Use the ImagePolicyWebhook admission controller",
      "Apply security contexts to pods and containers"
    ],
    "a": [
      "Implement network policies",
      "Use the ImagePolicyWebhook admission controller",
      "Apply security contexts to pods and containers"
    ],
    "e": "During deployment, implementing network policies restricts pod communication to only necessary traffic, reducing attack surfaces. The ImagePolicyWebhook admission controller enforces image security policies to prevent untrusted images from running. Applying security contexts defines permissions and restrictions for pods and containers, enhancing security. Running containers as root and using mutable tags like 'latest' are discouraged as they increase security risks and reduce traceability."
  },
  {
    "q": "When implementing Kubernetes NetworkPolicies, what security implication should administrators consider when using an empty podSelector field?",
    "c": [
      "Restricts Access to Only Specific Pods",
      "Only Applies to Ingress Traffic",
      "Enhances Network Security by Default",
      "Applies the policy to all pods in the specified namespace"
    ],
    "a": [
      "Applies the policy to all pods in the specified namespace"
    ],
    "e": "An empty podSelector in a NetworkPolicy selects all pods in the namespace, meaning the policy applies to all pods in that namespace. The effect on traffic depends on the policy's ingress and egress rules; it does not by itself create a default-allow or default-deny behavior. Administrators should carefully design policies with empty podSelectors to avoid unintended broad application. Other options misrepresent NetworkPolicy mechanics: validation errors (option 3) do not occur due to empty selectors, scope is not limited to new pods (option 4), and cross-namespace communication (option 5) requires explicit policy rules."
  },
  {
    "q": "How can you update the container image of a Kubernetes deployment without modifying other deployment configurations?",
    "c": [
      "Manually edit the deployment YAML file and apply changes",
      "Delete the existing deployment and recreate it with the new image",
      "Use the 'kubectl set image' command to update the image",
      "Scale the deployment down to zero replicas, update the image, then scale back up",
      "Update the image directly in the container registry"
    ],
    "a": [
      "Use the 'kubectl set image' command to update the image"
    ],
    "e": "The 'kubectl set image' command allows you to update the container image of a deployment directly without changing other configuration parameters. This command triggers a rolling update, ensuring minimal downtime. Manually editing the YAML is error-prone and may unintentionally alter other settings. Deleting and recreating the deployment causes downtime and loss of state. Scaling down to zero is unnecessary and disruptive. Updating the image in the container registry alone does not affect running deployments."
  },
  {
    "q": "Why is it recommended to use image digests instead of tags in Kubernetes manifests?",
    "c": [
      "Digests are shorter than tags",
      "Tags can be mutable, but digests ensure image immutability",
      "Using digests is required by Kubernetes",
      "Tags are not supported in private registries",
      "Digests allow for automatic updates"
    ],
    "a": [
      "Tags can be mutable, but digests ensure image immutability"
    ],
    "e": "Image digests are recommended because they refer to a specific, immutable version of an image. This ensures consistency and predictability in deployments, unlike mutable tags."
  },
  {
    "q": "What security risk is associated with mounting the Docker socket ('/var/run/docker.sock') into a container?",
    "c": [
      "No risk; it's a common practice",
      "The container can control the Docker daemon and other containers",
      "It improves container performance",
      "It provides secure access to host resources",
      "It isolates the container from the host"
    ],
    "a": [
      "The container can control the Docker daemon and other containers"
    ],
    "e": "Mounting the Docker socket into a container allows the container to control the host's Docker daemon, potentially leading to unauthorized access or manipulation of other containers and host resources. This practice should be avoided unless absolutely necessary and properly secured."
  },
  {
    "q": "Which of the following are best practices for securing etcd in a Kubernetes cluster? (Select all that apply)",
    "c": [
      "Enable TLS encryption for all communication with etcd",
      "Limit access to etcd endpoints to trusted networks only",
      "Use authentication and authorization mechanisms for etcd access",
      "Expose etcd endpoints publicly to facilitate monitoring",
      "Store etcd backups in a secure and access-controlled location"
    ],
    "a": [
      "Enable TLS encryption for all communication with etcd",
      "Limit access to etcd endpoints to trusted networks only",
      "Use authentication and authorization mechanisms for etcd access",
      "Store etcd backups in a secure and access-controlled location"
    ],
    "e": "Securing etcd is critical as it stores the cluster state and sensitive data. Best practices include enabling TLS encryption to protect data in transit, restricting access to trusted networks to prevent unauthorized access, implementing authentication and authorization to control who can access etcd, and securely storing backups to prevent data loss or compromise. Exposing etcd endpoints publicly is strongly discouraged as it poses a significant security risk."
  },
  {
    "q": "Which built-in Kubernetes authentication method is generally not recommended for production environments?",
    "c": [
      "Static Token File",
      "OpenID Connect (OIDC)",
      "Service Accounts",
      "Client Certificates",
      "Integrating with cloud provider IAM"
    ],
    "a": [
      "Static Token File"
    ],
    "e": "Static Token File authentication is not recommended for production due to security concerns. It lacks the robustness and flexibility of other methods like OIDC or Service Accounts."
  },
  {
    "q": "Which of the following is NOT a valid Kubernetes Service type?",
    "c": [
      "ClusterIP",
      "NodePort",
      "LoadBalancer",
      "ExternalName",
      "InternalPort"
    ],
    "a": [
      "InternalPort"
    ],
    "e": "Kubernetes defines several Service types to expose applications: ClusterIP, NodePort, LoadBalancer, and ExternalName are valid types. 'InternalPort' is not a recognized Service type in Kubernetes and does not exist in the official API. ClusterIP exposes the service on a cluster-internal IP, NodePort exposes the service on each node's IP at a static port, LoadBalancer provisions an external load balancer, and ExternalName maps the service to a DNS name. Therefore, 'InternalPort' is invalid."
  },
  {
    "q": "How can you create a ConfigMap from a file in Kubernetes?",
    "c": [
      "kubectl create configmap my-config --file=config.yaml",
      "kubectl apply configmap my-config --from-file=config.yaml",
      "kubectl create configmap my-config --from-file=config.yaml",
      "kubectl generate configmap my-config config.yaml",
      "kubectl configmap my-config --import=config.yaml"
    ],
    "a": [
      "kubectl create configmap my-config --from-file=config.yaml"
    ],
    "e": "To create a ConfigMap from a file, you use the command `kubectl create configmap my-config --from-file=config.yaml`. This command allows you to import configuration data from a file into a ConfigMap, which can then be used by applications running in Kubernetes."
  },
  {
    "q": "What is the recommended method to restrict access to the Kubernetes kubelet API securely?",
    "c": [
      "Disable the kubelet service entirely",
      "Configure kubelet with '--authorization-mode=Webhook' and '--authentication-token-webhook=true' flags",
      "Remove the kubelet binary from all nodes",
      "Access kubelet only via SSH tunnels",
      "Set '--allow-privileged=false' to restrict privileged containers"
    ],
    "a": [
      "Configure kubelet with '--authorization-mode=Webhook' and '--authentication-token-webhook=true' flags"
    ],
    "e": "The kubelet API should be secured by enabling authentication and authorization mechanisms. Using the '--authorization-mode=Webhook' flag enables authorization via an external webhook, typically the API server, while '--authentication-token-webhook=true' enables token-based authentication against the API server. This combination ensures that only authenticated and authorized requests can access the kubelet API. Disabling the kubelet or removing it is impractical as it is essential for node management. Accessing kubelet only via SSH does not inherently secure the API itself. Setting '--allow-privileged=false' restricts privileged containers but does not control API access."
  },
  {
    "q": "Which of the following best practices are recommended to secure the Kubernetes scheduler (kube-scheduler)? (Select all that apply.)",
    "c": [
      "Bind the scheduler to 0.0.0.0 to ensure it is accessible from all network interfaces",
      "Use Role-Based Access Control (RBAC) to restrict access to the scheduler API",
      "Run the scheduler as a non-root user to minimize privilege escalation risks",
      "Enable anonymous authentication to simplify access for debugging purposes",
      "Configure network policies to restrict network access to and from the scheduler"
    ],
    "a": [
      "Use Role-Based Access Control (RBAC) to restrict access to the scheduler API",
      "Run the scheduler as a non-root user to minimize privilege escalation risks",
      "Configure network policies to restrict network access to and from the scheduler"
    ],
    "e": "The recommended security measures for securing the kube-scheduler include: using Role-Based Access Control (RBAC) to enforce least privilege, ensuring only authorized entities can interact with the scheduler's API; running the kube-scheduler as a non-root user to reduce potential risks of privilege escalation in case of a compromise; and configuring network policies to restrict unauthorized network access to or from the kube-scheduler, thereby enhancing its security. Binding the scheduler to 0.0.0.0 increases exposure and is not recommended. Similarly, enabling anonymous authentication weakens security by allowing unauthenticated access."
  },
  {
    "q": "Which NIST Special Publication provides comprehensive guidelines on security and privacy controls specifically for federal information systems?",
    "c": [
      "NIST SP 800-53 Rev. 5",
      "NIST SP 800-190",
      "NIST SP 800-63",
      "NIST SP 800-171",
      "NIST SP 800-30"
    ],
    "a": [
      "NIST SP 800-53 Rev. 5"
    ],
    "e": "NIST SP 800-53 Rev. 5 is the primary publication that provides guidelines on security and privacy controls for federal information systems. It outlines a comprehensive set of controls that are crucial for protecting the confidentiality, integrity, and availability of federal information systems. NIST SP 800-190 focuses on cloud computing security, NIST SP 800-63 deals with digital identity guidelines, NIST SP 800-171 provides guidelines for protecting controlled unclassified information in nonfederal systems, and NIST SP 800-30 is about risk management."
  },
  {
    "q": "What is the outcome of setting 'imagePullPolicy: Never' in a Kubernetes pod specification?",
    "c": [
      "The image will always be pulled from the registry",
      "The pod will fail to start if the image is not present locally",
      "The image will be pulled only if not present",
      "The pod will ignore image updates in the registry",
      "The kubelet will crash"
    ],
    "a": [
      "The pod will fail to start if the image is not present locally"
    ],
    "e": "Setting 'imagePullPolicy: Never' in a Kubernetes pod specification means that the image will not be pulled from the registry. The pod will only start if the image is already present locally. This policy is useful for environments where network connectivity is limited or unreliable."
  },
  {
    "q": "When configuring encryption at rest for Kubernetes secrets using etcd, which Kubernetes component's configuration must be updated to enable this encryption?",
    "c": [
      "kube-scheduler",
      "kube-controller-manager",
      "kubelet",
      "kube-apiserver",
      "etcd"
    ],
    "a": [
      "kube-apiserver"
    ],
    "e": "Encryption at rest for Kubernetes secrets is configured by updating the kube-apiserver with an encryption configuration file. The kube-apiserver handles requests and encrypts secrets before storing them in etcd. The other components do not manage encryption configuration for secrets."
  },
  {
    "q": "What is the primary benefit of using multistage Docker builds?",
    "c": [
      "Faster build times by reusing intermediate stages",
      "Smaller and more secure final images by excluding build-time dependencies",
      "Compatibility with older Docker versions for broader deployment",
      "Simplified deployment scripts for easier automation",
      "Enhanced network performance during container communication"
    ],
    "a": [
      "Smaller and more secure final images by excluding build-time dependencies"
    ],
    "e": "The primary advantage of multistage Docker builds is the ability to create smaller and more secure final images. By separating the build and runtime stages, unnecessary build-time dependencies (e.g., compilers, libraries) are excluded from the final image. This reduces the image size, minimizes the attack surface, and enhances security. While multistage builds can indirectly improve build times by optimizing layers, their main focus is on producing leaner and safer images. They do not specifically address network performance or deployment script simplification."
  },
  {
    "q": "What is a common reason why a Kubernetes Network Policy might not be enforced as expected in a cluster?",
    "c": [
      "Network Policies are enabled by default in all clusters",
      "The installed CNI plugin does not support Network Policies",
      "The Network Policy YAML contains syntax errors",
      "The Kubernetes API server is unavailable",
      "Network Policies only apply to traffic from outside the cluster"
    ],
    "a": [
      "The installed CNI plugin does not support Network Policies"
    ],
    "e": "Network Policies in Kubernetes rely on the underlying Container Network Interface (CNI) plugin to enforce rules. If the CNI plugin does not support Network Policies, then the policies will not be enforced regardless of their correctness. While syntax errors in the YAML or API server issues can cause problems, the primary reason Network Policies might not work is lack of CNI support. Also, Network Policies affect pod-to-pod traffic within the cluster, not just external traffic."
  },
  {
    "q": "Which kubectl command lists all the nodes currently registered in a Kubernetes cluster?",
    "c": [
      "kubectl get nodes",
      "kubectl describe cluster",
      "kubectl list nodes",
      "kubectl cluster-info",
      "kubectl get cluster-nodes"
    ],
    "a": [
      "kubectl get nodes"
    ],
    "e": "'kubectl get nodes' is the standard command to list all nodes in the cluster along with their status and other summary information. 'kubectl describe cluster' and 'kubectl get cluster-nodes' are not valid commands. 'kubectl list nodes' is not a valid kubectl command. 'kubectl cluster-info' provides cluster endpoint information but does not list nodes."
  },
  {
    "q": "Which directories on a client machine contain sensitive information related to accessing Kubernetes clusters? (Select all that apply)",
    "c": [
      "/var/log/",
      "~/.kube/config",
      "/etc/hosts",
      "~/.ssh/",
      "/tmp/"
    ],
    "a": [
      "~/.kube/config",
      "~/.ssh/"
    ],
    "e": "The ~/.kube/config file stores Kubernetes cluster access credentials and configuration, making it sensitive. The ~/.ssh/ directory contains SSH keys used for secure access to nodes or clusters. Other directories like /var/log/, /etc/hosts, and /tmp/ do not typically contain sensitive Kubernetes access information."
  },
  {
    "q": "What is the purpose of the '--service-account-key-file' flag in the kube-apiserver?",
    "c": [
      "To specify the private key file used to sign service account tokens",
      "To define the service account used by the API server",
      "To store service account credentials",
      "To encrypt service account Secrets",
      "To disable service accounts"
    ],
    "a": [
      "To specify the private key file used to sign service account tokens"
    ],
    "e": "The '--service-account-key-file' flag in the kube-apiserver specifies the path to the private key file used to sign service account tokens. This key is critical for token authentication and validation. The API server uses this key to cryptographically sign tokens issued to service accounts, ensuring their authenticity. Other options are incorrect: the flag does not define which service account the API server uses, nor does it store credentials or encrypt Secrets. It also does not disable service accounts."
  },
  {
    "q": "What is an effective and consistent approach to enforce policies across multiple Kubernetes clusters?",
    "c": [
      "Manually applying policies individually on each cluster",
      "Using policy-as-code tools such as Open Policy Agent (OPA) or Kyverno",
      "Relying solely on default Kubernetes security settings",
      "Implementing different policies tailored for each environment",
      "Enforcing policies only at the application layer"
    ],
    "a": [
      "Using policy-as-code tools such as Open Policy Agent (OPA) or Kyverno"
    ],
    "e": "Using policy-as-code tools like OPA or Kyverno enables automated, consistent, and scalable enforcement of policies across multiple Kubernetes clusters. Manual application is error-prone and inconsistent. Default Kubernetes settings are minimal and insufficient for comprehensive policy enforcement. Tailoring different policies per environment can lead to inconsistencies. Enforcing policies only at the application layer misses cluster-level security controls."
  },
  {
    "q": "Which RBAC component links a ClusterRole to all authenticated users across the entire Kubernetes cluster?",
    "c": [
      "ClusterRoleBinding",
      "RoleBinding",
      "ClusterRole",
      "ServiceAccount",
      "GroupBinding"
    ],
    "a": [
      "ClusterRoleBinding"
    ],
    "e": "ClusterRoleBinding associates ClusterRoles with subjects (users/groups/serviceaccounts) cluster-wide. This is critical for security as it affects all namespaces. Best practice recommends using RoleBinding with namespaced Roles for least-privilege access."
  },
  {
    "q": "How can you retrieve the value of a secret key 'username' from the secret 'db-secret' in the namespace 'prod'?",
    "c": [
      "kubectl get secret db-secret -n prod -o jsonpath='{.data.username}' | base64 --decode",
      "kubectl describe secret db-secret -n prod",
      "kubectl get secret db-secret -n prod -o yaml",
      "kubectl read secret db-secret -n prod --key=username",
      "kubectl decode secret db-secret -n prod --field=username"
    ],
    "a": [
      "kubectl get secret db-secret -n prod -o jsonpath='{.data.username}' | base64 --decode"
    ],
    "e": "To extract and decode the secret value, you use `kubectl get` with `jsonpath` to specify the key and then decode the base64 encoded value. This method is efficient for retrieving specific secret values."
  },
  {
    "q": "What is the default service type in Kubernetes if not explicitly specified?",
    "c": [
      "ClusterIP",
      "NodePort",
      "LoadBalancer",
      "ExternalName",
      "Ingress"
    ],
    "a": [
      "ClusterIP"
    ],
    "e": "If not specified, the default service type in Kubernetes is ClusterIP. This means the service is only accessible within the cluster. Other types like NodePort or LoadBalancer are used for external access."
  },
  {
    "q": "Which of the following restrictions does the 'baseline' Pod Security Standard enforce? (Select all that apply)",
    "c": [
      "Disallows privileged containers",
      "Allows hostPath volumes",
      "Blocks host networking and ports",
      "Requires running as non-root",
      "Allows all Linux capabilities"
    ],
    "a": [
      "Disallows privileged containers",
      "Blocks host networking and ports"
    ],
    "e": "The 'baseline' Pod Security Standard disallows privileged containers and blocks host networking and ports. This ensures that pods are less vulnerable to security risks by limiting their capabilities."
  },
  {
    "q": "In Kubernetes, which securityContext setting ensures that a container runs as a non-root user to enhance security?",
    "c": [
      "runAsUser: 0",
      "runAsNonRoot: true",
      "runAsGroup: 0",
      "allowPrivilegeEscalation: false",
      "privileged: false"
    ],
    "a": [
      "runAsNonRoot: true"
    ],
    "e": "The 'runAsNonRoot: true' setting enforces that the container must run as a non-root user, preventing it from running with UID 0 (root). This enhances security by limiting container privileges. 'runAsUser: 0' explicitly sets the user to root, which is insecure. 'runAsGroup: 0' sets the group ID but doesn't enforce non-root user. 'allowPrivilegeEscalation: false' prevents privilege escalation but does not enforce non-root user. 'privileged: false' disables privileged mode but does not guarantee a non-root user."
  },
  {
    "q": "What is the primary function of a Kubernetes Service of type 'NodePort'?",
    "c": [
      "Exposes the service on a static port on each node's IP address",
      "Load balances traffic across multiple services",
      "Exposes the service externally using a cloud provider's load balancer",
      "Maps the service to an external DNS name",
      "Provides internal cluster DNS resolution"
    ],
    "a": [
      "Exposes the service on a static port on each node's IP address"
    ],
    "e": "A Kubernetes Service of type 'NodePort' exposes the service on the same static port across all nodes in the cluster, allowing external traffic to access the service via <NodeIP>:<NodePort>. It does not provide load balancing across multiple services (that is handled by ClusterIP or LoadBalancer types), nor does it map to external DNS names or provide internal DNS resolution. The LoadBalancer type is used to expose services externally via cloud provider load balancers."
  },
  {
    "q": "Which security context setting ensures that a container runs as a non-root user in Kubernetes?",
    "c": [
      "privileged: false",
      "allowPrivilegeEscalation: false",
      "runAsNonRoot: true",
      "readOnlyRootFilesystem: true",
      "capabilities: []"
    ],
    "a": [
      "runAsNonRoot: true"
    ],
    "e": "Setting 'runAsNonRoot: true' in a pod's security context ensures that the container is not run as the root user. This setting helps prevent unnecessary privilege escalation and improves container security."
  },
  {
    "q": "In Kubernetes, which resource allows multiple containers to share the same network stack, enabling them to communicate using 'localhost'?",
    "c": [
      "Pod",
      "Deployment",
      "StatefulSet",
      "Service"
    ],
    "a": [
      "Pod"
    ],
    "e": "A Pod in Kubernetes is the smallest deployable unit that can host one or more containers. Containers within the same Pod share the same network stack, including the same IP address and port space. This allows them to communicate with each other using 'localhost'. Other resources like Deployment, DaemonSet, Service, and StatefulSet are higher-level abstractions that manage Pods but do not define such shared networking behavior directly."
  },
  {
    "q": "Which API server flag is used to specify the audit policy file that defines what events are recorded in Kubernetes audit logs?",
    "c": [
      "--audit-log-path",
      "--audit-policy-file",
      "--enable-audit",
      "--audit-log-maxage",
      "--audit-log-format"
    ],
    "a": [
      "--audit-policy-file"
    ],
    "e": "The '--audit-policy-file' flag is used to specify the path to the audit policy file, which controls the granularity and types of events that are logged by the Kubernetes API server. Other flags like '--audit-log-path' specify where to write the logs, '--audit-log-maxage' controls log retention, and '--audit-log-format' defines the log format. There is no '--enable-audit' flag; audit logging is enabled by configuring these flags properly."
  },
  {
    "q": "Which Kubernetes resource enables automatic horizontal scaling of Pods based on observed CPU utilization?",
    "c": [
      "HorizontalPodAutoscaler",
      "VerticalPodAutoscaler",
      "ResourceQuota",
      "LimitRange",
      "Deployment"
    ],
    "a": [
      "HorizontalPodAutoscaler"
    ],
    "e": "The HorizontalPodAutoscaler (HPA) automatically adjusts the number of pod replicas in a deployment or replica set based on observed CPU utilization or other select metrics. VerticalPodAutoscaler adjusts resource requests and limits for containers rather than scaling pod count. ResourceQuota and LimitRange control resource usage limits but do not perform scaling. Deployment manages pod lifecycle but does not scale automatically based on CPU."
  },
  {
    "q": "Which commands can be used to list all loaded AppArmor profiles on a Linux node?",
    "c": [
      "sudo apparmor_status",
      "sudo aa-status",
      "sudo aa-enforce",
      "sudo apparmor_parser -L",
      "sudo systemctl status apparmor"
    ],
    "a": [
      "sudo apparmor_status",
      "sudo aa-status"
    ],
    "e": "Both `sudo apparmor_status` and `sudo aa-status` can be used to list all loaded AppArmor profiles on a Linux node. These commands provide detailed information about AppArmor, including the number of loaded profiles, their modes (enforce or complain), and any unconfined processes. Other options are incorrect for the following reasons: 1. `sudo aa-enforce`: This command is used to set an AppArmor profile to enforce mode, not to list profiles. 2. `sudo apparmor_parser -L`: This command is used for loading AppArmor profiles but does not list them. 3. `sudo systemctl status apparmor`: This command checks the status of the AppArmor service but does not provide a list of loaded profiles. Using either `sudo apparmor_status` or `sudo aa-status` ensures you can monitor and manage AppArmor profiles effectively."
  },
  {
    "q": "What is the purpose of the 'allowPrivilegeEscalation' field in a Kubernetes pod's security context?",
    "c": [
      "Allows the container to run as root",
      "Controls whether a process can gain more privileges than its parent process",
      "Enables privileged mode for the container",
      "Allows mounting of host directories",
      "Disables all capabilities for the container"
    ],
    "a": [
      "Controls whether a process can gain more privileges than its parent process"
    ],
    "e": "The 'allowPrivilegeEscalation' field in a Kubernetes pod's security context controls whether a process can gain more privileges than its parent process. This setting is crucial for security as it prevents potential privilege escalation attacks by limiting the capabilities of processes within a container."
  },
  {
    "q": "What is the primary function of Open Policy Agent (OPA) in Kubernetes?",
    "c": [
      "To serve as a container runtime",
      "To enforce policies and make authorization decisions",
      "To provide logging and monitoring capabilities",
      "To manage network routing",
      "To handle storage management"
    ],
    "a": [
      "To enforce policies and make authorization decisions"
    ],
    "e": "Open Policy Agent (OPA) is a general-purpose policy engine that evaluates inputs against defined policies to make authorization decisions. In Kubernetes, OPA is commonly used to enforce security and compliance policies on cluster resources. Incorrect options, such as serving as a container runtime, logging, or network management, describe functionalities unrelated to OPA's role."
  },
  {
    "q": "In the STRIDE threat modeling framework, what does 'Repudiation' refer to?",
    "c": [
      "Unauthorized access",
      "Denial of an action or event",
      "Data leakage",
      "Service unavailability",
      "Privilege escalation"
    ],
    "a": [
      "Denial of an action or event"
    ],
    "e": "'Repudiation' in STRIDE refers to the ability of an attacker or user to deny having performed an action or event, which can hinder accountability and auditing. It is distinct from unauthorized access (spoofing), data leakage (information disclosure), service unavailability (denial of service), and privilege escalation."
  },
  {
    "q": "What is the MITRE ATT&CK framework, and how is it used in cybersecurity?",
    "c": [
      "A set of compliance requirements for cloud providers",
      "A vulnerability scanning tool",
      "A knowledge base of adversary tactics and techniques used in cyberattacks",
      "An incident response guide for organizations",
      "A network security protocol for secure communication"
    ],
    "a": [
      "A knowledge base of adversary tactics and techniques used in cyberattacks"
    ],
    "e": "The MITRE ATT&CK framework is a comprehensive knowledge base that catalogs adversary tactics, techniques, and procedures (TTPs) observed in real-world cyberattacks. It is widely used by cybersecurity professionals to understand attacker behavior, improve threat detection, and enhance defense strategies. Other options are incorrect because they describe unrelated tools or concepts."
  },
  {
    "q": "Which field in the Pod spec can you use to disable privilege escalation for all containers in the Pod?",
    "c": [
      "securityContext.allowPrivilegeEscalation: false",
      "spec.containers.securityContext.allowPrivilegeEscalation: false",
      "podSecurityContext.allowPrivilegeEscalation: false",
      "spec.securityContext.allowPrivilegeEscalation: false",
      "metadata.securityContext.allowPrivilegeEscalation: false"
    ],
    "a": [
      "spec.containers.securityContext.allowPrivilegeEscalation: false"
    ],
    "e": "The correct field to disable privilege escalation for all containers in a Pod is 'spec.containers.securityContext.allowPrivilegeEscalation: false'. This must be set individually for each container within the Pod, as there is no global 'allowPrivilegeEscalation' setting at the Pod level."
  },
  {
    "q": "Which Kubernetes resource is used to request persistent storage for a Pod?",
    "c": [
      "PersistentVolume",
      "PersistentVolumeClaim",
      "StorageClass",
      "VolumeMount",
      "ConfigMap"
    ],
    "a": [
      "PersistentVolumeClaim"
    ],
    "e": "A PersistentVolumeClaim (PVC) is used by a Pod to request persistent storage resources. The PVC is matched with a PersistentVolume (PV), which provides the actual storage. StorageClasses are used to dynamically provision PersistentVolumes."
  },
  {
    "q": "What is a primary security risk associated with running a container in privileged mode?",
    "c": [
      "Increased memory usage",
      "Limited network access",
      "Container gaining unrestricted access to host resources, posing security risks",
      "Reduced application performance",
      "Inability to use persistent volumes"
    ],
    "a": [
      "Container gaining unrestricted access to host resources, posing security risks"
    ],
    "e": "Running a container in privileged mode grants it almost the same access to the host as the root user, including direct access to host devices and kernel capabilities. This significantly increases the risk of container breakout and host compromise. The other options, such as increased memory usage or reduced performance, are not typical consequences of privileged mode, and privileged containers can still use persistent volumes and network access normally."
  },
  {
    "q": "In a Kubernetes Pod specification, which field is used to define Linux capabilities for an individual container?",
    "c": [
      "securityContext.capabilities",
      "spec.capabilities",
      "container.securityContext.capabilities",
      "podSecurityContext.capabilities",
      "linuxOptions.capabilities"
    ],
    "a": [
      "securityContext.capabilities"
    ],
    "e": "Linux capabilities for containers are specified under the 'securityContext.capabilities' field within the container's specification. This allows fine-grained control over the capabilities added or dropped for that specific container."
  },
  {
    "q": "Which methods can be used to isolate resources effectively in a multi-tenant Kubernetes environment? (Select all that apply)",
    "c": [
      "Deploying separate Kubernetes clusters for each tenant",
      "Using Kubernetes namespaces combined with Role-Based Access Control (RBAC)",
      "Applying Kubernetes Network Policies to restrict traffic",
      "Sharing service accounts among tenants to simplify access",
      "Disabling resource quotas to allow unlimited resource usage"
    ],
    "a": [
      "Deploying separate Kubernetes clusters for each tenant",
      "Using Kubernetes namespaces combined with Role-Based Access Control (RBAC)",
      "Applying Kubernetes Network Policies to restrict traffic"
    ],
    "e": "Effective resource isolation in multi-tenant Kubernetes environments can be achieved by deploying separate clusters, using namespaces with RBAC to control access, and applying network policies to restrict communication. Sharing service accounts among tenants reduces isolation and is insecure. Disabling resource quotas removes limits on resource consumption, which can lead to resource contention and is not recommended."
  },
  {
    "q": "What is the main purpose of an Ingress Controller in Kubernetes?",
    "c": [
      "To expose services outside the cluster using HTTP/HTTPS",
      "To manage internal pod communication",
      "To store and manage secrets",
      "To schedule pods to nodes",
      "To provide persistent storage"
    ],
    "a": [
      "To expose services outside the cluster using HTTP/HTTPS"
    ],
    "e": "Ingress Controllers in Kubernetes manage external access to cluster services via HTTP/HTTPS. They act as entry points for incoming HTTP requests and route them to appropriate services within the cluster, allowing for load balancing, SSL termination, and path-based routing."
  },
  {
    "q": "Which of the following are key advantages of implementing a Service Mesh in Kubernetes? (Select all that apply)",
    "c": [
      "Built-in observability through metrics, logs, and traces",
      "Simplifies application code by offloading cross-cutting concerns",
      "Enhanced security through mutual TLS encryption",
      "Adds significant latency to all communications",
      "Requires minimal operational expertise to implement"
    ],
    "a": [
      "Built-in observability through metrics",
      "logs",
      "and traces",
      "Simplifies application code by offloading cross-cutting concerns",
      "Enhanced security through mutual TLS encryption"
    ],
    "e": "Service Meshes provide three primary benefits: 1) Comprehensive observability through automatic collection of communication metrics and distributed tracing. 2) Offloading of cross-cutting concerns like retries, timeouts, and circuit breaking from application code. 3) Security enhancements through automatic mutual TLS and fine-grained access controls. While they add some overhead, modern implementations minimize latency impact through optimized data planes."
  },
  {
    "q": "When creating a NetworkPolicy to implement default deny egress traffic for Kubernetes pods, which policyTypes value must be specified?",
    "c": [
      "Ingress only",
      "Egress only",
      "Both Ingress and Egress",
      "DenyAll policy type",
      "Egress with explicit deny rules"
    ],
    "a": [
      "Egress only"
    ],
    "e": "To create default deny egress, policyTypes must include Egress, and no egress rules should be defined. This combination blocks all outgoing traffic while allowing explicit exceptions through subsequent allow rules. The Kubernetes NetworkPolicy documentation emphasizes this pattern for implementing zero-trust network policies."
  },
  {
    "q": "In a Kubernetes container's securityContext, which field allows you to add specific Linux capabilities to the container?",
    "c": [
      "addCapabilities",
      "linuxCapabilities",
      "capabilities.add",
      "securityOptions",
      "privilegedCaps"
    ],
    "a": [
      "capabilities.add"
    ],
    "e": "The correct field is 'capabilities.add', which is a list under the container's securityContext that specifies which Linux capabilities to add to the container's default set. 'addCapabilities' and 'linuxCapabilities' are incorrect field names. 'securityOptions' and 'privilegedCaps' are not valid Kubernetes securityContext fields."
  },
  {
    "q": "When an attacker gains access to a Kubernetes pod, which of the following attack scenarios is typically not persistent after the pod restarts?",
    "c": [
      "Modifying the container image stored in the registry",
      "Installing malware inside the pod's ephemeral filesystem",
      "Exfiltrating data from the pod during its runtime",
      "Altering data stored in a mounted PersistentVolume",
      "Changing configurations stored in a ConfigMap"
    ],
    "a": [
      "Installing malware inside the pod's ephemeral filesystem"
    ],
    "e": "The pod's filesystem is ephemeral, meaning any changes such as malware installation inside the container's filesystem are lost when the pod restarts. Modifications to the container image in the registry, persistent volumes, or ConfigMaps are persistent because they exist outside the pod lifecycle. Data exfiltration is a runtime activity and does not persist but can have lasting impact."
  },
  {
    "q": "How do you port-forward a local port to a port on a Kubernetes pod?",
    "c": [
      "kubectl port-forward <pod-name> <local-port>:<pod-port>",
      "kubectl forward-port <pod-name> <local-port>:<pod-port>",
      "kubectl tunnel <pod-name> <local-port>:<pod-port>",
      "kubectl proxy <pod-name> --port=<local-port>",
      "kubectl connect <pod-name> --port=<local-port>"
    ],
    "a": [
      "kubectl port-forward <pod-name> <local-port>:<pod-port>"
    ],
    "e": "To port-forward a local port to a port on a Kubernetes pod, you use the command 'kubectl port-forward <pod-name> <local-port>:<pod-port>'. This command allows you to access the pod's port from your local machine."
  },
  {
    "q": "Which guidance document provides best practices for mitigating supply chain risks in Kubernetes environments?",
    "c": [
      "TOGAF Enterprise Architecture Framework",
      "OWASP Top 10 Security Risks",
      "NSA/CISA Kubernetes Hardening Guidance",
      "ITIL Service Management Framework",
      "SRE (Site Reliability Engineering) Handbook"
    ],
    "a": [
      "NSA/CISA Kubernetes Hardening Guidance"
    ],
    "e": "The NSA/CISA Kubernetes Hardening Guidance outlines strategies to mitigate supply chain risks in Kubernetes environments. It includes recommendations for securing container images, implementing role-based access control (RBAC), and ensuring secure configurations for clusters."
  },
  {
    "q": "What is the primary function of a Horizontal Pod Autoscaler (HPA) in Kubernetes?",
    "c": [
      "Automatically scales nodes",
      "Scales pods based on CPU utilization",
      "Schedules pods to nodes",
      "Balances network traffic",
      "Manages storage volumes"
    ],
    "a": [
      "Scales pods based on CPU utilization"
    ],
    "e": "A Horizontal Pod Autoscaler (HPA) in Kubernetes automatically adjusts the number of replicas of a pod based on observed CPU utilization or other custom metrics. This helps ensure that the application has sufficient resources to handle the current workload without over-allocating resources when demand is low."
  },
  {
    "q": "Which Kubernetes resource type allows cluster administrators to define and enforce the use of specific container runtimes like gVisor or Kata Containers?",
    "c": [
      "Containers?",
      "Runtime",
      "RuntimeClass",
      "PodSecurityPolicy",
      "SecurityContext",
      "ContainerRuntime"
    ],
    "a": [
      "RuntimeClass"
    ],
    "e": "RuntimeClass is a first-class Kubernetes resource that specifies container runtime configurations. It enables security-conscious runtime selection (like gVisor's sandboxed environment) while maintaining portability across different container runtimes. PodSecurityPolicy (deprecated in v1.21) handled security policies but not runtime selection."
  },
  {
    "q": "What are the key principles of the 4 Cs of cloud-native security?",
    "c": [
      "Encrypting data at rest only",
      "Applying security at Code, Container, Cluster, and Cloud levels",
      "Relying solely on cloud provider security",
      "Using containers to bypass security checks",
      "Limiting security to the network layer"
    ],
    "a": [
      "Applying security at Code, Container, Cluster, and Cloud levels"
    ],
    "e": "The 4 Cs of cloud-native security emphasize the importance of applying security measures at multiple levels: Code (secure coding practices), Container (secure containerization), Cluster (secure Kubernetes clusters), and Cloud (secure cloud infrastructure). This layered approach ensures comprehensive security."
  },
  {
    "q": "What are the four key areas of focus for cloud-native security, often referred to as the '4 Cs'?",
    "c": [
      "Code, Container, Cluster, Cloud",
      "Compute, Connectivity, Compliance, Cost",
      "Cloud, Core, Control, Compliance",
      "Code, Continuous Integration, Cloud, Compliance",
      "Containerization, Coordination, Configuration, Control"
    ],
    "a": [
      "Code, Container, Cluster, Cloud"
    ],
    "e": "The '4 Cs' of cloud-native security are Code, Container, Cluster, and Cloud. These represent the layers where security should be applied to ensure comprehensive protection across the entire cloud-native stack."
  },
  {
    "q": "How can you enable debug-level logging for the Kubernetes kubelet component?",
    "c": [
      "Set the verbosity level to 4 by adding '--v=4' to the kubelet startup arguments",
      "Run the command 'kubectl debug kubelet'",
      "Modify the kubelet configuration file to set 'logLevel: debug'",
      "Restart the kubelet with the flag '--debug=true'",
      "Debug logging cannot be enabled for the kubelet"
    ],
    "a": [
      "Set the verbosity level to 4 by adding '--v=4' to the kubelet startup arguments"
    ],
    "e": "Debug logging in kubelet is enabled by increasing the verbosity level through the '--v' flag, with '--v=4' commonly used to enable debug-level logs. The other options are incorrect: 'kubectl debug kubelet' is not a valid command; kubelet configuration does not use a 'logLevel' field; '--debug=true' is not a recognized flag; and debug logging is indeed possible and commonly used for troubleshooting."
  },
  {
    "q": "Which command is used to apply configuration changes defined in 'deployment.yaml' to a Kubernetes resource?",
    "c": [
      "kubectl create -f deployment.yaml",
      "kubectl apply -f deployment.yaml",
      "kubectl set -f deployment.yaml",
      "kubectl update -f deployment.yaml",
      "kubectl replace -f deployment.yaml"
    ],
    "a": [
      "kubectl apply -f deployment.yaml"
    ],
    "e": "The 'kubectl apply -f deployment.yaml' command applies configuration changes to a Kubernetes resource defined in the YAML file. It uses declarative management, ensuring that the resource's current state matches the desired state specified in the file. Other commands like 'kubectl create' are used for creating resources but do not update existing ones, while 'kubectl replace' replaces the entire resource instead of merging changes."
  },
  {
    "q": "What is the recommended approach to secure the Kubernetes Dashboard?",
    "c": [
      "Expose it publicly without authentication",
      "Use Role-Based Access Control (RBAC) and restrict access",
      "Grant it cluster-admin privileges",
      "Disable it entirely",
      "Run it as a privileged container"
    ],
    "a": [
      "Use Role-Based Access Control (RBAC) and restrict access"
    ],
    "e": "Securing the Kubernetes Dashboard with Role-Based Access Control (RBAC) is crucial to limit exposure and ensure that only authorized users can access and manage cluster resources. This approach helps prevent unauthorized access and reduces the attack surface by enforcing strict access controls. For guidance on securing the Dashboard, refer to Kubernetes security best practices and RBAC documentation[1][3]."
  },
  {
    "q": "Which Kubernetes Pod specification field allows you to inject environment variables from a ConfigMap into containers?",
    "c": [
      "VolumeMount",
      "envFrom",
      "Secret",
      "Annotation",
      "Label"
    ],
    "a": [
      "envFrom"
    ],
    "e": "The 'envFrom' field in a Pod specification enables injecting all key-value pairs from a ConfigMap as environment variables into the container. 'VolumeMount' is used for mounting volumes, 'Secret' is a separate object for sensitive data, 'Annotation' and 'Label' are metadata and do not inject environment variables."
  },
  {
    "q": "How can you ensure that only signed images are run in your Kubernetes cluster?",
    "c": [
      "Use imagePullSecrets",
      "Configure admission controllers to verify image signatures",
      "Manually inspect images before deployment",
      "Disable image caching on nodes",
      "Use a private container registry"
    ],
    "a": [
      "Configure admission controllers to verify image signatures"
    ],
    "e": "To ensure only signed images are run in a Kubernetes cluster, you can configure admission controllers like Gatekeeper or Kyverno to enforce policies that verify image signatures. This ensures that only trusted images are deployed."
  },
  {
    "q": "Which Kubernetes admission controller runs first during the admission control process?",
    "c": [
      "ValidatingAdmissionWebhook",
      "MutatingAdmissionWebhook",
      "ResourceQuota",
      "NamespaceLifecycle",
      "AlwaysPullImages"
    ],
    "a": [
      "MutatingAdmissionWebhook"
    ],
    "e": "The MutatingAdmissionWebhook runs first in the Kubernetes admission control process. This is because mutating admission controllers are designed to modify the incoming request before it is validated by validating admission controllers. Other options, such as ValidatingAdmissionWebhook, ResourceQuota, NamespaceLifecycle, and AlwaysPullImages, either run later in the process or serve different purposes."
  },
  {
    "q": "In which scenarios is soft multi-tenancy preferred over hard multi-tenancy in cloud-native environments?",
    "c": [
      "When strict tenant isolation is mandatory",
      "For workloads from untrusted tenants requiring strong isolation",
      "To maximize resource utilization efficiency in trusted tenant environments",
      "When compliance with strict regulatory requirements is necessary",
      "When deploying workloads across multiple Kubernetes clusters"
    ],
    "a": [
      "To maximize resource utilization efficiency in trusted tenant environments"
    ],
    "e": "Soft multi-tenancy is preferred when tenants are trusted and strict isolation is not required, allowing for more efficient sharing of resources. Hard multi-tenancy, by contrast, enforces strict isolation suitable for untrusted tenants or compliance-driven environments. Therefore, soft multi-tenancy optimizes resource usage in trusted settings but is not suitable where strong isolation or regulatory compliance is mandatory."
  },
  {
    "q": "What is the primary role of Public Key Infrastructure (PKI) in IT security?",
    "c": [
      "Managing network configurations",
      "Handling storage volumes",
      "Issuing and managing digital certificates and encryption keys",
      "Maintaining container images",
      "Collecting and analyzing application logs"
    ],
    "a": [
      "Issuing and managing digital certificates and encryption keys"
    ],
    "e": "Public Key Infrastructure (PKI) is a framework that manages digital certificates and encryption keys to enable secure communication and authentication over networks. It does not handle network configurations, storage volumes, container images, or application logs. PKI ensures trust by issuing certificates that verify identities and encrypt data."
  },
  {
    "q": "Which kubectl command is used to create a pod directly from a container image?",
    "c": [
      "kubectl create pod <pod-name> --image=<image>",
      "kubectl run <pod-name> --image=<image>",
      "kubectl new pod <pod-name> --image=<image>",
      "kubectl pod <pod-name> --image=<image>",
      "kubectl deploy pod <pod-name> --image=<image>"
    ],
    "a": [
      "kubectl run <pod-name> --image=<image>"
    ],
    "e": "The 'kubectl run' command is used to create a pod or deployment from a specified container image. It is the standard way to quickly start a pod with a given image. The other options are invalid commands or syntaxes that do not exist in kubectl."
  },
  {
    "q": "What is the default Kubernetes behavior when a container exceeds its configured memory limit?",
    "c": [
      "The container is throttled",
      "The container is terminated",
      "The pod is moved to another node",
      "Kubernetes does nothing",
      "Additional memory is allocated"
    ],
    "a": [
      "The container is terminated"
    ],
    "e": "When a container exceeds its memory limit, the Kubernetes kubelet kills the container to prevent it from affecting other workloads. This is known as an Out Of Memory (OOM) kill. The container is terminated and may be restarted depending on the pod's restart policy. CPU limits result in throttling, but memory limits cause termination. Kubernetes does not move pods automatically to other nodes or allocate additional memory beyond the specified limit."
  },
  {
    "q": "What is the primary function of the Open Policy Agent (OPA) in Kubernetes environments?",
    "c": [
      "A tool for monitoring and analyzing cluster performance metrics",
      "A general-purpose policy engine that enables defining and enforcing custom policies",
      "A built-in Kubernetes admission controller for validating resources",
      "A network policy enforcement tool for controlling pod communication",
      "A secret management system for storing sensitive data"
    ],
    "a": [
      "A general-purpose policy engine that enables defining and enforcing custom policies"
    ],
    "e": "Open Policy Agent (OPA) is a flexible, general-purpose policy engine that allows administrators to define and enforce custom policies across Kubernetes and other systems. It integrates with Kubernetes admission controllers but is not itself built-in. OPA is not a monitoring tool, network policy enforcer, or secret management system, although it can be used to enforce policies related to these areas."
  },
  {
    "q": "Which kubectl command displays the Kubernetes client and server versions for the cluster?",
    "c": [
      "kubectl version",
      "kubectl get version",
      "kubectl cluster-info",
      "kubectl describe cluster",
      "kubectl info"
    ],
    "a": [
      "kubectl version"
    ],
    "e": "The command 'kubectl version' shows both the client and server (cluster) Kubernetes versions, which is useful for verifying compatibility and troubleshooting. Other commands like 'kubectl get version' or 'kubectl info' are invalid or do not provide version details. 'kubectl cluster-info' provides cluster endpoint information but not version details."
  },
  {
    "q": "In Kubernetes Role-Based Access Control (RBAC), what is the purpose of a RoleBinding?",
    "c": [
      "Defines permissions within a namespace",
      "Associates a Role with users, groups, or service accounts within a namespace",
      "Creates a new role with cluster-wide permissions",
      "Manages network policies for a namespace",
      "Sets resource quotas for a project"
    ],
    "a": [
      "Associates a Role with users, groups, or service accounts within a namespace"
    ],
    "e": "A RoleBinding in Kubernetes RBAC binds a Role to one or more subjects (users, groups, or service accounts) within a specific namespace, granting them the permissions defined in that Role. Roles themselves define permissions, but RoleBindings associate those permissions with subjects. ClusterRoles and ClusterRoleBindings are used for cluster-wide permissions. Network policies and resource quotas are managed by different Kubernetes objects unrelated to RoleBindings."
  },
  {
    "q": "What is the primary difference between MicroVM and User-Space Kernel approaches in cloud native security?",
    "c": [
      "MicroVMs are larger in size",
      "User-space kernels provide hardware virtualization",
      "MicroVMs run directly on hardware without a host OS",
      "User-space kernels intercept system calls in user space",
      "There is no difference; they are the same"
    ],
    "a": [
      "User-space kernels intercept system calls in user space"
    ],
    "e": "The primary difference lies in how they operate. User-space kernels, like gVisor, run in user space and intercept system calls, providing a lightweight sandboxing mechanism. MicroVMs, on the other hand, are full-fledged virtual machines that run directly on hardware but require a host OS for management."
  },
  {
    "q": "Which tool is specifically designed to perform static security analysis of Kubernetes manifests to identify potential security issues?",
    "c": [
      "kube-bench",
      "kube-hunter",
      "kube-score",
      "kubectl describe",
      "kubesec"
    ],
    "a": [
      "kubesec"
    ],
    "e": "Kubesec is a static analysis tool that scans Kubernetes manifests for security risks and best practices violations before deployment. 'kube-bench' checks cluster nodes against CIS benchmarks, 'kube-hunter' performs active scanning for vulnerabilities, 'kube-score' provides general manifest validation but is less focused on security, and 'kubectl describe' is a CLI command for inspecting resources."
  },
  {
    "q": "What are the potential impacts of enabling detailed auditing of request responses in a Kubernetes cluster?",
    "c": [
      "Performance overhead and increased storage usage due to detailed logs",
      "Increased network latency between pods",
      "Reduced security due to exposure of sensitive data in logs",
      "Decreased reliability of the Kubernetes API server" 
    ],
    "a": [
      "Performance overhead and increased storage usage due to detailed logs"
    ],
    "e": "Enabling detailed auditing of request responses in Kubernetes increases the volume and detail of audit logs generated, leading to higher storage consumption and potential performance overhead on the API server. While detailed auditing improves security visibility, it must be balanced against these resource impacts."
  },
  {
    "q": "How do Kubernetes NetworkPolicies enhance cluster security when properly configured?",
    "c": [
      "Enable automatic TLS certificate rotation",
      "Enforce least-privilege communication between pods",
      "Manage persistent volume encryption",
      "Provide application auto-scaling capabilities",
      "Enable cluster-wide logging aggregation"
    ],
    "a": [
      "Enforce least-privilege communication between pods"
    ],
    "e": "NetworkPolicies implement microsegmentation by controlling pod-to-pod communication through label selectors, effectively enforcing zero-trust networking principles. They prevent lateral movement attacks by restricting traffic flows between services. Other options describe unrelated features: TLS (option 1), storage (option 3), scaling (option 4), and logging (option 5) require different configurations."
  },
  {
    "q": "Which command calculates the SHA256 checksum of the file '/usr/bin/kubelet' on a Linux system?",
    "c": [
      "sha1sum /usr/bin/kubelet",
      "md5sum /usr/bin/kubelet",
      "checksum -sha256 /usr/bin/kubelet",
      "sha256sum /usr/bin/kubelet",
      "hash -a sha256 /usr/bin/kubelet"
    ],
    "a": [
      "sha256sum /usr/bin/kubelet"
    ],
    "e": "The command 'sha256sum /usr/bin/kubelet' computes the SHA256 checksum of the specified file, which is commonly used to verify file integrity. 'sha1sum' and 'md5sum' calculate different hash algorithms (SHA1 and MD5 respectively). 'checksum -sha256' and 'hash -a sha256' are not standard Linux commands for checksum calculation."
  },
  {
    "q": "What is the primary function of a 'RoleBinding' in Kubernetes RBAC?",
    "c": [
      "Defines cluster-wide permissions",
      "Binds a ClusterRole to a namespace",
      "Binds a Role to users or groups within a namespace",
      "Creates a new ServiceAccount",
      "Defines network policies"
    ],
    "a": [
      "Binds a Role to users or groups within a namespace"
    ],
    "e": "A RoleBinding in Kubernetes assigns a Role to specific users or groups within a namespace, granting them the permissions defined by that Role."
  },
  {
    "q": "What is a significant security risk associated with not restricting egress traffic in a Kubernetes cluster?",
    "c": [
      "It complicates the debugging process for network-related issues.",
      "It leads to reduced latency in network communications within the cluster.",
      "It creates a potential pathway for data exfiltration from compromised pods to external, unauthorized destinations.",
      "It enhances and simplifies pod-to-pod communication within the cluster.",
      "It simplifies network configuration, reducing the complexity of network policies."
    ],
    "a": [
      "It creates a potential pathway for data exfiltration from compromised pods to external, unauthorized destinations."
    ],
    "e": "Failing to restrict egress traffic in Kubernetes can expose the cluster to significant security risks, most notably data exfiltration. Without proper egress controls, a compromised pod can freely communicate with external servers, potentially leaking sensitive data to attackers. While unrestricted egress might simplify initial network configurations, the security implications far outweigh any convenience gained. Restricting egress traffic is a critical security measure to limit the attack surface and prevent unauthorized communication from within the cluster."
  },
  {
    "q": "Which command lists all installed packages on a Debian-based Linux system using the apt package manager?",
    "c": [
      "apt list --installed",
      "dpkg -l",
      "rpm -qa",
      "yum list installed",
      "pkg info"
    ],
    "a": [
      "apt list --installed"
    ],
    "e": "The command 'apt list --installed' displays all packages installed via the apt package manager on Debian-based systems. While 'dpkg -l' also lists installed packages, it shows lower-level package information and is not specific to apt. 'rpm -qa' and 'yum list installed' are commands used on RPM-based systems like Red Hat or CentOS, and 'pkg info' is used in BSD-based systems, making them incorrect for Debian-based systems."
  },
  {
    "q": "Which Kubernetes object specifically controls inbound/outbound network traffic between Pods at the IP address and port level?",
    "c": [
      "NetworkPolicy",
      "Ingress",
      "Service",
      "Endpoint",
      "FirewallRule"
    ],
    "a": [
      "NetworkPolicy"
    ],
    "e": "NetworkPolicy objects define granular rules for Pod-to-Pod communication, including allowed ingress/egress traffic. While Services enable network access to Pods and Ingress manages external HTTP(S) routing, NetworkPolicy provides critical microsegmentation capabilities for zero-trust security architectures."
  },
  {
    "q": "In the STRIDE threat model, which category best describes a Trojan horse that compromises a build server?",
    "c": [
      "Spoofing",
      "Repudiation",
      "Information Disclosure",
      "Denial of Service",
      "Tampering"
    ],
    "a": [
      "Tampering"
    ],
    "e": "A Trojan horse compromising a build server is an example of tampering because it involves unauthorized modification of system components or data. Tampering refers to malicious alterations that can affect the integrity of software or systems. Spoofing involves impersonation, repudiation relates to denial of actions, information disclosure concerns unauthorized data exposure, and denial of service targets availability, none of which precisely describe this scenario."
  },
  {
    "q": "Can you enforce more than one Pod Security Admission (PSA) policy level concurrently within a single namespace?",
    "c": [
      "Yes, by applying multiple labels",
      "No, only one policy level per namespace",
      "Yes, but only with custom configurations",
      "Only if the namespace is partitioned",
      "It depends on the Kubernetes version"
    ],
    "a": [
      "No, only one policy level per namespace"
    ],
    "e": "PSA policies are applied at the namespace level. Only one PSA policy level (privileged, baseline, or restricted) can be enforced per namespace for each mode (enforce, audit, or warn). This ensures clear and consistent policy enforcement."
  },
  {
    "q": "When you run the command 'kubectl apply', which Kubernetes component processes the request first?",
    "c": [
      "etcd",
      "kube-scheduler",
      "kube-controller-manager",
      "kube-apiserver",
      "kubelet"
    ],
    "a": [
      "kube-apiserver"
    ],
    "e": "All kubectl commands interact first with the kube-apiserver, which is the central management entity of the Kubernetes control plane. The API server authenticates and validates the request, then persists the desired state in etcd. Other components like the scheduler and controller manager act later based on the updated state."
  },
  {
    "q": "How can you expose a Kubernetes deployment as a service?",
    "c": [
      "kubectl expose deployment my-deployment",
      "kubectl service deployment my-deployment",
      "kubectl create service my-deployment",
      "kubectl generate service my-deployment",
      "kubectl map service my-deployment"
    ],
    "a": [
      "kubectl expose deployment my-deployment"
    ],
    "e": "The `kubectl expose` command creates a Service that exposes the deployment, allowing access to the pods within the deployment from outside the cluster."
  },
  {
    "q": "What command can you use to edit a Kubernetes resource directly in your default editor?",
    "c": [
      "kubectl change <resource>",
      "kubectl update <resource>",
      "kubectl edit <resource>",
      "kubectl modify <resource>",
      "kubectl adjust <resource>"
    ],
    "a": [
      "kubectl edit <resource>"
    ],
    "e": "The 'kubectl edit' command is used to edit a Kubernetes resource directly in your default editor. This command opens the resource's configuration file in your editor, allowing you to make changes before saving and applying them."
  },
  {
    "q": "Which Kubernetes resource is used to assign permissions within a namespace to a user or group?",
    "c": [
      "ClusterRole",
      "Role",
      "ClusterRoleBinding",
      "RoleBinding",
      "ServiceAccount"
    ],
    "a": [
      "RoleBinding"
    ],
    "e": "A RoleBinding is used to grant permissions defined in a Role to users or groups within a specific namespace. This is essential for fine-grained access control in Kubernetes."
  },
  {
    "q": "What is the primary function of the Kubernetes scheduler in a cluster?",
    "c": [
      "To monitor the overall health of the cluster",
      "To assign pods to nodes based on resource availability and scheduling policies",
      "To manage service discovery within the cluster",
      "To enforce network policies between pods",
      "To control user access to the Kubernetes API server"
    ],
    "a": [
      "To assign pods to nodes based on resource availability and scheduling policies"
    ],
    "e": "The Kubernetes scheduler is responsible for selecting the most suitable node for each pod to run on, based on resource availability, constraints, and scheduling policies. It does not monitor cluster health, manage service discovery, enforce network policies, or control API server access. Those responsibilities belong to other components like the kube-controller-manager, CoreDNS, network plugins, and the API server's authentication/authorization mechanisms."
  },
  {
    "q": "How can you retrieve the digest (content hash) of the Docker image 'nginx:1.19' using the Docker CLI?",
    "c": [
      "docker images nginx:1.19 --digests",
      "docker inspect nginx:1.19 --format='{{.Id}}'",
      "docker pull nginx@sha256",
      "docker inspect --format='{{index .RepoDigests 0}}' nginx:1.19",
      "docker tag nginx:1.19 nginx:sha256"
    ],
    "a": [
      "docker inspect --format='{{index .RepoDigests 0}}' nginx:1.19"
    ],
    "e": "The command 'docker inspect --format='{{index .RepoDigests 0}}' nginx:1.19' extracts the image digest from the image's metadata, showing the content-addressable identifier (digest) of the image. Option 1 lists digests for all images but may not show the specific digest for the tag. Option 2 shows the image ID, which is different from the digest. Option 3 is incomplete and incorrect syntax. Option 5 is unrelated to obtaining the digest, as it tags images but does not display digests."
  },
  {
    "q": "Which command is recommended to check the readiness and status of Kubernetes cluster components?",
    "c": [
      "kubectl get components",
      "kubectl get --raw='/readyz?verbose'",
      "kubectl get cs",
      "kubectl get componentstatuses",
      "kubectl describe components"
    ],
    "a": [
      "kubectl get --raw='/readyz?verbose'"
    ],
    "e": "The command `kubectl get --raw='/readyz?verbose'` is the recommended way to check the readiness and status of Kubernetes cluster components. This approach provides detailed and up-to-date information about the health of the cluster. Other commands, such as `kubectl get cs` (deprecated shorthand) and `kubectl get componentstatuses` (deprecated endpoint), are no longer reliable in newer Kubernetes versions."
  },
  {
    "q": "To enable audit logging in Kubernetes, which flag must be added to the API server configuration to specify the log file path?",
    "c": [
      "--audit-log-path",
      "--audit-policy-file",
      "--enable-audit",
      "--audit-log-maxage",
      "--audit-log-format"
    ],
    "a": [
      "--audit-log-path"
    ],
    "e": "The '--audit-log-path' flag is crucial for enabling audit logging by specifying the path where audit logs will be stored. This allows for the collection and analysis of API requests and responses, which is essential for security auditing and compliance."
  },
  {
    "q": "In Kubernetes, how can you apply an AppArmor profile to all containers within a Pod?",
    "c": [
      "Set the profile in the Pod's securityContext",
      "Annotate each container with the AppArmor profile",
      "Use the 'appArmorProfile' field in the container spec",
      "Specify the profile in the Deployment's metadata",
      "Set the profile in the node's AppArmor configuration"
    ],
    "a": [
      "Annotate each container with the AppArmor profile",
      "Use the 'appArmorProfile' field in the container spec"
    ],
    "e": "To apply an AppArmor profile to all containers in a Pod, you can use one of two methods: 1. **Annotations**: Use the annotation `container.apparmor.security.beta.kubernetes.io/<container_name>: <profile_ref>` for each container in the Pod. This method has been traditionally used and is backward-compatible. 2. **`appArmorProfile` field in `securityContext`**: Starting with Kubernetes v1.30, you can specify the AppArmor profile directly in the `securityContext` of a container using the `appArmorProfile` field. This method is more intuitive and avoids relying on annotations. Other options, such as setting it in the Deployment metadata or node-level configuration, are not valid methods for applying AppArmor profiles to specific containers."
  },
  {
    "q": "Which statement best describes the purpose of the CIS Controls in the context of enterprise cybersecurity?",
    "c": [
      "They define licensing restrictions for enterprise software",
      "They specify hardware requirements for data center appliances",
      "They provide a prioritized set of cybersecurity best practices to defend against common cyber attacks",
      "They offer guidelines for AI-based container scheduling",
      "They focus exclusively on physical security measures"
    ],
    "a": [
      "They provide a prioritized set of cybersecurity best practices to defend against common cyber attacks"
    ],
    "e": "The CIS Controls are a set of prioritized cybersecurity best practices designed to help organizations defend against the most common and pervasive cyber threats. They provide actionable guidance for improving security posture. The other options are incorrect because CIS Controls do not deal with software licensing, hardware specifications, AI scheduling, or solely physical security."
  },
  {
    "q": "What is the primary purpose of audit logging in Kubernetes?",
    "c": [
      "To monitor application performance",
      "To track and record API server requests for security and compliance auditing",
      "To manage network policies",
      "To automatically scale applications based on load",
      "To store container images"
    ],
    "a": [
      "To track and record API server requests for security and compliance auditing"
    ],
    "e": "Audit logging in Kubernetes is designed to record all requests made to the API server, capturing details about who did what and when. This information is crucial for security auditing, compliance monitoring, and forensic analysis. It is not intended for monitoring application performance, managing network policies, scaling applications, or storing container images, which are handled by other Kubernetes components or tools."
  },
  {
    "q": "Which best defines PCI DSS in a containerized environment?",
    "c": [
      "A software license for open-source container platforms",
      "A set of security standards for systems handling cardholder data, applicable to container-based workflows",
      "A Kubernetes admission controller for preventing configuration drift",
      "A recommended approach to container performance tuning",
      "A zero-trust compliance framework for data science workloads"
    ],
    "a": [
      "A set of security standards for systems handling cardholder data, applicable to container-based workflows"
    ],
    "e": "PCI DSS in a containerized environment refers to the application of its security standards to workflows that handle cardholder data within containers. This includes ensuring compliance with requirements such as network segmentation, access control, and real-time monitoring. Other options are incorrect because they either mischaracterize PCI DSS or describe unrelated concepts like software licenses or Kubernetes-specific tools."
  },
  {
    "q": "In a Dockerfile, which instruction is used to specify that the container should run as a non-root user?",
    "c": [
      "FROM nonroot",
      "USER nobody",
      "RUN chmod 777 /app",
      "EXPOSE 80",
      "ENTRYPOINT [\"/app\"]"
    ],
    "a": [
      "USER nobody"
    ],
    "e": "The 'USER' instruction in a Dockerfile sets the user under which the container process runs. Using 'USER nobody' ensures the application runs as a non-root user, enhancing container security. 'FROM nonroot' is not a valid instruction, 'RUN chmod 777 /app' changes permissions but does not change the user, 'EXPOSE' declares ports, and 'ENTRYPOINT' specifies the executable."
  },
  {
    "q": "Why is a ConfigMap not suitable for storing sensitive information such as secrets in Kubernetes?",
    "c": [
      "ConfigMaps cannot be mounted as volumes in pods",
      "ConfigMaps do not support key-value pairs",
      "Data stored in ConfigMaps is kept in plain text and not encrypted",
      "ConfigMaps are deprecated in recent Kubernetes versions",
      "ConfigMaps have strict size limitations that prevent storing secrets"
    ],
    "a": [
      "Data stored in ConfigMaps is kept in plain text and not encrypted"
    ],
    "e": "ConfigMaps are designed to store non-sensitive configuration data as key-value pairs and store data in plain text within etcd. They do not provide encryption or access controls suitable for sensitive information. Secrets, on the other hand, are specifically designed to store sensitive data and can be encrypted at rest. ConfigMaps can be mounted as volumes and are not deprecated. While ConfigMaps have size limits, the primary reason they are unsuitable for secrets is the lack of security."
  },
  {
    "q": "Why is it crucial to restrict access to etcd in a Kubernetes cluster?",
    "c": [
      "Because etcd stores logs that can be tampered with",
      "Because etcd contains all cluster data, including secrets, and access can lead to cluster compromise",
      "Because etcd runs the application code",
      "Because etcd controls network policies",
      "Because etcd is not important and can be ignored"
    ],
    "a": [
      "Because etcd contains all cluster data, including secrets, and access can lead to cluster compromise"
    ],
    "e": "Restricting access to etcd is vital because it stores sensitive data, including cluster secrets. Unauthorized access to etcd can compromise the entire Kubernetes cluster."
  },
  {
    "q": "What does the '--anonymous-auth=false' flag do when set on the kube-apiserver?",
    "c": [
      "Disables anonymous requests to the API server",
      "Disables authentication entirely",
      "Allows all requests without authentication",
      "Enables anonymous authentication",
      "Forces all clients to use tokens"
    ],
    "a": [
      "Disables anonymous requests to the API server"
    ],
    "e": "Setting '--anonymous-auth=false' on the kube-apiserver ensures that all requests to the API server must be authenticated. This enhances security by preventing unauthorized access."
  },
  {
    "q": "What is the correct 'kind' value for an object that associates a Role with a user or group?",
    "c": [
      "RoleBinding",
      "ClusterRole",
      "User",
      "Group",
      "RoleAssignment"
    ],
    "a": [
      "RoleBinding"
    ],
    "e": "A RoleBinding is the Kubernetes object that binds a Role to a user or group within a namespace, enabling them to perform specific actions."
  },
  {
    "q": "What is the primary function of a Service Mesh in Kubernetes architecture?",
    "c": [
      "A network overlay for pod communication",
      "An infrastructure layer for handling service-to-service communication",
      "A type of storage solution",
      "A container runtime interface",
      "A logging mechanism"
    ],
    "a": [
      "An infrastructure layer for handling service-to-service communication"
    ],
    "e": "A Service Mesh is a dedicated infrastructure layer that manages service-to-service communication through sidecar proxies, providing features like traffic management, service discovery, and security policies without requiring application code changes. While pod communication occurs through the mesh, it's not merely a network overlay but rather a comprehensive communication management layer."
  },
  {
    "q": "What is the main objective of Microsoft's Security Development Lifecycle (SDL)?",
    "c": [
      "To provide a compliance checklist for healthcare data",
      "To outline an encryption standard for IoT devices",
      "To incorporate threat modeling and mitigation throughout the software development process",
      "To define data storage formats for container logs",
      "To guide zero-downtime deployment strategies"
    ],
    "a": [
      "To incorporate threat modeling and mitigation throughout the software development process"
    ],
    "e": "Microsoft's Security Development Lifecycle (SDL) is a comprehensive process that integrates security and privacy best practices into every phase of software development. Its primary focus is on identifying potential threats early through threat modeling and implementing mitigations to reduce vulnerabilities. It is not a compliance checklist, encryption standard, logging format, or deployment strategy guide."
  },
  {
    "q": "Which statement best describes the Kubernetes Ingress resource?",
    "c": [
      "It defines internal networking rules between pods",
      "It manages external HTTP and HTTPS access to services",
      "It is used for storing configuration data",
      "It schedules pods to nodes",
      "It provides persistent storage to pods"
    ],
    "a": [
      "It manages external HTTP and HTTPS access to services"
    ],
    "e": "Kubernetes Ingress is a resource that manages external access to services, typically HTTP and HTTPS traffic. It provides routing rules to direct external requests to the appropriate backend services within the cluster. It does not define internal pod networking (that is handled by Services and network plugins), nor is it used for storing configuration data (ConfigMaps/Secrets), scheduling pods (handled by the scheduler), or providing persistent storage (handled by PersistentVolumes)."
  },
  {
    "q": "Which strace command-line option provides a summary of the time spent in each system call during program execution?",
    "c": [
      "-c",
      "-p",
      "-t",
      "-e trace=%time",
      "-s"
    ],
    "a": [
      "-c"
    ],
    "e": "The '-c' option in strace outputs a summary report showing the count, total time, and average time spent in each system call, helping analyze performance bottlenecks. The '-p' option attaches strace to an existing process by PID, '-t' prefixes each line with a timestamp, '-e trace=%time' is not a valid option, and '-s' sets the maximum string size to print, so they do not provide a time summary."
  },
  {
    "q": "Which Kubernetes component serves as the entry point for the control plane and exposes the Kubernetes API?",
    "c": [
      "kubelet",
      "kube-scheduler",
      "kube-apiserver",
      "kube-proxy",
      "etcd"
    ],
    "a": [
      "kube-apiserver"
    ],
    "e": "The kube-apiserver acts as the front end of the control plane, handling incoming API requests and serving as the primary interface for Kubernetes cluster management. It is responsible for authenticating and authorizing all requests to the API server, ensuring secure access to cluster resources. For more information, refer to the official Kubernetes documentation on components and architecture[1][3]."
  },
  {
    "q": "What are the key best practices for hardening container images to enhance security?",
    "c": [
      "Use a minimal base image to reduce the attack surface.",
      "Run containers as root to simplify privilege management.",
      "Remove unnecessary packages and dependencies to minimize potential vulnerabilities.",
      "Expose all ports for maximum connectivity and flexibility.",
      "Regularly scan images for known vulnerabilities and apply necessary patches."
    ],
    "a": [
      "Use a minimal base image to reduce the attack surface.",
      "Remove unnecessary packages and dependencies to minimize potential vulnerabilities.",
      "Regularly scan images for known vulnerabilities and apply necessary patches."
    ],
    "e": "To effectively harden container images, it is crucial to minimize the attack surface and potential vulnerabilities. Using minimal base images ensures that only essential components are included, reducing the number of potential security flaws. Removing unnecessary packages further decreases the likelihood of exploitable vulnerabilities. Regularly scanning images for known vulnerabilities allows for proactive identification and remediation of security risks. Running containers as root is discouraged because it gives the process elevated privileges that it does not need and exposes the host system to vulnerabilities. Exposing all ports creates unnecessary entry points for attackers."
  },
  {
    "q": "Which configuration in a Kubernetes container's securityContext is used to drop all Linux capabilities, effectively removing extra privileges?",
    "c": [
      "capabilities: {drop: ['ALL']}",
      "capabilities: {add: ['NONE']}",
      "privileged: false",
      "allowPrivilegeEscalation: false",
      "runAsNonRoot: true"
    ],
    "a": [
      "capabilities: {drop: ['ALL']}"
    ],
    "e": "To remove all Linux capabilities from a container, the 'capabilities' field under the container's securityContext should specify 'drop: ['ALL']'. This explicitly drops all added capabilities, minimizing the container's privileges."
  },
  {
    "q": "Which kubectl command allows you to view the current resource usage (CPU and memory) of a specific pod?",
    "c": [
      "kubectl describe pod <pod-name>",
      "kubectl top pod <pod-name>",
      "kubectl get pod <pod-name> --resources",
      "kubectl logs <pod-name>",
      "kubectl inspect pod <pod-name>"
    ],
    "a": [
      "kubectl top pod <pod-name>"
    ],
    "e": "The 'kubectl top pod <pod-name>' command displays the current CPU and memory usage of the specified pod, provided that the Metrics Server is installed and running in the cluster. 'kubectl describe' shows detailed pod information but not real-time resource usage. The other commands do not provide resource consumption data."
  },
  {
    "q": "What is a common cause for failing to pull the latest version of a container image from the 'k8s.gcr.io' registry?",
    "c": [
      "The image registry has been deprecated or is unavailable",
      "Specifying an incorrect image name or tag in the pull command",
      "Network policies blocking outbound traffic from the node",
      "The Kubernetes node lacks sufficient CPU or memory resources",
      "The kube-proxy component is not running on the node"
    ],
    "a": [
      "Specifying an incorrect image name or tag in the pull command"
    ],
    "e": "A frequent reason for image pull failures is specifying an incorrect image name or tag, which leads to the registry not finding the requested image. While registry deprecation or network policies can also cause issues, the most common and easily overlooked cause is a typo or mismatch in the image reference. Insufficient node resources or kube-proxy issues typically do not directly cause image pull failures."
  },
  {
    "q": "Which of the following actions in Kubernetes cross trust boundaries and potentially introduce security risks? (Select all that apply)",
    "c": [
      "Accessing the Kubernetes API server",
      "Communicating between pods within the same namespace",
      "Mounting hostPath volumes into pods",
      "Using service accounts across different namespaces",
      "Pulling container images from public registries"
    ],
    "a": [
      "Mounting hostPath volumes into pods",
      "Using service accounts across different namespaces",
      "Pulling container images from public registries"
    ],
    "e": "Mounting hostPath volumes allows pods to access the host filesystem, crossing the boundary between container and host, which poses significant security risks. Using service accounts across namespaces can bypass namespace isolation, potentially escalating privileges. Pulling images from public registries introduces risks from untrusted or malicious images. Accessing the Kubernetes API is a controlled and authenticated action, while pod-to-pod communication within the same namespace is generally within the same trust boundary and less risky."
  },
  {
    "q": "Which of the following options is NOT a category in the STRIDE threat model?",
    "c": [
      "Spoofing",
      "Tampering",
      "Replication",
      "Information Disclosure",
      "Denial of Service"
    ],
    "a": [
      "Replication"
    ],
    "e": "Replication is not one of the categories in the STRIDE threat model. The STRIDE model includes Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, and Elevation of Privileges."
  },
  {
    "q": "Why is integrating TLS certificates critical for supply chain security in Kubernetes environments?",
    "c": [
      "It ensures faster application deployment via automation",
      "It facilitates multi-cloud resource allocation",
      "It secures communication between admission controllers and the API server, preventing man-in-the-middle attacks",
      "It helps in container orchestration on legacy systems",
      "It extends the clusterâ€™s node pool automatically"
    ],
    "a": [
      "It secures communication between admission controllers and the API server, preventing man-in-the-middle attacks"
    ],
    "e": "TLS certificate integration is essential in Kubernetes supply chain security because it encrypts and authenticates communication between components such as admission controllers and the API server. This prevents attackers from intercepting or tampering with requests, thereby mitigating man-in-the-middle attacks and ensuring the integrity of the supply chain. The other options do not relate to TLS's role in securing communication or supply chain integrity."
  },
  {
    "q": "Which Kubernetes component is responsible for enforcing Pod Security Standards through admission control?",
    "c": [
      "kube-scheduler",
      "kube-apiserver with the PodSecurity admission plugin",
      "kube-controller-manager",
      "kubelet",
      "etcd"
    ],
    "a": [
      "kube-apiserver with the PodSecurity admission plugin"
    ],
    "e": "The kube-apiserver enforces Pod Security Standards by using the PodSecurity admission plugin, which validates and enforces security policies on pods during creation or update. The kube-scheduler schedules pods to nodes, kube-controller-manager manages controllers, kubelet runs on nodes to manage pods, and etcd is the cluster data store; none of these enforce Pod Security Standards directly."
  },
  {
    "q": "Which statement accurately describes how Kubernetes Network Policies control pod-to-pod communication within a cluster?",
    "c": [
      "By default, they block all traffic between pods.",
      "They use iptables rules (via the CNI plugin) to control pod communication.",
      "They are enforced by the kube-scheduler.",
      "They manage access to the Kubernetes API.",
      "They control storage access for pods."
    ],
    "a": [
      "They use iptables rules (via the CNI plugin) to control pod communication."
    ],
    "e": "Kubernetes Network Policies define how groups of pods are allowed to communicate with each other and with other network endpoints. These policies are enforced by the Container Network Interface (CNI) plugin used in the cluster. Most CNI plugins implement network policies using iptables or similar mechanisms to control traffic at the network level. By default, if no Network Policy is applied, all pods can communicate freely. Network Policies do not block all traffic by default, nor are they enforced by the kube-scheduler. They do not manage API or storage access."
  },
  {
    "q": "Why is it advisable to avoid running containers with root privileges in a Kubernetes environment?",
    "c": [
      "It increases resource consumption",
      "It can lead to security risks by granting unnecessary permissions",
      "It reduces application performance",
      "It prevents containers from accessing the network",
      "It is required by Kubernetes policies"
    ],
    "a": [
      "It can lead to security risks by granting unnecessary permissions"
    ],
    "e": "Running containers as root increases the risk of privilege escalation and other security attacks. By running containers as non-root users, you reduce the attack surface and improve the overall security posture of your Kubernetes environment."
  },
  {
    "q": "Which tool is commonly used for real-time compliance monitoring and alerting in Kubernetes environments?",
    "c": [
      "Sysdig Secure",
      "NTP daemon",
      "CoreDNS",
      "Kubernetes Dashboard",
      "etcd"
    ],
    "a": [
      "Sysdig Secure"
    ],
    "e": "Sysdig Secure is a tool designed for real-time compliance monitoring, anomaly detection, and security enforcement in Kubernetes environments. It helps ensure that clusters adhere to security standards and best practices."
  },
  {
    "q": "What is the role of the 'cluster-admin' ClusterRole?",
    "c": [
      "Full control over all resources in the cluster",
      "Full control over all resources in a single namespace",
      "Read-only access to all cluster resources",
      "Management of cluster nodes and infrastructure only"
    ],
    "a": [
      "Full control over all resources in the cluster"
    ],
    "e": "The 'cluster-admin' ClusterRole grants full cluster-wide administrative permissions. When bound via a ClusterRoleBinding, it provides full control over all resources in the cluster. When bound via a RoleBinding, its permissions are limited to the namespace specified in the binding."
  },
  {
    "q": "What admission controller should be used to enforce Pod Security Standards in Kubernetes versions 1.25 and later?",
    "c": [
      "PodSecurityPolicy",
      "Pod Security Admission Controller",
      "NodeRestriction",
      "ResourceQuota",
      "LimitRanger"
    ],
    "a": [
      "Pod Security Admission Controller"
    ],
    "e": "The Pod Security Admission Controller is the recommended method for enforcing Pod Security Standards in Kubernetes versions 1.25 and above. This controller replaces the deprecated PodSecurityPolicy and provides a more flexible and efficient way to manage pod security."
  },
  {
    "q": "Which Kubernetes component is responsible for securely storing and managing all cluster data, including Secrets, ConfigMaps, and cluster state?",
    "c": [
      "kube-apiserver",
      "kube-scheduler",
      "kubelet",
      "etcd",
      "kube-controller-manager"
    ],
    "a": [
      "etcd"
    ],
    "e": "etcd is the distributed key-value store that serves as Kubernetes' primary data store. It maintains the cluster's state, configuration data, and Secrets. While the kube-apiserver interacts with etcd, it doesn't store data directly. Proper etcd configuration (encryption, access controls, backups) is critical for cluster security."
  },
  {
    "q": "How do you display the full YAML definition of a specific pod in Kubernetes using kubectl?",
    "c": [
      "kubectl show pod <pod-name>",
      "kubectl get pod <pod-name> -o yaml",
      "kubectl describe pod <pod-name>",
      "kubectl view pod <pod-name>",
      "kubectl yaml pod <pod-name>"
    ],
    "a": [
      "kubectl get pod <pod-name> -o yaml"
    ],
    "e": "The command 'kubectl get pod <pod-name> -o yaml' outputs the complete YAML manifest of the specified pod, showing its configuration as stored in the cluster. 'kubectl describe pod <pod-name>' provides detailed runtime information but not the raw YAML definition. The other commands are not valid kubectl commands."
  },
  {
    "q": "Which statement best describes the purpose of the CIS Kubernetes Benchmark?",
    "c": [
      "It offers prescriptive configuration guidelines for hardening Kubernetes clusters",
      "It is an automated tool that scans and remediates security vulnerabilities in Kubernetes clusters.",
      "It provides a framework for threat modeling and risk assessment in containerized environments.",
      "It focuses on scanning container images for known vulnerabilities and compliance violations."
    ],
    "a": [
      "It offers prescriptive configuration guidelines for hardening Kubernetes clusters"
    ],
    "e": "The CIS Kubernetes Benchmark provides detailed, consensus-based best practices for securely configuring Kubernetes clusters. It focuses on hardening the cluster components and configurations to reduce security risks. It is not a software tool, nor does it focus exclusively on threat modeling or container image scanning. While zero-trust principles may be relevant to Kubernetes security, the benchmark itself specifically addresses configuration hardening."
  },
  {
    "q": "How can you prevent pods from being scheduled on a Kubernetes node?",
    "c": [
      "kubectl cordon <node-name>",
      "kubectl drain <node-name>",
      "kubectl taint nodes <node-name> key=value:NoSchedule",
      "kubectl label nodes <node-name> unschedulable=true",
      "kubectl delete node <node-name>"
    ],
    "a": [
      "kubectl cordon <node-name>",
      "kubectl taint nodes <node-name> key=value:NoSchedule"
    ],
    "e": "Both cordoning and tainting a node with `kubectl taint nodes <node-name> key=value:NoSchedule` prevents pods without a matching toleration from being scheduled on it. This is a way to mark nodes as unsuitable for certain workloads without completely removing them from the cluster."
  },
  {
    "q": "What is the primary benefit of applying the CIS Kubernetes Benchmark to production clusters?",
    "c": [
      "It provides prescriptive security hardening recommendations to enhance cluster security and compliance",
      "It guarantees zero downtime and high availability for all Kubernetes services.",
      "It automates the deployment of serverless functions within the cluster.",
      "It focuses solely on reducing operational costs by optimizing resource usage."
    ],
    "a": [
      "It provides prescriptive security hardening recommendations to enhance cluster security and compliance"
    ],
    "e": "The CIS Kubernetes Benchmark offers detailed, prescriptive guidelines and best practices for securing Kubernetes clusters. Applying these recommendations helps organizations harden their production environments against security threats and meet compliance requirements. The benchmark does not guarantee zero downtime, enforce deployment strategies, provide automatic encryption, or replace orchestration with serverless functions."
  },
  {
    "q": "Why might a pod retain privileged access even after applying the 'restricted' Pod Security Standard (PSS) or Pod Security Admission (PSA) policy to its namespace?",
    "c": [
      "The Pod Security Standard does not apply retroactively to existing pods",
      "The namespace labels required for policy enforcement are misconfigured or missing",
      "The Kubernetes API server does not support Pod Security Standards",
      "The pod specification explicitly overrides the policy",
      "Privileged access is always allowed regardless of policy"
    ],
    "a": [
      "The Pod Security Standard does not apply retroactively to existing pods",
      "The namespace labels required for policy enforcement are misconfigured or missing"
    ],
    "e": "The 'restricted' Pod Security Standard or Pod Security Admission policy applies only to pods created or updated after the policy is enforced; existing pods are not automatically remediated. Enforcement also depends on correct namespace labeling (e.g., 'pod-security.kubernetes.io/enforce=restricted'). If these labels are missing or misconfigured, the policy will not be enforced on pods in that namespace."
  },
  {
    "q": "What is the primary purpose of a PodDisruptionBudget in Kubernetes?",
    "c": [
      "To prevent pods from being evicted during maintenance",
      "To automatically scale the number of pods based on CPU usage",
      "To define resource limits and requests for pods",
      "To enforce security policies and pod isolation boundaries"
    ],
    "a": [
      "To prevent pods from being evicted during maintenance"
    ],
    "e": "A PodDisruptionBudget ensures that a specified number of replicas of a pod are available at any time, preventing disruptions during maintenance or other events that might cause pod eviction."
  },
  {
    "q": "What is the correct command to label a Kubernetes namespace named 'production' with the label 'env=prod'?",
    "c": [
      "kubectl label namespace env=prod production",
      "kubectl label namespace production env=prod",
      "kubectl annotate namespace production env=prod",
      "kubectl label namespaces env=prod production",
      "kubectl set label namespace production env=prod"
    ],
    "a": [
      "kubectl label namespace production env=prod"
    ],
    "e": "To label a Kubernetes namespace, you use the `kubectl label` command. The correct syntax is `kubectl label namespace <namespace_name> <label_key>=<label_value>`. Therefore, to label the 'production' namespace with 'env=prod', you would use `kubectl label namespace production env=prod`. This command updates the namespace with the specified label, which can be useful for organizing and filtering resources within your cluster."
  },
  {
    "q": "What is the effect of the 'kubectl config use-context' command in Kubernetes?",
    "c": [
      "Switches the active namespace in the current context",
      "Changes the current kubeconfig file being used",
      "Modifies the cluster configuration in kubeconfig",
      "Sets the current context to the specified one in kubeconfig",
      "Updates the API server endpoint in the current context"
    ],
    "a": [
      "Sets the current context to the specified one in kubeconfig"
    ],
    "e": "The command 'kubectl config use-context <context-name>' sets the current context in the kubeconfig file to the specified context. This changes which cluster, user, and namespace kubectl commands operate against by default. It does not switch namespaces directly (that requires 'kubectl config set-context' or 'kubectl config set-namespace'), nor does it change the kubeconfig file itself or modify cluster details. It simply selects which predefined context is active."
  },
  {
    "q": "During the build phase of a Kubernetes application, which practices are most effective for ensuring security?",
    "c": [
      "Use minimal base images to reduce the attack surface.",
      "Run containers as root to simplify privilege management.",
      "Scan images for vulnerabilities to identify and remediate potential security flaws.",
      "Include unnecessary packages to provide additional functionality.",
      "Use only authorized images from trusted registries to prevent the introduction of malicious code."
    ],
    "a": [
      "Use minimal base images to reduce the attack surface.",
      "Scan images for vulnerabilities to identify and remediate potential security flaws.",
      "Use only authorized images from trusted registries to prevent the introduction of malicious code."
    ],
    "e": "In the build phase, security is best ensured by minimizing the image footprint with minimal base images, regularly scanning for vulnerabilities to catch issues early, and using only authorized images from trusted sources. Minimal base images reduce the attack surface. Vulnerability scanning identifies and allows remediation of security flaws before deployment. Using authorized images prevents the introduction of untrusted or malicious code. Running containers as root is a security risk, and including unnecessary packages increases the potential attack surface."
  },
  {
    "q": "Which kubectl command is used to retrieve the logs of a pod named 'my-pod'?",
    "c": [
      "kubectl get logs my-pod",
      "kubectl describe my-pod",
      "kubectl logs my-pod",
      "kubectl status my-pod",
      "kubectl inspect my-pod"
    ],
    "a": [
      "kubectl logs my-pod"
    ],
    "e": "The correct command to view the logs of a pod named 'my-pod' is 'kubectl logs my-pod'. This command fetches the standard output and error logs from the pod's containers. 'kubectl describe' provides detailed resource information but not logs. The other commands are invalid or do not exist."
  },
  {
    "q": "If the Kubernetes API server is not responding, which configuration file should you check for possible misconfigurations?",
    "c": [
      "/var/log/kube-apiserver.log",
      "/etc/kubernetes/manifests/kube-scheduler.yaml",
      "/etc/kubernetes/manifests/kube-apiserver.yaml",
      "/etc/kubernetes/config/apiserver.conf",
      "/var/lib/kubelet/config.yaml"
    ],
    "a": [
      "/etc/kubernetes/manifests/kube-apiserver.yaml"
    ],
    "e": "The Kubernetes API server's configuration is typically defined in its static pod manifest, which is usually located at `/etc/kubernetes/manifests/kube-apiserver.yaml`. This file contains the configuration for the API server, including any custom settings or overrides that might be causing issues. Checking this file can help identify misconfigurations that could be preventing the API server from responding."
  },
  {
    "q": "How does the underlying cloud infrastructure impact the security of a Kubernetes cluster?",
    "c": [
      "No impact, as Kubernetes abstracts infrastructure entirely",
      "Yes, infrastructure vulnerabilities can compromise cluster security",
      "Only if using on-premises hardware",
      "It depends on the Kubernetes version",
      "Only when running stateful applications"
    ],
    "a": [
      "Yes, infrastructure vulnerabilities can compromise cluster security"
    ],
    "e": "The security of the underlying cloud infrastructure directly impacts the security of a Kubernetes cluster. Vulnerabilities in the infrastructure can compromise the cluster, making it essential to ensure the infrastructure is secure."
  },
  {
    "q": "What is a primary objective of supply chain compliance in Kubernetes environments?",
    "c": [
      "To reduce container start-up times",
      "To ensure all software components, including third-party container images, comply with security and integrity standards",
      "To provide a universal logging format for microservices",
      "To automatically scale nodes based on environmental sensor data",
      "To monitor CPU resource usage for cost optimization"
    ],
    "a": [
      "To ensure all software components, including third-party container images, comply with security and integrity standards"
    ],
    "e": "Supply chain compliance in Kubernetes focuses on verifying the integrity, provenance, and security of all software components used throughout the application lifecycle, including third-party container images. This ensures that only trusted and compliant components are deployed, mitigating risks from vulnerabilities or malicious code. Other options, such as reducing container start-up times or scaling nodes based on sensor data, are unrelated to supply chain compliance objectives."
  },
  {
    "q": "What command is used to scan a Docker image named 'myapp:latest' for HIGH and CRITICAL vulnerabilities using Trivy?",
    "c": [
      "trivy myapp:latest",
      "trivy image --severity HIGH,CRITICAL myapp:latest",
      "trivy scan --critical myapp:latest",
      "trivy image --vulnerabilities HIGH,CRITICAL myapp:latest",
      "trivy inspect myapp:latest"
    ],
    "a": [
      "trivy image --vulnerabilities HIGH,CRITICAL myapp:latest"
    ],
    "e": "The correct command to scan for HIGH and CRITICAL vulnerabilities is 'trivy image --severity HIGH,CRITICAL myapp:latest'. This command specifically targets vulnerabilities of those severities in the Docker image."
  },
  {
    "q": "Which tool is widely used to automate compliance checks against the CIS Kubernetes Benchmark?",
    "c": [
      "Kube-bench",
      "Prometheus",
      "Falco",
      "Kustomize"
    ],
    "a": [
      "Kube-bench"
    ],
    "e": "Kube-bench is a specialized open-source tool designed to automate the assessment of Kubernetes clusters against the CIS Kubernetes Benchmark, which defines security best practices. Unlike generic tools such as Nmap or Grafana, Kube-bench runs checks that correspond directly to the CIS controls, providing detailed reports on compliance status. While Bash scripts can be used for automation, they lack the comprehensive and standardized checks that Kube-bench provides. Syslog-ng is a logging tool and unrelated to compliance scanning."
  },
  {
    "q": "What is the primary objective of threat modeling in the context of Kubernetes security?",
    "c": [
      "To define default CPU and memory limits for all workloads",
      "To visualize data flows and identify potential attack vectors within cluster configurations",
      "To enforce container image scanning during runtime",
      "To conduct load testing on container orchestration systems",
      "To accelerate pipeline deployments in CI/CD"
    ],
    "a": [
      "To visualize data flows and identify potential attack vectors within cluster configurations"
    ],
    "e": "Threat modeling in Kubernetes security involves creating a detailed representation of data flows and system components to identify potential vulnerabilities and attack vectors within cluster configurations. This proactive approach helps security teams anticipate and mitigate risks before exploitation. Defining resource limits, enforcing image scanning, load testing, or accelerating CI/CD pipelines are important operational tasks but do not constitute the core purpose of threat modeling."
  },
  {
    "q": "What was the precursor to the Pod Security Standards (PSS) in Kubernetes?",
    "c": [
      "Pod Security Admission (PSA)",
      "Kubernetes Security Policies (KSP)",
      "PodSecurityPolicy (PSP)",
      "Network Policies",
      "Role-Based Access Control (RBAC)"
    ],
    "a": [
      "PodSecurityPolicy (PSP)"
    ],
    "e": "PodSecurityPolicy (PSP) was the precursor to Pod Security Standards (PSS). PSP was deprecated and replaced by PSS and the PodSecurity admission controller to improve pod security management in Kubernetes clusters."
  },
  {
    "q": "Which of the following statements about static pods in Kubernetes are true? (Select all that apply)",
    "c": [
      "They are managed directly by the kubelet on a node",
      "They are defined in the API server and stored in etcd",
      "They are useful for running critical system components",
      "They are automatically rescheduled on other nodes if the node fails",
      "They can be updated using kubectl commands"
    ],
    "a": [
      "They are managed directly by the kubelet on a node",
      "They are useful for running critical system components"
    ],
    "e": "Static pods are defined by placing pod manifest files directly on a nodeâ€™s filesystem and are managed by the kubelet on that node, not through the API server or etcd. They are useful for running critical system components that must run on a specific node. Static pods are not rescheduled automatically if the node fails, and they cannot be updated via kubectl since they are not managed through the Kubernetes API."
  },
  {
    "q": "In Kubernetes security best practices, what is the primary security benefit of configuring a container's root filesystem as read-only?",
    "c": [
      "Improved container startup performance",
      "Reduced container image storage requirements",
      "Enhanced security by preventing malicious filesystem modifications",
      "Enables cross-container file sharing capabilities",
      "Simplifies rolling updates for containerized applications"
    ],
    "a": [
      "Enhanced security by preventing malicious filesystem modifications"
    ],
    "e": "A read-only root filesystem (configured via securityContext.readOnlyRootFilesystem) prevents attackers from modifying system files, installing malware, or writing to sensitive directories, even if they gain shell access. This security hardening measure is recommended by CIS Kubernetes Benchmarks and Kubernetes security best practices."
  },
  {
    "q": "How can you force delete a Kubernetes pod that is stuck in the 'Terminating' state?",
    "c": [
      "Run 'kubectl delete pod <pod-name>' normally",
      "Restart the kubelet service on the node",
      "Run 'kubectl delete pod <pod-name> --force --grace-period=0'",
      "Delete the node where the pod is running",
      "Edit the pod's YAML to remove finalizers"
    ],
    "a": [
      "Run 'kubectl delete pod <pod-name> --force --grace-period=0'"
    ],
    "e": "A pod stuck in 'Terminating' state can be force deleted using the command 'kubectl delete pod <pod-name> --force --grace-period=0'. This command bypasses the graceful termination period and forcibly removes the pod from the API server, even if the pod's containers are still running. Restarting the kubelet or deleting the node can be disruptive and are not recommended first steps. Editing the pod's YAML to remove finalizers can help if finalizers are blocking deletion, but the force delete command is the standard immediate solution."
  },
  {
    "q": "Select all that apply: Which Kubernetes object(s) allow you to define a set of rules for validating or mutating admission requests?",
    "c": [
      "ValidatingWebhookConfiguration",
      "MutatingWebhookConfiguration",
      "AdmissionController",
      "CustomResourceDefinition",
      "WebhookPolicy"
    ],
    "a": [
      "ValidatingWebhookConfiguration",
      "MutatingWebhookConfiguration"
    ],
    "e": "`ValidatingWebhookConfiguration` and `MutatingWebhookConfiguration` are used to integrate admission webhooks that validate or mutate admission requests. Option 2 (`AdmissionController`) is a general term for the mechanism but not a specific Kubernetes object. Option 3 (`CustomResourceDefinition`) is used to define custom resources, and Option 4 (`WebhookPolicy`) is not a valid Kubernetes object."
  },
  {
    "q": "What is the primary function of Kubernetes admission controllers in enforcing compliance within a cluster?",
    "c": [
      "Scheduling pods onto nodes based on resource requirements",
      "Managing persistent storage volumes for stateful applications",
      "Intercepting API requests to validate and enforce policies before object creation or modification",
      "Acting as a certificate authority for cluster nodes",
      "Providing a graphical user interface for cluster configuration"
    ],
    "a": [
      "Intercepting API requests to validate and enforce policies before object creation or modification"
    ],
    "e": "Kubernetes admission controllers are plugins that intercept API requests to the Kubernetes API server before objects are persisted. They validate and enforce policies such as security, resource quotas, and compliance rules, ensuring that only compliant configurations are admitted into the cluster. Scheduling pods, managing storage, acting as a certificate authority, or providing GUIs are handled by other Kubernetes components and tools."
  },
  {
    "q": "What is a common mitigation strategy for 'Spoofing' threats?",
    "c": [
      "Implementing proper authentication mechanisms",
      "Using encryption for data at rest",
      "Implementing audit logging",
      "Applying rate limiting",
      "Running processes as root"
    ],
    "a": [
      "Implementing proper authentication mechanisms"
    ],
    "e": "Spoofing threats can be mitigated by implementing robust authentication mechanisms. These mechanisms help verify the identity of users or systems, reducing the risk of impersonation. While encryption (option 2) and audit logging (option 3) are important security practices, they do not directly address spoofing. Rate limiting (option 4) is more relevant to Denial of Service attacks, and running processes as root (option 5) increases security risks."
  },
  {
    "q": "In Kubernetes RBAC, what does a Role define?",
    "c": [
      "A set of users and their passwords",
      "Permissions within a namespace",
      "Network policies for pods",
      "Global cluster-wide permissions",
      "Resource quotas for a project"
    ],
    "a": [
      "Permissions within a namespace"
    ],
    "e": "A Role in Kubernetes RBAC defines a set of permissions that are applicable within a specific namespace. This allows for fine-grained control over resources within that namespace."
  },
  {
    "q": "Which combination of pod configurations can allow a compromised Kubernetes pod to access and potentially modify the host system? (Select all that apply)",
    "c": [
      "Running the pod in privileged mode",
      "Mounting the host filesystem into the pod",
      "Using host networking in the pod",
      "Dropping all Linux capabilities from the pod",
      "Running the pod as a non-root user"
    ],
    "a": [
      "Running the pod in privileged mode",
      "Mounting the host filesystem into the pod",
      "Using host networking in the pod"
    ],
    "e": "Running a pod in privileged mode grants it broad permissions, including the ability to access host resources and perform actions that can compromise the host system. Mounting the host filesystem into the pod exposes sensitive files and allows the pod to read or modify host data, which is a significant security risk. Using host networking gives the pod direct access to the host's network stack, increasing the risk of network-based attacks or eavesdropping. In contrast, dropping all Linux capabilities and running as a non-root user are security best practices that reduce the attack surface and limit the pod's ability to affect the host, making these options incorrect."
  },
  {
    "q": "Which securityContext configuration field enables privileged container mode in Kubernetes pods?",
    "c": [
      "allowPrivilegeEscalation: true",
      "runAsPrivileged: true",
      "privileged: true",
      "capabilities.add: [\"ALL\"]",
      "securityContext.privilegedMode: enabled"
    ],
    "a": [
      "privileged: true"
    ],
    "e": "The privileged: true setting gives the container full access to host devices and capabilities, equivalent to root privileges on the host. This dangerous configuration should be avoided in production, as emphasized in Kubernetes security documentation and CIS Benchmarks. Privileged containers bypass most security controls and namespace restrictions."
  },
  {
    "q": "What is a primary benefit of using Namespaces in Kubernetes?",
    "c": [
      "Improves application performance",
      "Provides a mechanism for resource isolation and organization",
      "Simplifies container image management",
      "Automatically scales applications based on load",
      "Eliminates the need for Pods"
    ],
    "a": [
      "Provides a mechanism for resource isolation and organization"
    ],
    "e": "Namespaces in Kubernetes provide a way to logically separate and isolate resources within a cluster, enabling multiple teams or projects to share the same cluster without resource conflicts. They help organize cluster resources and apply resource quotas or policies per namespace. Namespaces do not directly improve application performance, simplify container images, automatically scale applications, or replace Pods, which are fundamental units of deployment in Kubernetes."
  },
  {
    "q": "Which of the following controllers is NOT managed by the kube-controller-manager in Kubernetes?",
    "c": [
      "Node Controller",
      "Endpoint Controller",
      "Ingress Controller",
      "Deployment Controller",
      "Service Account Controller"
    ],
    "a": [
      "Ingress Controller"
    ],
    "e": "The Ingress Controller is not part of the kube-controller-manager; it is typically deployed separately as a pod or set of pods to manage external HTTP/S traffic routing. The kube-controller-manager manages controllers such as Node, Endpoint, Deployment, and Service Account Controllers internally."
  },
  {
    "q": "What is the primary purpose of Grafana in IT operations?",
    "c": [
      "Managing code version control",
      "Automating continuous integration pipelines",
      "Visualizing and monitoring metrics through dashboards",
      "Enforcing network security policies",
      "Managing user identities and access"
    ],
    "a": [
      "Visualizing and monitoring metrics through dashboards"
    ],
    "e": "Grafana is an open-source platform used primarily for creating dashboards that visualize metrics and monitoring data from various sources. It helps IT teams observe system performance and troubleshoot issues. It is not used for version control, continuous integration, network security enforcement, or identity management."
  },
  {
    "q": "Which command lists all processes currently listening on TCP and UDP ports on a Linux system, including the associated process IDs?",
    "c": [
      "sudo netstat -tulpn",
      "sudo lsof -i",
      "sudo ss -tulw",
      "sudo ps aux | grep LISTEN",
      "sudo netstat -an"
    ],
    "a": [
      "sudo netstat -tulpn"
    ],
    "e": "The command 'sudo netstat -tulpn' lists all listening TCP and UDP ports along with the process IDs and names that are using those ports. The flags mean: '-t' for TCP, '-u' for UDP, '-l' for listening sockets, '-p' to show process info, and '-n' to show numeric addresses. 'sudo lsof -i' also shows network connections but is less focused on listening ports specifically. 'sudo ss -tulw' shows listening sockets but may omit process names without additional flags. 'sudo ps aux | grep LISTEN' is incorrect because 'LISTEN' is not a process name but a socket state. 'sudo netstat -an' shows all connections but does not include process information."
  },
  {
    "q": "What is the effect of applying a Kubernetes NetworkPolicy that does not select any pods in the cluster?",
    "c": [
      "It has no effect on network traffic within the cluster",
      "It denies all network traffic to and from all pods",
      "It allows all network traffic by default",
      "It causes an error in the network plugin",
      "It only affects newly created pods after the policy is applied"
    ],
    "a": [
      "It has no effect on network traffic within the cluster"
    ],
    "e": "A NetworkPolicy that does not select any pods effectively applies to no pods and therefore has no impact on network traffic. It neither denies nor allows traffic beyond the cluster's default behavior. It does not cause errors in the network plugin, nor does it selectively affect only new pods. NetworkPolicies only affect pods that they select."
  },
  {
    "q": "In a Kubernetes NetworkPolicy specification, which field defines the allowed egress destinations for Pods?",
    "c": [
      "ingress",
      "egress",
      "to",
      "from",
      "destinations"
    ],
    "a": [
      "egress"
    ],
    "e": "The 'egress' field in a NetworkPolicy spec specifies the rules that allow outbound traffic from selected Pods to specified destinations. The 'ingress' field defines allowed inbound traffic. 'to' is a subfield inside 'egress' rules specifying destination peers but is not the top-level field defining egress rules. 'from' is used in ingress rules to specify source peers. 'destinations' is not a valid field in NetworkPolicy."
  },
  {
    "q": "What command is used to check the version of the Kubernetes API server?",
    "c": [
      "'kubectl version'",
      "'kubectl get apiserver'",
      "'kube-apiserver --version'",
      "'kubectl cluster-info'",
      "'kubectl describe componentstatus'"
    ],
    "a": [
      "'kubectl version'"
    ],
    "e": "The `kubectl version` command is used to display the client and server versions of Kubernetes. This is useful for ensuring compatibility and identifying potential version mismatches."
  },
  {
    "q": "How can you restrict a Kubernetes user to create resources only within a specific namespace?",
    "c": [
      "Assign the user the cluster-admin role",
      "Create a Role and RoleBinding scoped to that namespace for the user",
      "Modify the kube-apiserver configuration to limit user access",
      "Create a NetworkPolicy that restricts user actions",
      "Set a resource quota on the namespace to limit resource creation"
    ],
    "a": [
      "Create a Role and RoleBinding scoped to that namespace for the user"
    ],
    "e": "To restrict a user to create resources only within a specific namespace, you create a Role that defines the allowed permissions within that namespace and bind it to the user via a RoleBinding. Assigning cluster-admin grants full cluster-wide permissions, which is too broad. Modifying kube-apiserver configuration is not practical for per-user namespace restrictions. NetworkPolicies control pod network traffic, not user permissions. Resource quotas limit resource consumption but do not restrict user actions."
  },
  {
    "q": "Which Kubernetes object is used to manage stateful applications that require persistent storage and network identities?",
    "c": [
      "Deployment",
      "StatefulSet",
      "ReplicaSet",
      "DaemonSet",
      "Job"
    ],
    "a": [
      "StatefulSet"
    ],
    "e": "StatefulSets are used to manage stateful applications that require persistent storage and network identities. Unlike Deployments, StatefulSets maintain a stable network identity and storage for each pod, making them suitable for applications like databases."
  },
  {
    "q": "What is a common mitigation strategy for 'Tampering' threats in Kubernetes?",
    "c": [
      "Implementing strong authentication",
      "Using digital signatures and checksums",
      "Applying redundant servers",
      "Implementing multi-factor authentication",
      "Enforcing password complexity"
    ],
    "a": [
      "Using digital signatures and checksums"
    ],
    "e": "Using digital signatures and checksums is an effective way to mitigate Tampering threats. These mechanisms ensure data integrity by verifying that data has not been altered during transmission or storage."
  },
  {
    "q": "After generating a Certificate Signing Request (CSR) and having it signed by the Kubernetes cluster Certificate Authority (CA), how do you configure kubectl to use the new client certificate and key for the user 'alice'?",
    "c": [
      "kubectl config set-credentials alice --client-certificate=alice.crt --client-key=alice.key",
      "kubectl create secret tls alice --cert=alice.crt --key=alice.key",
      "kubectl config set-context alice-context --cluster=kubernetes --user=alice",
      "kubectl apply -f alice.crt",
      "kubectl certificate approve alice"
    ],
    "a": [
      "kubectl config set-credentials alice --client-certificate=alice.crt --client-key=alice.key"
    ],
    "e": "To configure kubectl to use a new client certificate for a user, you use the command 'kubectl config set-credentials' specifying the user name along with the paths to the client certificate and private key files. This updates the kubeconfig file with the user's credentials. The other options do not configure kubectl credentials: 'kubectl create secret tls' creates a TLS secret in Kubernetes but does not affect kubectl client config; 'kubectl config set-context' sets the context but does not set credentials; 'kubectl apply -f' applies Kubernetes resources and is unrelated; 'kubectl certificate approve' approves a CSR but does not configure kubectl."
  },
  {
    "q": "What is the primary function of the ImagePolicyWebhook admission controller in Kubernetes?",
    "c": [
      "To scan container images for vulnerabilities during runtime",
      "To enforce custom policies on container images during admission to the cluster",
      "To cache container images locally for faster deployment",
      "To automatically update container images to the latest version",
      "To log all image pull requests for auditing purposes"
    ],
    "a": [
      "To enforce custom policies on container images during admission to the cluster"
    ],
    "e": "The ImagePolicyWebhook admission controller intercepts Pod creation requests and enforces policies on container images before they are admitted into the cluster, such as validating image signatures or restricting images from untrusted registries. It does not perform runtime vulnerability scanning, caching, automatic updates, or logging image pulls, which are handled by other tools or controllers."
  },
  {
    "q": "Which compliance framework is primarily recognized for emphasizing continuous policy review and network traffic monitoring to enhance security in cloud environments?",
    "c": [
      "NIST Cybersecurity Framework",
      "SOC 1 Type II",
      "ISO/IEC 27017",
      "FedRAMP",
      "COBIT"
    ],
    "a": [
      "NIST Cybersecurity Framework"
    ],
    "e": "The NIST Cybersecurity Framework is widely adopted for managing cybersecurity risks and emphasizes continuous monitoring, including ongoing policy review and network traffic analysis, to effectively manage and mitigate risks in cloud and other environments. SOC 1 Type II focuses on financial controls, ISO/IEC 27017 provides guidelines for cloud security controls but does not emphasize continuous monitoring to the same extent, FedRAMP is a U.S. government program for cloud security authorization, and COBIT is a governance framework for IT management rather than specific continuous monitoring practices."
  },
  {
    "q": "Which kubectl command correctly creates a generic secret named 'db-secret' with a key 'password' and the value 'S3cr3t!'?",
    "c": [
      "kubectl create secret generic db-secret --password='S3cr3t!'",
      "kubectl create secret db-secret --from-literal='password=S3cr3t!'",
      "kubectl create secret generic db-secret --from-literal=password=S3cr3t!",
      "kubectl create secret tls db-secret --key='S3cr3t!'",
      "kubectl create secret docker-registry db-secret --password='S3cr3t!'"
    ],
    "a": [
      "kubectl create secret generic db-secret --from-literal=password=S3cr3t!"
    ],
    "e": "The correct command uses 'kubectl create secret generic' with the '--from-literal' flag to specify a key-value pair for the secret. The syntax is: kubectl create secret generic db-secret --from-literal=password=S3cr3t!. The other options are incorrect because '--password' is not a valid flag for generic secrets, 'kubectl create secret' without 'generic' is incomplete, 'tls' secrets require certificate and key files, and 'docker-registry' secrets are for Docker credentials, not arbitrary key-value pairs."
  },
  {
    "q": "Which kubectl command is used to check the health status and readiness of all nodes in a Kubernetes cluster?",
    "c": [
      "kubectl get nodes",
      "kubectl describe nodes",
      "kubectl health nodes",
      "kubectl check nodes",
      "kubectl status nodes"
    ],
    "a": [
      "kubectl get nodes"
    ],
    "e": "'kubectl get nodes' lists all nodes in the cluster along with their status, including whether they are Ready or NotReady, which indicates their health and availability. While 'kubectl describe nodes' provides detailed information about each node, including conditions and events, the primary command to quickly check node health is 'kubectl get nodes'. The other commands are not valid kubectl commands."
  },
  {
    "q": "What is the role of the Service Account Controller in Kubernetes?",
    "c": [
      "Manages the creation and lifecycle of service accounts and their associated authentication tokens",
      "Controls access permissions to external services from the cluster",
      "Assigns network policies to service accounts for traffic control",
      "Manages the lifecycle and scaling of Kubernetes services",
      "Handles automatic scaling of deployments based on load"
    ],
    "a": [
      "Manages the creation and lifecycle of service accounts and their associated authentication tokens"
    ],
    "e": "The Service Account Controller, part of the kube-controller-manager, is responsible for creating service accounts and generating the associated authentication tokens used by pods to interact securely with the Kubernetes API. It does not control external service access, assign network policies, manage service lifecycles, or handle deployment scaling."
  },
  {
    "q": "Which command is used to approve a CertificateSigningRequest (CSR) in Kubernetes?",
    "c": [
      "kubectl sign csr <csr-name>",
      "kubectl create csr <csr-name>",
      "kubectl certificate approve <csr-name>",
      "kubectl approve csr <csr-name>",
      "kubectl csr approve <csr-name>"
    ],
    "a": [
      "kubectl certificate approve <csr-name>"
    ],
    "e": "The correct command to approve a CertificateSigningRequest (CSR) in Kubernetes is 'kubectl certificate approve <csr-name>'. This command instructs the certificate signing controller to approve the CSR, allowing the requested certificate to be issued. Other options like 'kubectl create' are used for creating resources, while 'kubectl sign', 'kubectl approve csr', and 'kubectl csr approve' are invalid commands."
  },
  {
    "q": "Which Kubernetes Secret type is required when configuring TLS termination for an Ingress resource?",
    "c": [
      "Opaque",
      "kubernetes.io/tls",
      "Docker Registry",
      "Basic Auth",
      "SSH Key"
    ],
    "a": [
      "kubernetes.io/tls"
    ],
    "e": "For configuring TLS termination in an Ingress resource, a Secret of type 'kubernetes.io/tls' is required. This type of Secret must contain 'tls.crt' and 'tls.key' entries with PEM-encoded certificates."
  },
  {
    "q": "Which kubectl command allows you to view the events occurring in a Kubernetes cluster, such as pod lifecycle changes and errors, using the most current recommended method?",
    "c": [
      "kubectl get events",
      "kubectl describe events",
      "kubectl list events",
      "kubectl events",
      "kubectl get logs"
    ],
    "a": [
      "kubectl events"
    ],
    "e": "'kubectl events' is the newer and recommended command for viewing events in a Kubernetes cluster, including pod lifecycle changes, warnings, and errors. It provides enhanced filtering and output options compared to the traditional 'kubectl get events'. 'kubectl describe events' is not a valid command; 'kubectl describe' is used with specific resource types but not directly with 'events'. 'kubectl list events' is not a valid command. 'kubectl get logs' is used to fetch logs from pods, not cluster events."
  },
  {
    "q": "Why is Infrastructure as Code (IaC) important for maintaining compliance in Kubernetes environments?",
    "c": [
      "It replaces the need for container registries",
      "It enables the manual application of security patches",
      "It provides a script-free approach to deployment",
      "It ensures repeatable and auditable deployments aligned with security best practices",
      "It automatically detects vulnerabilities without scanning"
    ],
    "a": [
      "It ensures repeatable and auditable deployments aligned with security best practices"
    ],
    "e": "Infrastructure as Code (IaC) tools like Terraform, Ansible, or CloudFormation enable automated, repeatable, and auditable provisioning of infrastructure and Kubernetes resources. This consistency helps enforce security best practices, reduces human error, and supports compliance requirements by maintaining version-controlled infrastructure definitions. IaC does not replace container registries, nor does it provide script-free deployment or automatic vulnerability detection without scanning."
  },
  {
    "q": "How can you verify that Pod Security Admission (PSA) is actively enforcing security policies within a specific Kubernetes namespace?",
    "c": [
      "Check the API server logs for PSA-related entries",
      "Attempt to create a pod that violates the PSA policy and observe the outcome",
      "Inspect the kubelet configuration on the nodes",
      "Review the scheduler's event logs for pod scheduling issues",
      "Use the command 'kubectl get psa' to check enforcement status"
    ],
    "a": [
      "Attempt to create a pod that violates the PSA policy and observe the outcome"
    ],
    "e": "The most direct way to verify that Pod Security Admission is enforcing policies is to try creating a pod that violates the defined PSA policy in the target namespace. If the pod creation is denied, it confirms that PSA is active and enforcing the policies. Checking API server logs or scheduler events may provide indirect clues but are less reliable for verification. The kubelet configuration does not control PSA enforcement, and 'kubectl get psa' is not a valid command for checking PSA status."
  },
  {
    "q": "In Kubernetes NetworkPolicy configuration, what podSelector configuration creates a default-deny-all policy that applies to all pods in a namespace?",
    "c": [
      "Empty selector: {}",
      "Wildcard selector: '*'",
      "Omitted podSelector field",
      "Null value: podSelector: null",
      "Label-based exclusion selector"
    ],
    "a": [
      "Empty selector: {}"
    ],
    "e": "An empty podSelector ({}) matches all pods in the namespace, while omitting the field would make the policy ineffective. This configuration is critical for implementing namespace-wide default-deny policies, as documented in Kubernetes network policy best practices and the CIS Kubernetes Benchmark."
  },
  {
    "q": "Which open-source tool specializes in static security analysis of Kubernetes manifests through vulnerability scanning and policy checks?",
    "c": [
      "kube-hunter (penetration testing tool)",
      "kubesec (security risk analysis)",
      "kubectl (cluster management CLI)",
      "kubelet (node agent)",
      "etcdctl (key-value store client)"
    ],
    "a": [
      "kubesec (security risk analysis)"
    ],
    "e": "Kubesec analyzes Kubernetes manifests for security misconfigurations, providing risk scores and remediation guidance. It checks for common issues like privileged containers, missing security contexts, and insecure capabilities. Other tools serve different purposes: kube-hunter (option 1) tests live clusters, kubectl (option 3) manages resources, kubelet (option 4) runs pods, and etcdctl (option 5) interacts with etcd."
  },
  {
    "q": "Which of the following is a recommended best practice when configuring container registries to ensure security?",
    "c": [
      "Use HTTP instead of HTTPS for performance",
      "Allow anonymous access",
      "Use authenticated and encrypted connections (HTTPS)",
      "Disable TLS verification",
      "Expose the registry publicly without restrictions"
    ],
    "a": [
      "Use authenticated and encrypted connections (HTTPS)"
    ],
    "e": "Using HTTPS with authentication ensures that communication with the container registry is encrypted and access is controlled, preventing unauthorized access and tampering. Using HTTP or disabling TLS verification exposes the registry to interception and attacks. Allowing anonymous or unrestricted public access increases the risk of unauthorized image uploads or downloads."
  },
  {
    "q": "Which command is used to generate a 2048-bit RSA private key for a new Kubernetes user?",
    "c": [
      "openssl genrsa -out user.key 2048",
      "openssl rsa -in user.key -out user.key",
      "openssl req -newkey rsa:2048 -nodes -keyout user.key -out user.csr",
      "kubectl create secret tls user.key",
      "ssh-keygen -t rsa -b 2048 -f user.key"
    ],
    "a": [
      "openssl genrsa -out user.key 2048"
    ],
    "e": "The command 'openssl genrsa -out user.key 2048' generates a 2048-bit RSA private key and saves it to 'user.key'. The second command attempts to process an existing key but does not generate a new one. The third command generates a new private key and a certificate signing request (CSR), not just the key. 'kubectl create secret tls' is for creating TLS secrets, not generating keys. 'ssh-keygen' generates SSH keys, which are different from the keys used for Kubernetes user certificates."
  },
  {
    "q": "How do you create a Kubernetes namespace named 'dev'?",
    "c": [
      "kubectl create namespace dev",
      "kubectl apply namespace dev",
      "kubectl generate namespace dev",
      "kubectl make namespace dev",
      "kubectl new namespace dev"
    ],
    "a": [
      "kubectl create namespace dev"
    ],
    "e": "To create a Kubernetes namespace named 'dev', you use the command 'kubectl create namespace dev'. This command directly creates a new namespace in your cluster."
  },
  {
    "q": "Which of the following steps are necessary to enable audit logging in Kubernetes? (Select all that apply)",
    "c": [
      "Create an audit policy file",
      "Configure the kubelet with audit flags",
      "Add '--audit-policy-file' flag to API server",
      "Restart the kube-controller-manager",
      "Specify '--audit-log-path' in the API server configuration"
    ],
    "a": [
      "Create an audit policy file",
      "Add '--audit-policy-file' flag to API server",
      "Specify '--audit-log-path' in the API server configuration"
    ],
    "e": "To enable audit logging in Kubernetes, you must create an audit policy file, specify this file using the '--audit-policy-file' flag in the API server configuration, and define the log path using '--audit-log-path'. These steps ensure that audit logs are properly configured and stored."
  },
  {
    "q": "Which compliance standard is specifically relevant for organizations handling Protected Health Information (PHI) in the healthcare sector?",
    "c": [
      "HIPAA",
      "SOX",
      "ISO 9001",
      "GDPR",
      "MITRE ATT&CK"
    ],
    "a": [
      "HIPAA"
    ],
    "e": "HIPAA is crucial for healthcare organizations as it contains security and privacy rules that protect PHI. It is particularly relevant when deploying healthcare solutions on cloud platforms like Kubernetes, ensuring compliance with PHI handling regulations."
  },
  {
    "q": "Which authentication mechanisms are commonly used by kubeadm during Kubernetes cluster bootstrapping? (Select all that apply)",
    "c": [
      "TLS certificates",
      "Token-based authentication",
      "OAuth tokens",
      "Static passwords",
      "Biometric authentication"
    ],
    "a": [
      "TLS certificates",
      "Token-based authentication"
    ],
    "e": "kubeadm primarily uses TLS certificates and token-based authentication mechanisms to secure communication and authenticate components during cluster bootstrapping. TLS certificates are used for API server and client authentication, while bootstrap tokens facilitate node joining."
  },
  {
    "q": "Why are 'distroless' container images recommended for use in production environments?",
    "c": [
      "They include a shell for debugging",
      "They have a larger attack surface",
      "They are minimal images that reduce vulnerabilities",
      "They support all Linux distributions",
      "They are required by Kubernetes"
    ],
    "a": [
      "They are minimal images that reduce vulnerabilities"
    ],
    "e": "'Distroless' images contain only the application and its runtime dependencies, excluding package managers, shells, and other unnecessary tools. This minimalism reduces the attack surface and potential vulnerabilities. They do not include shells, which can make debugging harder but improves security. They are not required by Kubernetes and do not inherently support all Linux distributions."
  },
  {
    "q": "What is the primary purpose of the NIST Cybersecurity Framework (CSF)?",
    "c": [
      "A universal law for international data privacy",
      "A set of risk management guidelines to identify, protect, detect, respond to, and recover from cyber threats",
      "A standard for container registry licensing",
      "A government mandate exclusively for financial institutions",
      "A platform for automating software supply chain security"
    ],
    "a": [
      "A set of risk management guidelines to identify, protect, detect, respond to, and recover from cyber threats"
    ],
    "e": "The NIST Cybersecurity Framework (CSF) is designed as a voluntary framework to help organizations manage and reduce cybersecurity risk. It provides a comprehensive set of guidelines and best practices structured around five core functions: Identify, Protect, Detect, Respond, and Recover. This framework is not a law or mandate but a flexible tool to improve cybersecurity posture across industries. The other options are incorrect because they either misrepresent the framework's scope or confuse it with unrelated standards or platforms."
  },
  {
    "q": "Which Kubernetes Admission Controller was deprecated and replaced by Pod Security Admission in Kubernetes version 1.25?",
    "c": [
      "PodSecurityPolicy",
      "NodeRestriction",
      "AlwaysPullImages",
      "NamespaceLifecycle",
      "LimitRanger"
    ],
    "a": [
      "PodSecurityPolicy"
    ],
    "e": "PodSecurityPolicy was deprecated in Kubernetes version 1.25 and replaced by the Pod Security Admission (PSA) controller. The PSA controller provides a simpler and more flexible way to enforce pod security standards, aligning with Kubernetes' evolving security model. Other options, such as NodeRestriction, AlwaysPullImages, NamespaceLifecycle, and LimitRanger, are not related to this deprecation."
  },
  {
    "q": "Which tool is specifically designed to benchmark a Kubernetes cluster against the Center for Internet Security (CIS) Kubernetes Benchmark best practices?",
    "c": [
      "kube-bench",
      "kube-hunter",
      "kubesec",
      "kube-score",
      "kube-linter"
    ],
    "a": [
      "kube-bench"
    ],
    "e": "kube-bench is a tool that runs checks against the CIS Kubernetes Benchmark, which is a set of best practices for securing Kubernetes clusters. It audits cluster components and configuration to identify security issues. Other tools like kube-hunter focus on penetration testing, kubesec and kube-score analyze resource configurations but do not perform CIS benchmark compliance checks, and kube-linter is a static analysis tool for Kubernetes manifests."
  },
  {
    "q": "In a Kubernetes container's securityContext, which field prevents processes from gaining elevated privileges through privilege escalation?",
    "c": [
      "runAsUser: 0",
      "privileged: false",
      "allowPrivilegeEscalation: false",
      "runAsNonRoot: false",
      "readOnlyRootFilesystem: true"
    ],
    "a": [
      "allowPrivilegeEscalation: false"
    ],
    "e": "The 'allowPrivilegeEscalation' field, when set to false, prevents a process from gaining more privileges than its parent process, effectively blocking privilege escalation attacks. Setting 'privileged' to false disables privileged mode but does not specifically prevent privilege escalation. 'runAsUser: 0' runs the container as root, which does not prevent privilege escalation. 'runAsNonRoot: false' allows running as root, so it doesn't prevent privilege escalation. 'readOnlyRootFilesystem: true' restricts filesystem writes but does not control privilege escalation."
  },
  {
    "q": "How do you configure Kubernetes to use a specific container runtime, such as containerd, on a node?",
    "c": [
      "Specify the container runtime in the pod specification",
      "Set the '--container-runtime-endpoint' flag in the kubelet configuration",
      "Configure the container runtime in the kube-proxy settings",
      "Rely on automatic detection; no manual configuration is required",
      "Set an environment variable on the master node to specify the runtime"
    ],
    "a": [
      "Set the '--container-runtime-endpoint' flag in the kubelet configuration"
    ],
    "e": "The kubelet is responsible for managing the container runtime on each node. To specify a container runtime like containerd, you configure the kubelet with the '--container-runtime-endpoint' flag, which points to the runtime's socket endpoint. This setting ensures kubelet communicates with the correct container runtime. The pod specification does not control the runtime used by the node. Kube-proxy manages networking and is unrelated to container runtimes. Automatic detection is not reliable for runtime selection. Environment variables on the master node do not affect node-level runtime configuration."
  },
  {
    "q": "What is the primary purpose of the 'kubectl config' command in Kubernetes?",
    "c": [
      "To configure Kubernetes cluster settings",
      "To manage kubeconfig files and contexts",
      "To update deployment configurations",
      "To set node configurations",
      "To modify pod specifications"
    ],
    "a": [
      "To manage kubeconfig files and contexts"
    ],
    "e": "'kubectl config' is used to view and modify kubeconfig files, which store cluster connection information, user credentials, and contexts. This command helps manage multiple clusters and user access configurations. It does not directly configure cluster settings, deployments, nodes, or pods."
  },
  {
    "q": "Which Kubernetes object defines cluster-wide permissions and roles that can be assigned to users or service accounts?",
    "c": [
      "Role",
      "ClusterRole",
      "RoleBinding",
      "ClusterRoleBinding",
      "ServiceAccount"
    ],
    "a": [
      "ClusterRole"
    ],
    "e": "'ClusterRole' defines permissions that apply across the entire Kubernetes cluster, allowing for cluster-wide access control. In contrast, 'Role' defines permissions scoped to a specific namespace. 'RoleBinding' and 'ClusterRoleBinding' are used to assign Roles or ClusterRoles to users or service accounts but do not define permissions themselves. 'ServiceAccount' represents an identity for processes running in Pods, not permissions."
  },
  {
    "q": "Why is it critical to verify the checksums of Kubernetes binaries after downloading them?",
    "c": [
      "To ensure they are the latest version",
      "To verify the integrity and authenticity of the binaries",
      "To improve their performance",
      "To check for syntax errors",
      "To enable automatic updates"
    ],
    "a": [
      "To verify the integrity and authenticity of the binaries"
    ],
    "e": "Verifying the checksums of Kubernetes binaries ensures that the files have not been tampered with or corrupted during download, confirming their integrity and authenticity. This protects against malicious modifications or accidental corruption. Checking for the latest version, performance improvements, syntax errors, or enabling automatic updates are unrelated to checksum verification."
  },
  {
    "q": "What command is used to create a Kubernetes namespace named 'production'?",
    "c": [
      "kubectl create namespace production",
      "kubectl create deployment production",
      "kubectl apply -f namespace.yaml",
      "kubectl config set-context production"
    ],
    "a": [
      "kubectl create namespace production"
    ],
    "e": "The command 'kubectl create namespace production' is used to create a new namespace in a Kubernetes cluster. Namespaces provide a way to divide cluster resources between multiple applications or teams. They are essential for organizing and isolating resources within a cluster."
  },
  {
    "q": "What measures can you take to prevent a container from running as the root user in Kubernetes?",
    "c": [
      "Set 'runAsUser: 0' in the security context",
      "Use a Pod Security Admission to enforce non-root user requirements",
      "It is not possible to prevent this",
      "Modify the container image to exclude root user privileges",
      "Set 'allowPrivilegeEscalation: true' in the security context"
    ],
    "a": [
      "Use a Pod Security Admission to enforce non-root user requirements"
    ],
    "e": "To enhance security, you can use Pod Security Admission to enforce that containers run as non-root users. This prevents potential privilege escalation attacks. Option 1 ('runAsUser: 0') explicitly allows running as root, which is insecure. Option 3 is incorrect because Kubernetes provides mechanisms to enforce non-root users. Option 4 may reduce root privileges but does not enforce non-root execution. Option 5 ('allowPrivilegeEscalation: true') enables privilege escalation, which contradicts the goal of preventing root access."
  },
  {
    "q": "Select all that apply: Which command(s) can be used to list all ServiceAccounts in the 'dev' namespace?",
    "c": [
      "kubectl get sa -n dev",
      "kubectl get serviceaccount -A",
      "kubectl get serviceaccounts --namespace=dev",
      "kubectl describe serviceaccounts -n dev",
      "kubectl list sa dev"
    ],
    "a": [
      "kubectl get sa -n dev",
      "kubectl get serviceaccounts --namespace=dev",
      "kubectl describe serviceaccounts -n dev"
    ],
    "e": "The commands `kubectl get sa -n dev`, `kubectl get serviceaccounts --namespace=dev`, and `kubectl describe serviceaccounts -n dev` all list ServiceAccounts in the 'dev' namespace. The first two provide a summary list, while `kubectl describe` provides detailed information about each ServiceAccount. Option 1 (`kubectl get serviceaccount -A`) lists ServiceAccounts across all namespaces, and Option 4 (`kubectl list sa dev`) is not a valid `kubectl` command."
  },
  {
    "q": "In the STRIDE threat model, which category best describes an attacker exploiting a buffer overflow to gain root access?",
    "c": [
      "Elevation of Privileges",
      "Information Disclosure",
      "Tampering",
      "Denial of Service"
    ],
    "a": [
      "Elevation of Privileges"
    ],
    "e": "Exploiting a buffer overflow to gain root access is classified as an Elevation of Privileges threat because it involves escalating an attacker's privileges to access sensitive resources. This is a critical threat as it can lead to full system compromise."
  },
  {
    "q": "What is the primary focus of the NSA/CISA Kubernetes Hardening Guidance?",
    "c": [
      "Using insecure container registries for testing purposes",
      "Skipping vulnerability scanning to reduce operational overhead",
      "Securing supply chain components and minimizing container privileges",
      "Disabling TLS to accelerate deployment processes",
      "Automatically approving all configuration changes to enhance agility"
    ],
    "a": [
      "Securing supply chain components and minimizing container privileges"
    ],
    "e": "The NSA/CISA Kubernetes Hardening Guidance emphasizes securing the software supply chain and minimizing container privileges to reduce attack surfaces. This includes practices like signing container images, scanning for vulnerabilities, and implementing least privilege access controls."
  },
  {
    "q": "Which security development framework explicitly incorporates threat modeling and validation phases to ensure secure software development?",
    "c": [
      "Microsoft Security Development Lifecycle (SDL)",
      "Open Container Initiative (OCI) Standard",
      "JWT Token Compliance Framework",
      "HTTP Strict Transport Security (HSTS)",
      "NIST Special Publication 800-63"
    ],
    "a": [
      "Microsoft Security Development Lifecycle (SDL)"
    ],
    "e": "The Microsoft Security Development Lifecycle (SDL) is a comprehensive framework that integrates security at every phase of software development, including explicit phases for requirements definition, threat modeling, mitigation strategies, and validation. This approach helps identify and address security risks early. Other options either focus on standards for container formats (OCI), token compliance, transport security policies (HSTS), or identity proofing guidelines (NIST SP 800-63), which do not specifically include threat modeling and validation phases within software development."
  },
  {
    "q": "Which Kubernetes tool uses a webhook-based admission controller to enforce compliance policies?",
    "c": [
      "Kube-proxy",
      "Prometheus",
      "Open Policy Agent (OPA) Gatekeeper",
      "kubectl",
      "MetalLB"
    ],
    "a": [
      "Open Policy Agent (OPA) Gatekeeper"
    ],
    "e": "Open Policy Agent (OPA) Gatekeeper integrates with Kubernetes as a webhook admission controller, allowing administrators to enforce custom policies on Kubernetes resources during creation or update. This enables automated compliance enforcement. Kube-proxy manages network proxying, Prometheus is for monitoring, kubectl is a CLI tool, and MetalLB provides load balancing; none of these enforce policies via admission webhooks."
  },
  {
    "q": "What command is used to list all pods across all namespaces in a Kubernetes cluster?",
    "c": [
      "'kubectl get pods'",
      "'kubectl get pods --all'",
      "'kubectl get pods -A'",
      "'kubectl get pods --namespaces'",
      "'kubectl get all-pods'"
    ],
    "a": [
      "'kubectl get pods -A'"
    ],
    "e": "The '-A' flag is used with 'kubectl get pods' to list resources in all namespaces. This is a shorthand for '--all-namespaces', which ensures that pods from every namespace are displayed."
  },
  {
    "q": "Which Kubernetes resources, if compromised, could lead to significant security breaches and should be audited carefully? (Select all that apply)",
    "c": [
      "Secrets",
      "ConfigMaps",
      "Pods",
      "ServiceAccounts",
      "PersistentVolumes"
    ],
    "a": [
      "Secrets",
      "ServiceAccounts"
    ],
    "e": "Secrets and ServiceAccounts are considered sensitive Kubernetes resources because they often contain confidential information such as credentials, API keys, and tokens. If compromised, these resources can lead to unauthorized access, privilege escalation, or data breaches. ConfigMaps generally contain non-sensitive configuration data and are less critical from a security perspective. While Pods and PersistentVolumes are important, they are not typically audited for sensitive information unless they handle sensitive data explicitly."
  },
  {
    "q": "What is the primary purpose of Botkube in a Kubernetes environment?",
    "c": [
      "To provide an integrated container build system",
      "To automate Slack-based alerts for compliance and security events",
      "To serve as an API gateway for microservices",
      "To orchestrate container autoscaling across clusters",
      "To replace kubelet on worker nodes"
    ],
    "a": [
      "To automate Slack-based alerts for compliance and security events"
    ],
    "e": "Botkube is a Kubernetes monitoring tool that integrates with messaging platforms like Slack, Microsoft Teams, or Mattermost to send real-time alerts about cluster events, compliance issues, and security incidents. It helps teams stay informed without constantly monitoring dashboards. It is not a container build system, API gateway, autoscaling orchestrator, or a replacement for kubelet."
  },
  {
    "q": "Which securityContext field makes a container's root filesystem read-only to prevent modifications?",
    "c": [
      "readOnlyFileSystem",
      "readOnlyRootFilesystem",
      "immutableRoot",
      "filesystemReadonly",
      "noWriteFilesystem"
    ],
    "a": [
      "readOnlyRootFilesystem"
    ],
    "e": "The 'readOnlyRootFilesystem' field in a container's securityContext makes the root filesystem read-only, preventing any modifications and enhancing container security."
  },
  {
    "q": "What does the term 'container breakout' refer to in the context of container security?",
    "c": [
      "When a container fails to start properly",
      "A container exceeding its allocated resource limits",
      "An attack where an attacker escapes container isolation to gain access to the host system",
      "Scaling a container beyond its maximum configured replicas",
      "Migrating a container to a different node in the cluster"
    ],
    "a": [
      "An attack where an attacker escapes container isolation to gain access to the host system"
    ],
    "e": "A container breakout occurs when an attacker exploits vulnerabilities to escape the isolation boundaries of a container and gain unauthorized access to the underlying host system. This compromises the host's security and can lead to privilege escalation. Other options describe container lifecycle or resource management issues, which are unrelated to security breaches involving isolation escape."
  },
  {
    "q": "What is the primary function of the 'kubeadm' tool in Kubernetes?",
    "c": [
      "To manage container images",
      "To bootstrap Kubernetes clusters",
      "To monitor cluster health",
      "To deploy applications to the cluster",
      "To manage network policies"
    ],
    "a": [
      "To bootstrap Kubernetes clusters"
    ],
    "e": "The `kubeadm` tool is used to bootstrap a Kubernetes cluster, making it easier to set up and manage clusters. It automates the installation and configuration process, ensuring that all necessary components are properly initialized."
  },
  {
    "q": "Which of the following lists the five core functions of the NIST Cybersecurity Framework?",
    "c": [
      "Monitor, Map, Maintain, Minimise, and Mutate",
      "Identify, Protect, Detect, Respond, and Recover",
      "Review, Replace, Retract, Renew, and Reserve",
      "Discover, Compare, Archive, Document, and Renew",
      "Encrypt, Store, Backup, Alert, and Evaluate"
    ],
    "a": [
      "Identify, Protect, Detect, Respond, and Recover"
    ],
    "e": "The NIST Cybersecurity Framework (CSF) is structured around five core functions: Identify, Protect, Detect, Respond, and Recover. These functions provide a high-level, strategic view of the lifecycle of managing cybersecurity risk. The other options list unrelated or incorrect terms that do not correspond to the NIST CSF core functions."
  },
  {
    "q": "Which compliance framework is mandatory for U.S. federal agencies or their contractors when hosting government data in cloud environments?",
    "c": [
      "FedRAMP",
      "COSO",
      "ISO 20000",
      "DMARC",
      "SAML"
    ],
    "a": [
      "FedRAMP"
    ],
    "e": "FedRAMP is a government-wide program that provides a standardized approach to security assessment, authorization, and continuous monitoring for cloud products and services used by U.S. federal agencies. It ensures that cloud services meet specific security requirements."
  },
  {
    "q": "Which Kubernetes resource object is used to request a certificate signing operation via the Kubernetes API?",
    "c": [
      "CertificateRequest",
      "CertificateSigningRequest",
      "CertificateApproval",
      "CertificateSigning",
      "Certificate"
    ],
    "a": [
      "CertificateSigningRequest"
    ],
    "e": "The Kubernetes resource 'CertificateSigningRequest' (CSR) is the official API object used to request a certificate signing operation. Users or components create a CSR object containing a public key and metadata; cluster administrators or automated controllers then approve and sign it. The other options are not valid Kubernetes resource kinds: 'CertificateRequest' and 'CertificateSigning' do not exist as Kubernetes resources; 'CertificateApproval' is not a resource but an action; 'Certificate' is not a Kubernetes resource for CSRs."
  },
  {
    "q": "Which STRIDE category is primarily concerned with service availability?",
    "c": [
      "Spoofing",
      "Tampering",
      "Denial of Service",
      "Information Disclosure",
      "Elevation of Privileges"
    ],
    "a": [
      "Denial of Service"
    ],
    "e": "Denial of Service (DoS) is the STRIDE category focused on making services unavailable. This can be achieved through various means, such as overwhelming a system with requests or disrupting network connectivity. The other options involve different types of threats: impersonation (Spoofing), data modification (Tampering), unauthorized data access (Information Disclosure), and unauthorized privilege escalation (Elevation of Privileges)."
  },
  {
    "q": "If Kubernetes audit logs are stored at '/var/log/kubernetes/audit.log', which command can you use to view these logs in real time?",
    "c": [
      "kubectl logs audit",
      "sudo tail -f /var/log/kubernetes/audit.log",
      "kubectl get events --audit",
      "journalctl -u kube-apiserver",
      "kubectl describe audit-logs"
    ],
    "a": [
      "sudo tail -f /var/log/kubernetes/audit.log"
    ],
    "e": "Audit logs written to a file such as '/var/log/kubernetes/audit.log' can be viewed in real time using the 'tail -f' command with appropriate permissions, hence 'sudo tail -f /var/log/kubernetes/audit.log'. The 'kubectl logs' command is used for container logs, not audit logs stored on the host. 'kubectl get events --audit' and 'kubectl describe audit-logs' are invalid commands. 'journalctl -u kube-apiserver' shows the kube-apiserver service logs but may not include audit logs if they are configured to a separate file."
  },
  {
    "q": "Which Docker flag allows a container to share the PID namespace with another container named 'container1'?",
    "c": [
      "--pid=host",
      "--pid=container1",
      "--pid=container:container1",
      "--net=container:container1",
      "--namespace=pid:container1"
    ],
    "a": [
      "--pid=container:container1"
    ],
    "e": "The correct flag to share the PID namespace is '--pid=container:container1'. This allows processes in one container to see and interact with processes in the other container."
  },
  {
    "q": "In a Kubernetes cluster, which component is responsible for assigning pods to specific nodes based on resource requirements and constraints?",
    "c": [
      "kube-apiserver",
      "kube-scheduler",
      "kubelet",
      "kube-controller-manager",
      "etcd"
    ],
    "a": [
      "kube-scheduler"
    ],
    "e": "The kube-scheduler is the component in Kubernetes responsible for scheduling pods onto nodes. It evaluates the resource requirements of the pods (e.g., CPU, memory) and matches them with the available resources on nodes. Other components, such as kube-apiserver, handle API requests; kubelet manages node-level operations; kube-controller-manager handles controllers; and etcd is the key-value store for cluster data."
  },
  {
    "q": "In Kubernetes, what is the main reason for using namespaces?",
    "c": [
      "To provide network isolation between different applications.",
      "To group and logically isolate resources such as deployments, services, and pods.",
      "To enforce security policies across the entire cluster.",
      "To manage the lifecycle of persistent storage volumes.",
      "To monitor the overall health and performance of the Kubernetes cluster."
    ],
    "a": [
      "To group and logically isolate resources such as deployments, services, and pods."
    ],
    "e": "Namespaces in Kubernetes are primarily used to logically divide a cluster into multiple virtual clusters. This allows teams or projects to operate in isolation from one another within the same physical cluster. While namespaces can be used in conjunction with network policies to provide network isolation, their primary purpose is logical grouping and isolation of Kubernetes resources like pods, services, and deployments. They do not inherently enforce security policies or manage storage volumes directly, nor are they primarily for monitoring cluster health."
  },
  {
    "q": "What happens by default when a container in a Kubernetes pod crashes?",
    "c": [
      "The pod is deleted",
      "Kubernetes does nothing",
      "The kubelet restarts the container",
      "An alert is sent to the administrator",
      "The node is drained"
    ],
    "a": [
      "The kubelet restarts the container"
    ],
    "e": "By default, when a container in a Kubernetes pod crashes, the kubelet will automatically restart it. This behavior can be configured using restart policies."
  },
  {
    "q": "Which Kubernetes resource is used to run a one-time task?",
    "c": [
      "Deployment",
      "StatefulSet",
      "DaemonSet",
      "Job",
      "ReplicaSet"
    ],
    "a": [
      "Job"
    ],
    "e": "In Kubernetes, a Job is used to run a one-time task. Jobs create one or more pods to perform a task and ensure they complete successfully. They are ideal for batch processing or running tasks that need to complete before the pods are terminated."
  },
  {
    "q": "What is a significant security risk associated with using an insecure container registry?",
    "c": [
      "Faster image downloads",
      "Increased image caching",
      "Man-in-the-middle attacks leading to compromised images",
      "Improved image availability",
      "Automatic image updates"
    ],
    "a": [
      "Man-in-the-middle attacks leading to compromised images"
    ],
    "e": "Using an insecure container registry exposes images to interception and tampering during transit, enabling man-in-the-middle attacks that can compromise container images. This can lead to running malicious or altered images in production. The other options describe benefits or neutral effects unrelated to security risks."
  },
  {
    "q": "Which tool serves as a data source for visualizing Kubernetes cluster metrics in Grafana?",
    "c": [
      "Prometheus",
      "Elasticsearch",
      "Kibana",
      "Fluentd",
      "Logstash"
    ],
    "a": [
      "Prometheus"
    ],
    "e": "Prometheus is a robust monitoring and alerting toolkit that collects metrics from Kubernetes clusters. These metrics can be integrated into Grafana as a data source to create dashboards for visualization. While Grafana handles the visualization, Prometheus provides the necessary data. Other options like Elasticsearch, Kibana, Fluentd, and Logstash are primarily used for logging and log analysis, not for collecting or serving metrics directly."
  },
  {
    "q": "Which Kubernetes resource is designed to manage long-running, stateful applications that require stable network identities and persistent storage?",
    "c": [
      "Deployment",
      "Job",
      "StatefulSet",
      "DaemonSet",
      "ReplicaSet"
    ],
    "a": [
      "StatefulSet"
    ],
    "e": "StatefulSets are used to manage stateful applications that require stable, unique network identifiers and persistent storage across pod restarts. Unlike Deployments or ReplicaSets, which are suited for stateless applications, StatefulSets ensure that pods are created in order and maintain persistent identities. Jobs are for batch or finite tasks, and DaemonSets ensure a pod runs on every node but do not provide stable identities or storage."
  },
  {
    "q": "Which flag combination with the 'kubectl run' command generates a Pod manifest in YAML format without actually creating the Pod resource in the cluster?",
    "c": [
      "--dry-run=server",
      "--dry-run=client -o yaml",
      "--output=yaml",
      "--generate-only",
      "--no-create"
    ],
    "a": [
      "--dry-run=client -o yaml"
    ],
    "e": "Using '--dry-run=client -o yaml' with 'kubectl run' simulates the creation of the Pod resource on the client side and outputs the manifest in YAML format without sending it to the API server, thus not creating the resource. '--dry-run=server' validates on the server side but does not output YAML by default. '--output=yaml' alone does not prevent creation. '--generate-only' and '--no-create' are deprecated or invalid flags."
  },
  {
    "q": "Which of the following are the recognized Pod Security Standard levels in Kubernetes? (Select all that apply)",
    "c": [
      "Privileged",
      "Baseline",
      "Restricted",
      "Unrestricted",
      "Default"
    ],
    "a": [
      "Privileged",
      "Baseline",
      "Restricted"
    ],
    "e": "The Pod Security Standards define three levels of security enforcement for pods: Privileged, Baseline, and Restricted. 'Privileged' allows the most permissions, 'Baseline' enforces a moderate security posture suitable for most applications, and 'Restricted' enforces the strictest security controls. 'Unrestricted' and 'Default' are not recognized Pod Security Standard levels."
  },
  {
    "q": "What does 'Elevation of Privileges' mean in the context of STRIDE?",
    "c": [
      "Gaining access to resources by posing as someone else",
      "Modifying data in transit",
      "Gaining unauthorized access rights that one should not have",
      "Denial of actions performed",
      "Accessing services during downtime"
    ],
    "a": [
      "Gaining unauthorized access rights that one should not have"
    ],
    "e": "Elevation of Privileges refers to the unauthorized acquisition of higher access rights than those originally granted. This can lead to increased capabilities to perform actions that were previously restricted. The other options describe different threats: impersonation (Spoofing), data tampering (Tampering), denial of actions (Denial of Service), and accessing services during maintenance (not a specific STRIDE category)."
  },
  {
    "q": "How can you retrieve a list of all contexts in your kubeconfig file?",
    "c": [
      "kubectl config get-contexts",
      "kubectl get contexts",
      "kubectl config view",
      "kubectl context list",
      "kubectl list contexts"
    ],
    "a": [
      "kubectl config get-contexts"
    ],
    "e": "To list all contexts in your kubeconfig file, you use the command `kubectl config get-contexts`. This command displays all available contexts, which are used to manage different Kubernetes clusters or environments."
  },
  {
    "q": "What is the default behavior of Kubernetes network traffic when no Network Policies are applied to a namespace?",
    "c": [
      "All ingress and egress traffic is denied",
      "All ingress traffic is denied; egress traffic is allowed",
      "All ingress and egress traffic is allowed",
      "All egress traffic is denied; ingress traffic is allowed",
      "Traffic is allowed only within the namespace"
    ],
    "a": [
      "All ingress and egress traffic is allowed"
    ],
    "e": "By default, Kubernetes allows all ingress and egress traffic to pods if no Network Policies are applied. Network Policies are opt-in and must be explicitly created to restrict traffic. Without any policies, pods can send and receive traffic unrestricted. The other options describe behaviors that occur only when specific Network Policies are configured."
  },
  {
    "q": "To prevent Pods from accessing the cloud provider's metadata API, which IP address should be blocked in a Kubernetes NetworkPolicy?",
    "c": [
      "0.0.0.0/0",
      "127.0.0.1/32",
      "169.254.169.254/32",
      "255.255.255.255/32",
      "192.168.0.1/32"
    ],
    "a": [
      "169.254.169.254/32"
    ],
    "e": "The IP address 169.254.169.254 is the standard link-local address used by cloud providers (such as AWS, GCP, Azure) for their metadata service. Blocking this IP in a NetworkPolicy prevents Pods from querying sensitive metadata, mitigating risks like metadata service exploitation. Other IPs listed do not correspond to the cloud metadata service."
  },
  {
    "q": "What is the effect of the 'kubectl rollout undo' command on a Kubernetes deployment?",
    "c": [
      "Rolls back to the previous revision",
      "Deletes the deployment and all associated pods",
      "Pauses the deployment to prevent further updates",
      "Scales the deployment to a specified number of replicas"
    ],
    "a": [
      "Rolls back to the previous revision"
    ],
    "e": "The 'kubectl rollout undo' command reverts a deployment to its previous revision, effectively rolling back any changes made in the most recent update. It does not delete, pause, scale, or update the deployment to a new version but restores the last known good state."
  },
  {
    "q": "What is the primary purpose of a Cloud Workload Protection Platform (CWPP)?",
    "c": [
      "Monitor network traffic",
      "Secure workloads across various environments",
      "Manage cloud costs",
      "Provide identity and access management",
      "Automate infrastructure provisioning"
    ],
    "a": [
      "Secure workloads across various environments"
    ],
    "e": "CWPPs are designed to protect workloads in any environment."
  },
  {
    "q": "Which of the following are common CNI plugins that support Network Policies? (Select all that apply)",
    "c": [
      "Flannel",
      "Calico",
      "Weave Net",
      "AWS VPC CNI",
      "Cilium"
    ],
    "a": [
      "Calico",
      "Weave Net",
      "AWS VPC CNI",
      "Cilium"
    ],
    "e": "Calico, Weave Net, Cilium, and AWS VPC CNI are CNI plugins that support Network Policies. AWS VPC CNI supports network policies but requires them to be enabled and does not support them for Fargate or Windows containers. Flannel does not support Network Policies by default."
  },
  {
    "q": "What is the primary function of Resource Quotas in a Kubernetes namespace?",
    "c": [
      "Limit the number of namespaces in the cluster",
      "Restrict access to the Kubernetes API server",
      "Control the amount of resources consumed within a namespace",
      "Schedule pods to specific nodes",
      "Enforce network policies"
    ],
    "a": [
      "Control the amount of resources consumed within a namespace"
    ],
    "e": "Resource Quotas in Kubernetes are used to limit the total amount of compute resources (such as CPU, memory, and object counts) that can be consumed within a namespace. This helps prevent a single namespace from exhausting cluster resources. Resource Quotas do not limit namespaces themselves, control API server access, schedule pods, or enforce network policies, which are handled by other Kubernetes components."
  },
  {
    "q": "Where in a Pod specification should you declare the use of a gVisor RuntimeClass to ensure all containers in the Pod use this secure runtime environment?",
    "c": [
        "Set 'runtimeClassName: \"gvisor\"' at the Pod spec level",
        "Add it under the Pod's SecurityContext 'seccompProfile' field",
        "Specify it in the 'runtime' field within each container's definition",
        "Define it as an annotation: 'annotations.runtime.class/gvisor'"
    ],
    "a": [
      "Set 'runtimeClassName: \"gvisor\"' at the Pod spec level"
    ],
    "e": "The 'runtimeClassName' field must be specified directly in the Pod's spec section (pod.spec.runtimeClassName). This ensures all containers in the Pod use the specified runtime. SecurityContext handles security parameters but not runtime selection, and container-level runtime configuration isn't supported in this manner."
  },
  {
    "q": "In Kubernetes security contexts, what specific security benefit does configuring 'readOnlyRootFilesystem: true' provide to containers?",
    "c": [
      "Prevents container processes from modifying host network configurations",
      "Enables root user privileges for container operations",
      "Restricts container processes from writing to the root filesystem",
      "Allows containers to bypass filesystem permission checks",
      "Disables container logging capabilities"
    ],
    "a": [
      "Restricts container processes from writing to the root filesystem"
    ],
    "e": "Setting readOnlyRootFilesystem to true mounts the container's root filesystem as read-only, preventing malicious processes from writing to or modifying system files. This hardening measure significantly reduces attack surfaces by blocking persistence mechanisms and limiting damage from container escapes. Other options describe unrelated security mechanisms: network restrictions (option 1), privilege escalation (option 2/4), and logging (option 5) require separate configurations."
  },
  {
    "q": "Which Kubernetes object is used to define a set of network access rules that control traffic to and from pods?",
    "c": [
      "Service",
      "Deployment",
      "Ingress",
      "NetworkPolicy",
      "ConfigMap"
    ],
    "a": [
      "NetworkPolicy"
    ],
    "e": "NetworkPolicy objects in Kubernetes are used to specify rules that control the ingress and egress traffic to and from pods. Services manage access at a different layer, Ingress manages external access, Deployments manage pod lifecycle, and ConfigMaps store configuration data, none of which control pod-level network access rules."
  },
  {
    "q": "In a Kubernetes NetworkPolicy, which selector is used to specify the Pods to which the policy applies?",
    "c": [
      "podSelector",
      "namespaceSelector",
      "policySelector",
      "matchLabels",
      "appSelector"
    ],
    "a": [
      "podSelector"
    ],
    "e": "The 'podSelector' field in a NetworkPolicy defines the set of Pods that the policy applies to by selecting Pods based on labels. 'namespaceSelector' selects namespaces, not Pods. 'policySelector' is not a valid field in NetworkPolicy. 'matchLabels' is a label selector syntax used inside 'podSelector' but is not itself a selector field. 'appSelector' is not a standard Kubernetes selector field."
  },
  {
    "q": "Which strace command attaches to an already running process with PID 1234 to trace its system calls?",
    "c": [
      "strace 1234",
      "strace -p 1234",
      "strace -c 1234",
      "sudo trace -pid 1234",
      "strace --process 1234"
    ],
    "a": [
      "strace -p 1234"
    ],
    "e": "The correct command to attach strace to a running process with PID 1234 is 'strace -p 1234'. The '-p' option specifies the process ID to attach to. 'strace 1234' attempts to run a new process named '1234', which is invalid. 'strace -c 1234' runs strace with summary statistics on a new process named '1234'. 'sudo trace -pid 1234' is not a valid command, and 'strace --process 1234' is not a recognized option."
  },
  {
    "q": "What is the correct kubectl command to set the default namespace for all subsequent operations in the current context?",
    "c": [
      "kubectl config use-context <namespace>",
      "kubectl set namespace <namespace>",
      "kubectl config set-context --current --namespace=<namespace>",
      "kubectl namespace set <namespace>",
      "kubectl switch namespace <namespace>"
    ],
    "a": [
      "kubectl config set-context --current --namespace=<namespace>"
    ],
    "e": "The command 'kubectl config set-context --current --namespace=<namespace>' modifies the current context's namespace setting persistently. This differs from temporary namespace overrides using '-n' flag, and ensures all subsequent commands use the specified namespace by default. Other options either use incorrect syntax or modify different configuration aspects."
  },
  {
    "q": "Which of the following are critical security hardening measures for the Kubernetes API server? (Select all that apply)",
    "c": [
      "Disable anonymous authentication",
      "Enable RBAC authorization",
      "Allow all admission controllers",
      "Enable etcd encryption for secrets",
      "Use insecure port for API communication"
    ],
    "a": [
      "Disable anonymous authentication",
      "Enable RBAC authorization",
      "Enable etcd encryption for secrets"
    ],
    "e": "Disabling anonymous authentication prevents unauthorized access, RBAC enables granular permissions, and etcd encryption protects sensitive data. Allowing all admission controllers (including deprecated ones) and using insecure ports would reduce security. The insecure port (--insecure-port) is deprecated and should be disabled."
  },
  {
    "q": "Which Kubernetes component is responsible for maintaining network rules on nodes for services?",
    "c": [
      "kubelet",
      "kube-proxy",
      "kube-scheduler",
      "kube-controller-manager",
      "etcd"
    ],
    "a": [
      "kube-proxy"
    ],
    "e": "kube-proxy is the component that maintains network rules on nodes for services. It ensures that incoming traffic is properly routed to the correct service endpoints."
  },
  {
    "q": "In the STRIDE threat modeling framework, what does the letter 'S' represent?",
    "c": [
      "Spoofing",
      "Scanning",
      "Snooping",
      "Spamming",
      "Sniffing"
    ],
    "a": [
      "Spoofing"
    ],
    "e": "In STRIDE, a widely used threat modeling framework, 'S' stands for Spoofing, which refers to an attacker pretending to be someone or something else to gain unauthorized access. The other options like scanning, snooping, spamming, and sniffing are related to security but are not part of the STRIDE categories."
  },
  {
    "q": "What is the primary function of a Kubernetes Ingress resource in managing network traffic?",
    "c": [
      "To manage internal cluster networking",
      "To define rules for routing external HTTP and HTTPS traffic to services",
      "To provide persistent storage to pods",
      "To schedule pods onto nodes",
      "To configure network policies for pod communication"
    ],
    "a": [
      "To define rules for routing external HTTP and HTTPS traffic to services"
    ],
    "e": "A Kubernetes Ingress resource primarily manages external access to services within a cluster by defining rules for routing HTTP and HTTPS traffic. It acts as an entry point that controls how external clients reach services inside the cluster. Other options are incorrect because internal networking is handled by Services and CNI plugins, storage is managed by PersistentVolumes, pod scheduling is done by the scheduler, and network policies control pod-to-pod communication rather than external traffic."
  },
  {
    "q": "In a Kubernetes Pod specification, which field is used to specify the ServiceAccount under which the Pod should run?",
    "c": [
      "serviceAccount",
      "serviceAccountName",
      "accountName",
      "saName",
      "serviceAccountSpec"
    ],
    "a": [
      "serviceAccountName"
    ],
    "e": "The correct field is 'serviceAccountName', which defines the name of the ServiceAccount that the Pod uses for authentication and authorization. The other options are incorrect as they are not valid Pod spec fields. 'serviceAccount' and 'accountName' do not exist in the Pod spec. 'saName' and 'serviceAccountSpec' are not recognized fields."
  },
  {
    "q": "What is the effect of disabling anonymous authentication on the kubelet?",
    "c": [
      "Increased security by requiring authentication",
      "Nodes cannot join the cluster",
      "Pods fail to start",
      "kube-proxy stops working",
      "No effect; kubelet does not support anonymous access"
    ],
    "a": [
      "Increased security by requiring authentication"
    ],
    "e": "Disabling anonymous authentication on the kubelet enhances security by ensuring that only authenticated requests are accepted. This prevents unauthorized access and reduces the risk of attacks."
  },
  {
    "q": "How can you enable Pod Security Admission (PSA) in a Kubernetes cluster to enforce pod security standards?",
    "c": [
      "By applying security labels directly to pods",
      "By configuring the API server to enable the PodSecurity admission controller",
      "By setting environment variables on cluster nodes",
      "By deploying a third-party admission webhook",
      "By updating kubelet configurations on nodes"
    ],
    "a": [
      "By configuring the API server to enable the PodSecurity admission controller"
    ],
    "e": "Pod Security Admission (PSA) is enabled by configuring the Kubernetes API server to include the 'PodSecurity' admission controller in its '--enable-admission-plugins' flag. This admission controller enforces pod security standards based on namespace labels. Applying labels to pods or setting environment variables on nodes does not enable PSA. While third-party admission webhooks can enforce policies, PSA is a built-in admission controller. Kubelet configurations do not control PSA."
  },
  {
    "q": "What is the primary function of Kubernetes labels in organizing resources?",
    "c": [
      "To provide human-readable names for resources",
      "To organize and select groups of objects",
      "To store configuration data",
      "To set permissions on resources",
      "To define network policies"
    ],
    "a": [
      "To organize and select groups of objects"
    ],
    "e": "Kubernetes labels are key-value pairs attached to objects, such as pods or services, to facilitate identification and selection. They enable users to organize and filter resources based on specific criteria, making it easier to manage complex environments."
  },
  {
    "q": "Which Kubernetes resource defines permissions within a specific namespace?",
    "c": [
      "ClusterRole",
      "ClusterRoleBinding",
      "Role",
      "RoleBinding",
      "ServiceAccount"
    ],
    "a": [
      "Role"
    ],
    "e": "A Role in Kubernetes defines permissions within a namespace. It specifies what actions can be performed by users or service accounts within that namespace."
  },
  {
    "q": "How does Kube-bench contribute to enhancing Kubernetes security?",
    "c": [
      "By automating cluster scaling during high load",
      "By auditing cluster configurations against CIS Kubernetes Benchmark recommendations",
      "By providing a continuous integration pipeline for containers",
      "By replacing default CNI plugins with a secure version",
      "By encrypting container images at runtime"
    ],
    "a": [
      "By auditing cluster configurations against CIS Kubernetes Benchmark recommendations"
    ],
    "e": "Kube-bench is a tool that automates the evaluation of Kubernetes cluster configurations to ensure they align with the CIS Kubernetes Benchmark recommendations. This helps identify and address potential security vulnerabilities."
  },
  {
    "q": "Which Kubernetes resource is used to enforce network segmentation between pods?",
    "c": [
      "NetworkPolicy",
      "PodSecurityPolicy",
      "ResourceQuota",
      "LimitRange",
      "Ingress"
    ],
    "a": [
      "NetworkPolicy"
    ],
    "e": "NetworkPolicy defines rules that segment network traffic between pods, allowing you to control the flow of traffic and isolate pods from each other. This is essential for securing communication within a Kubernetes cluster."
  },
  {
    "q": "After identifying an unwanted process listening on a network port, which command can you use to terminate that process by its process ID (PID)?",
    "c": [
      "killall <process-name>",
      "sudo stop <process-name>",
      "sudo systemctl disable <process-name>",
      "sudo kill <pid>",
      "sudo service <process-name> remove"
    ],
    "a": [
      "sudo kill <pid>"
    ],
    "e": "The command 'sudo kill <pid>' sends a termination signal to the process with the specified PID, effectively stopping it. 'killall <process-name>' kills all processes matching the name but requires the exact process name and may affect multiple processes. 'sudo stop <process-name>' is used to stop services managed by Upstart, which is less common now. 'sudo systemctl disable <process-name>' disables a systemd service from starting on boot but does not stop a running process immediately. 'sudo service <process-name> remove' is not a valid command to stop processes."
  },
  {
    "q": "What are the key characteristics of gVisor and Firecracker? (Select all that apply)",
    "c": [
      "gVisor is a user-space kernel providing sandboxing",
      "Firecracker uses lightweight microVMs with KVM",
      "Both provide full hardware virtualization",
      "Firecracker is a container runtime interface",
      "gVisor offers better performance than traditional VMs"
    ],
    "a": [
      "gVisor is a user-space kernel providing sandboxing",
      "Firecracker uses lightweight microVMs with KVM",
      "gVisor offers better performance than traditional VMs"
    ],
    "e": "gVisor provides sandboxing by running in user space and intercepting system calls, which enhances security without the need for full hardware virtualization. Firecracker uses microVMs, leveraging KVM for efficient isolation. gVisor can offer better performance compared to traditional VMs due to its lightweight nature."
  },
  {
    "q": "Which Kubernetes admission controller specifically restricts kubelets to only modify their own Node API objects and Pod objects bound to their node?",
    "c": [
      "NodeRestriction",
      "LimitRanger",
      "NamespaceLifecycle",
      "ResourceQuota",
      "PodSecurityPolicy"
    ],
    "a": [
      "NodeRestriction"
    ],
    "e": "The NodeRestriction admission controller limits kubelet permissions to prevent node spoofing and privilege escalation. It ensures kubelets can only modify their own Node API object and Pod objects scheduled on their node, while LimitRanger and ResourceQuota manage resource constraints."
  },
  {
    "q": "What command should you use to delete all pods within a Kubernetes namespace named 'test'?",
    "c": [
      "kubectl delete pods --all -n test",
      "kubectl delete pod -A",
      "kubectl delete pods -n test",
      "kubectl remove pods --namespace=test",
      "kubectl delete pods * -n test"
    ],
    "a": [
      "kubectl delete pods --all -n test"
    ],
    "e": "To delete all pods in a specific namespace, you use the `kubectl delete pods` command with the `--all` flag to specify all pods, and the `-n` flag to specify the namespace. The correct command is `kubectl delete pods --all -n test`. This command will delete all pods in the 'test' namespace, which can be useful for cleaning up resources or resetting a namespace."
  },
  {
    "q": "What is the purpose of the 'kubectl exec' command in Kubernetes?",
    "c": [
      "Executes a command on the Kubernetes control plane",
      "Runs a command inside a container in a pod",
      "Creates a new pod in the cluster",
      "Updates an existing deployment",
      "Deletes a Kubernetes resource"
    ],
    "a": [
      "Runs a command inside a container in a pod"
    ],
    "e": "'kubectl exec' is used to execute a command inside a running container within a Kubernetes pod. This is particularly useful for debugging or interacting with applications running inside containers. For example, you can use it to access logs or run shell commands within the container. Other options are incorrect because: - Option 0: Commands are not executed on the control plane using 'kubectl exec'. - Option 2: It does not create new pods; 'kubectl run' or deployment manifests are used for that. - Option 3: Updating deployments is done using 'kubectl apply' or 'kubectl set'. - Option 4: Deleting resources is handled by 'kubectl delete'."
  },
  {
    "q": "What is the primary purpose of a PersistentVolumeClaim (PVC) in Kubernetes?",
    "c": [
      "To request storage resources from the cluster",
      "To define storage classes",
      "To monitor disk usage",
      "To create a new volume",
      "To delete unused volumes"
    ],
    "a": [
      "To request storage resources from the cluster"
    ],
    "e": "A PersistentVolumeClaim (PVC) is a request for storage by a user that binds to a PersistentVolume (PV) in the cluster. It abstracts the details of how storage is provided and allows pods to use storage resources without knowing the underlying storage implementation. PVCs do not define storage classes, monitor disk usage, create new volumes directly, or delete volumes; those tasks are handled by other Kubernetes components."
  },
  {
    "q": "What is 'Threat Modeling' in the context of security?",
    "c": [
      "A systematic process to identify and mitigate security risks",
      "A method to design software architectures",
      "A technique to improve application performance",
      "A strategy for marketing products",
      "An approach to project management"
    ],
    "a": [
      "A systematic process to identify and mitigate security risks"
    ],
    "e": "Threat Modeling is a structured approach to identifying and mitigating potential security threats. It involves analyzing systems to uncover vulnerabilities and developing strategies to address them. This process is crucial for ensuring the security and integrity of systems. The other options describe unrelated activities: software design, performance optimization, marketing, and project management."
  },
  {
    "q": "In a Kubernetes Pod manifest, which annotation is used to specify an AppArmor profile for a container named 'nginx'?",
    "c": [
      "apparmor.security.beta.kubernetes.io/nginx: 'localhost/nginx-profile'",
      "security.alpha.kubernetes.io/apparmor/nginx: 'localhost/nginx-profile'",
      "container.apparmor.security.beta.kubernetes.io/nginx: 'localhost/nginx-profile'",
      "nginx.apparmor.kubernetes.io/profile: 'localhost/nginx-profile'",
      "securityContext.apparmorProfile: 'localhost/nginx-profile'"
    ],
    "a": [
      "container.apparmor.security.beta.kubernetes.io/nginx: 'localhost/nginx-profile'"
    ],
    "e": "The correct annotation format to specify an AppArmor profile for a container named 'nginx' is 'container.apparmor.security.beta.kubernetes.io/nginx: \"localhost/nginx-profile\"'. This annotation applies the profile to the specific container. Other options are either incorrect prefixes, deprecated, or invalid Kubernetes annotation keys."
  },
  {
    "q": "What is the primary effect of sharing the PID namespace between two Docker containers?",
    "c": [
      "They share the same network interfaces",
      "They can see and signal each other's processes",
      "They share the same filesystem",
      "They can access each other's environment variables",
      "They share the same memory space"
    ],
    "a": [
      "They can see and signal each other's processes"
    ],
    "e": "Sharing the PID namespace allows containers to see and interact with each other's processes. This means they can send signals to processes running in the other container."
  },
  {
    "q": "Which kubectl command correctly creates a TLS secret named 'tls-secret' using the certificate file 'tls.crt' and the key file 'tls.key'?",
    "c": [
      "kubectl create secret generic tls-secret --from-file=tls.crt --from-file=tls.key",
      "kubectl create secret tls tls-secret --cert=tls.crt --key=tls.key",
      "kubectl create secret docker-registry tls-secret --docker-server=tls.crt --docker-username=tls.key",
      "kubectl create tls-secret tls-secret --cert=tls.crt --key=tls.key",
      "kubectl create secret tls-secret --type=tls --cert=tls.crt --key=tls.key"
    ],
    "a": [
      "kubectl create secret tls tls-secret --cert=tls.crt --key=tls.key"
    ],
    "e": "The correct command to create a TLS secret in Kubernetes is 'kubectl create secret tls' followed by the secret name and the paths to the certificate and key files using the --cert and --key flags."
  },
  {
    "q": "Which Kubernetes or related object defines how to build and deploy an application from source code?",
    "c": [
      "BuildConfig (OpenShift)",
      "Dockerfile",
      "Helm Chart",
      "ConfigMap"      
    ],
    "a": [
      "BuildConfig (OpenShift)"
    ],
    "e": "While Kubernetes itself does not have a native object for building applications from source code, OpenShift uses the 'BuildConfig' object for this purpose. It defines how to build and deploy applications from source code into containers."
  },
  {
    "q": "Which Kubernetes object is specifically designed to store sensitive information such as passwords, tokens, or keys?",
    "c": [
      "ConfigMap",
      "Secret",
      "Volume",
      "Pod Annotation",
      "Deployment"
    ],
    "a": [
      "Secret"
    ],
    "e": "Kubernetes Secrets are intended to store sensitive data like passwords, OAuth tokens, and SSH keys securely. Unlike ConfigMaps, which store non-sensitive configuration data, Secrets provide mechanisms to protect this sensitive information, including base64 encoding and integration with encryption at rest. Volumes, Pod Annotations, and Deployments are not designed for securely storing sensitive data."
  },
  {
    "q": "Which of the following practices help prevent container breakout vulnerabilities? (Select all that apply)",
    "c": [
      "Running containers with root privileges",
      "Using minimal base images to reduce attack surface",
      "Applying the principle of least privilege to container permissions",
      "Disabling security modules like SELinux or AppArmor",
      "Regularly updating container runtimes and dependencies"
    ],
    "a": [
      "Using minimal base images to reduce attack surface",
      "Applying the principle of least privilege to container permissions",
      "Regularly updating container runtimes and dependencies"
    ],
    "e": "Preventing container breakouts involves minimizing the attack surface and restricting privileges. Using minimal base images reduces unnecessary software that could be exploited. Applying the principle of least privilege limits container capabilities to only what is necessary, reducing risk. Regularly updating container runtimes ensures known vulnerabilities are patched. Conversely, running containers as root increases risk, and disabling security modules like SELinux or AppArmor removes important security layers, increasing breakout potential."
  },
  {
    "q": "How do multistage builds in Docker reduce image size?",
    "c": [
      "By running multiple containers within a single image",
      "By creating images compatible with multiple architectures",
      "By separating build-time dependencies from runtime components in different stages",
      "By enabling parallel builds across multiple stages",
      "By deploying to multiple environments simultaneously"
    ],
    "a": [
      "By separating build-time dependencies from runtime components in different stages"
    ],
    "e": "Multistage builds in Docker allow developers to separate build-time dependencies (e.g., compilers, libraries) from runtime components by using multiple `FROM` instructions in a single Dockerfile. This ensures that only the necessary artifacts (e.g., binaries) are included in the final image, significantly reducing its size and improving security. While multistage builds can simplify workflows, they do not inherently enable parallel builds or support multi-environment deployments."
  },
  {
    "q": "What is the primary function of a DaemonSet in Kubernetes?",
    "c": [
      "A pod runs on all nodes or a subset of nodes",
      "Only one pod runs in the cluster",
      "Pods are automatically scaled based on load",
      "Services are exposed externally",
      "ConfigMaps are synchronized across namespaces"
    ],
    "a": [
      "A pod runs on all nodes or a subset of nodes"
    ],
    "e": "DaemonSets ensure that a copy of a pod runs on each node or a subset of nodes in a Kubernetes cluster. This is useful for running system daemons or monitoring agents."
  },
  {
    "q": "If a user is granted the 'cluster-admin' ClusterRole through a RoleBinding, what level of access will they have?",
    "c": [
      "Full administrative privileges limited to the namespace where the RoleBinding is applied",
      "Full cluster-wide administrative privileges",
      "Read-only access to all resources in the cluster",
      "No permissions; ClusterRoles require ClusterRoleBindings to take effect",
      "Access only to service accounts within the namespace"
    ],
    "a": [
      "Full administrative privileges limited to the namespace where the RoleBinding is applied"
    ],
    "e": "When a ClusterRole, such as 'cluster-admin', is assigned using a RoleBinding, it grants full administrative privileges but only within the namespace where the RoleBinding is applied. This is because RoleBindings are namespace-scoped, meaning they cannot grant cluster-wide permissions even if the associated role is a ClusterRole. To grant cluster-wide permissions, a ClusterRoleBinding must be used. Incorrect options: (1) Full cluster-wide privileges require a ClusterRoleBinding, not a RoleBinding. (2) Read-only access is not tied to this scenario. (3) The statement about 'no permissions' is incorrect because RoleBindings do apply within their namespace. (4) Access to service accounts is not exclusive in this context."
  },
  {
    "q": "Which of the following are valid components of a Kubernetes audit policy? (Select all that apply)",
    "c": [
      "Rules",
      "Levels",
      "Stages",
      "Users",
      "Verbs"
    ],
    "a": [
      "Rules",
      "Stages",
      "Users",
      "Verbs"
    ],
    "e": "A Kubernetes audit policy is composed of 'Rules' that define what events to capture. Each rule can specify 'Stages' of the request lifecycle (such as RequestReceived, ResponseStarted). 'Users' can be specified to filter audit events by user identity. 'Verbs' define the types of API operations (e.g., get, create) to audit. 'Levels' is not a component of the policy structure but rather a field inside rules specifying the detail level of logging (e.g., None, Metadata)."
  },
  {
    "q": "What is the primary function of a ReplicaSet in Kubernetes?",
    "c": [
      "To ensure that a specified number of pod replicas are running at all times",
      "To expose services to external traffic using load balancing",
      "To store persistent data for applications",
      "To define and enforce network policies for pods",
      "To schedule pods to specific nodes based on resource requirements"
    ],
    "a": [
      "To ensure that a specified number of pod replicas are running at all times"
    ],
    "e": "A ReplicaSet in Kubernetes ensures that a specified number of pod replicas are running at all times. It monitors existing pods and creates or deletes them as needed to maintain the desired state. Incorrect options: (1) Exposing services to external traffic is handled by Services, not ReplicaSets. (2) Persistent data storage is managed by PersistentVolumes and PersistentVolumeClaims. (3) Network policies are defined separately using NetworkPolicy resources. (4) Scheduling pods to specific nodes is handled by the Kubernetes Scheduler."
  },
  {
    "q": "What types of data are stored inside the etcd key-value store in a Kubernetes cluster? (Select all that apply)",
    "c": [
      "Kubernetes cluster state",
      "Persistent application data",
      "Pod logs",
      "Secrets and ConfigMaps",
      "Container images"
    ],
    "a": [
      "Kubernetes cluster state",
      "Secrets and ConfigMaps"
    ],
    "e": "etcd stores the entire Kubernetes cluster state, including resource objects such as Secrets and ConfigMaps. It does not store persistent application data (which is stored in volumes), pod logs (which are stored on nodes or centralized logging systems), or container images (stored in container registries)."
  },
  {
    "q": "What is the role of the 'namespaceSelector' field in a Kubernetes NetworkPolicy?",
    "c": [
      "To select namespaces where the policy is applied",
      "To select Pods in specific namespaces for ingress or egress rules",
      "To label namespaces",
      "To deny traffic to certain namespaces",
      "To enforce policies across all namespaces"
    ],
    "a": [
      "To select Pods in specific namespaces for ingress or egress rules"
    ],
    "e": "The 'namespaceSelector' in a NetworkPolicy is used to select Pods in specific namespaces as sources or destinations for ingress or egress traffic rules. It does not select the namespaces where the policy itself is applied; NetworkPolicies are always applied within the namespace they are defined. It also does not label namespaces, deny traffic directly, or enforce policies cluster-wide."
  },
  {
    "q": "Which of the following securityContext fields are commonly applied at the Pod level in Kubernetes? (Select all that apply)",
    "c": [
      "runAsUser",
      "fsGroup",
      "privileged",
      "capabilities",
      "seLinuxOptions"
    ],
    "a": [
      "runAsUser",
      "fsGroup",
      "seLinuxOptions"
    ],
    "e": "At the Pod level, 'runAsUser' specifies the user ID for all containers in the Pod, 'fsGroup' sets the group ID for mounted volumes, and 'seLinuxOptions' configures SELinux labels for the Pod. 'privileged' and 'capabilities' are container-level settings and cannot be set at the Pod level. Therefore, only 'runAsUser', 'fsGroup', and 'seLinuxOptions' are valid Pod-level securityContext fields."
  },
  {
    "q": "In threat modeling using Data Flow Diagrams (DFDs), what key aspects of a system are primarily visualized?",
    "c": [
      "Financial transaction records across global markets",
      "Network latency metrics in high-availability clusters",
      "Entry points, exit points, data flows, and potential threat vectors within the system",
      "Container orchestration for microservices deployment",
      "Source code management for Git-based repositories"
    ],
    "a": [
      "Entry points, exit points, data flows, and potential threat vectors within the system"
    ],
    "e": "Data Flow Diagrams (DFDs) are used in threat modeling to visually represent how data moves through a system, highlighting entry and exit points, data stores, processes, and trust boundaries. This visualization helps identify where threats could occur. The other options describe unrelated concepts such as financial data, network performance, container orchestration, or source code management, which are not the focus of DFDs in threat modeling."
  },
  {
    "q": "What is the recommended method to rotate TLS certificates in a Kubernetes cluster managed by kubeadm?",
    "c": [
      "Manually delete and recreate certificates",
      "Use the 'kubeadm certs renew' command to renew certificates",
      "TLS certificates cannot be rotated once issued",
      "Restart the kubelet service to refresh certificates",
      "Use a third-party certificate manager exclusively"
    ],
    "a": [
      "Use the 'kubeadm certs renew' command to renew certificates"
    ],
    "e": "Kubernetes clusters initialized with kubeadm provide the 'kubeadm certs renew' command to safely renew TLS certificates without manual deletion. Manually deleting certificates or restarting kubelet alone is not sufficient and can cause downtime. While third-party certificate managers can be used, kubeadm's built-in commands are the recommended approach for certificate rotation."
  },
  {
    "q": "Which Kubernetes object is used to persist data across the lifecycle of a pod?",
    "c": [
      "PersistentVolume",
      "ConfigMap",
      "Secret",
      "PersistentVolumeClaim",
      "EmptyDir"
    ],
    "a": [
      "PersistentVolume"
    ],
    "e": "A PersistentVolume (PV) is a Kubernetes resource that provides persistent storage for data that needs to be preserved across pod lifecycles. Unlike data stored in an EmptyDir or other ephemeral storage, data in a PersistentVolume remains available even if the pod is deleted or recreated. PersistentVolumeClaims (PVCs) are used to request storage resources from PersistentVolumes, but the PV itself is the resource that holds the data."
  },
  {
    "q": "Which command is used to apply a label to a pod in Kubernetes?",
    "c": [
      "kubectl label pods <pod-name> key=value",
      "kubectl annotate pods <pod-name> key=value",
      "kubectl tag pods <pod-name> key=value",
      "kubectl set label pods <pod-name> key=value",
      "kubectl edit pods <pod-name> --label key=value"
    ],
    "a": [
      "kubectl label pods <pod-name> key=value"
    ],
    "e": "The command `kubectl label pods <pod-name> key=value` is used to apply a label to a pod. This command updates the metadata of the pod with the specified key-value pair, allowing for easier management and filtering of resources."
  },
  {
    "q": "Which of the following actions can improve the security of the Kubernetes kubelet? (Select all that apply)",
    "c": [
      "Enable authentication and authorization on the kubelet API",
      "Disable anonymous access to the kubelet",
      "Expose the kubelet read-only port to all network interfaces",
      "Use TLS certificates for kubelet communication",
      "Run the kubelet process in privileged mode"
    ],
    "a": [
      "Enable authentication and authorization on the kubelet API",
      "Disable anonymous access to the kubelet",
      "Use TLS certificates for kubelet communication"
    ],
    "e": "Improving kubelet security involves enabling authentication and authorization to ensure only authorized users can access the API, disabling anonymous access to prevent unauthenticated requests, and using TLS certificates to encrypt communication between components. Exposing the read-only port publicly increases attack surface and is discouraged. Running kubelet in privileged mode is not a security best practice and can increase risk."
  },
  {
    "q": "What is the impact on a Kubernetes cluster if the kube-proxy component enters a 'CrashLoopBackOff' state?",
    "c": [
      "Pods will not be scheduled on any nodes",
      "Network traffic between services may be disrupted or fail",
      "The entire Kubernetes cluster will shut down",
      "The kubelet service on nodes will stop functioning",
      "Access to Kubernetes Secrets will be blocked"
    ],
    "a": [
      "Network traffic between services may be disrupted or fail"
    ],
    "e": "kube-proxy manages network rules on each node to enable service communication and load balancing. If kube-proxy crashes repeatedly (CrashLoopBackOff), network traffic between services can be disrupted, causing failures in service discovery and connectivity. However, pod scheduling, kubelet operation, cluster availability, and secret access are not directly affected by kube-proxy failures."
  },
  {
    "q": "What is the primary purpose of signing container images in a cloud-native environment?",
    "c": [
      "To reduce the image size for deployment",
      "To verify the image's integrity and authenticity",
      "To include metadata for deployment automation",
      "To enforce runtime security policies",
      "To speed up image pulling during deployment"
    ],
    "a": [
      "To verify the image's integrity and authenticity"
    ],
    "e": "The primary purpose of image signing is to ensure that a container image originates from a trusted source and has not been tampered with. This process involves cryptographically signing the image, allowing users to verify its integrity and authenticity before use. Incorrect options such as reducing image size or speeding up deployment do not relate to the security function of signing. Similarly, metadata inclusion and runtime policy enforcement are separate mechanisms unrelated to image signing."
  },
  {
    "q": "How does Kubernetes ensure that a Deployment maintains the desired number of replicas?",
    "c": [
      "Through the kube-scheduler",
      "Using the ReplicaSet controller",
      "Via the kubelet on each node",
      "By the API server checking periodically",
      "It does not ensure this automatically"
    ],
    "a": [
      "Using the ReplicaSet controller"
    ],
    "e": "Kubernetes Deployments use ReplicaSets to ensure that the desired number of pod replicas is maintained. ReplicaSets automatically adjust the number of replicas if any discrepancies are detected."
  },
  {
    "q": "Which kubectl command provides detailed information about a specific Kubernetes resource, including its configuration and status?",
    "c": [
      "kubectl get <resource>",
      "kubectl describe <resource>",
      "kubectl inspect <resource>",
      "kubectl show <resource>",
      "kubectl info <resource>"
    ],
    "a": [
      "kubectl describe <resource>"
    ],
    "e": "The 'kubectl describe <resource>' command outputs detailed information about a Kubernetes resource, including its configuration, status, events, and other metadata. In contrast, 'kubectl get <resource>' provides a summary list or status of resources, but not detailed information. The other commands such as 'inspect', 'show', and 'info' are not valid kubectl commands for this purpose."
  },
  {
    "q": "What is the correct command to base64-encode the string 'admin' for Kubernetes Secret creation, including proper newline handling?",
    "c": [
      "echo -n 'admin' | base64",
      "echo 'admin' | base64",
      "base64 admin",
      "echo -n 'admin' | base64 -d"
    ],
    "a": [
      "echo -n 'admin' | base64"
    ],
    "e": "The '-n' flag prevents adding a trailing newline character, which is critical for accurate encoding. Kubernetes Secrets require precise base64 encoding without unexpected characters. The resulting output can be used in Secret manifests' data field."
  },
  {
    "q": "In Kubernetes, what is the purpose of the Pod Security Standards?",
    "c": [
      "A deprecated feature replaced by PodSecurityPolicy",
      "A set of built-in policies that enforce best practices for pod security",
      "A configuration for network policies",
      "A type of storage class for pods",
      "An admission controller for scheduling pods"
    ],
    "a": [
      "A set of built-in policies that enforce best practices for pod security"
    ],
    "e": "Pod Security Standards (PSS) are predefined policy levels provided by Kubernetes to enforce security best practices for pods. They replace the deprecated PodSecurityPolicy and provide three levelsâ€”Privileged, Baseline, and Restrictedâ€”to control pod permissions and capabilities. They are not related to network policies, storage classes, or pod scheduling admission controllers."
  },
  {
    "q": "What happens when you set 'terminationGracePeriodSeconds' to zero in a Kubernetes pod spec?",
    "c": [
      "The pod will terminate immediately without a graceful shutdown",
      "The pod will never terminate",
      "The pod will have infinite time to terminate",
      "The setting is ignored by Kubernetes",
      "The pod will terminate after 30 seconds"
    ],
    "a": [
      "The pod will terminate immediately without a graceful shutdown"
    ],
    "e": "Setting 'terminationGracePeriodSeconds' to zero forces the pod to terminate immediately without a graceful shutdown. This means any running processes will be forcefully stopped, which can lead to data corruption or other issues if not handled properly."
  },
  {
    "q": "Does setting 'privileged: true' on a Kubernetes pod grant it access to Kubernetes Secrets?",
    "c": [
      "Yes, it grants full access to all Secrets in the cluster",
      "No, it only elevates the pod's privileges on the host system but does not affect Secrets access",
      "Yes, but only to Secrets within the same namespace",
      "No, it explicitly prevents access to Secrets",
      "Access depends solely on RBAC permissions, regardless of privileged mode"
    ],
    "a": [
      "No, it only elevates the pod's privileges on the host system but does not affect Secrets access"
    ],
    "e": "Setting 'privileged: true' on a pod grants the container elevated privileges on the host system, such as access to devices and kernel capabilities, but it does not inherently grant access to Kubernetes Secrets. Access to Secrets is controlled by Kubernetes Role-Based Access Control (RBAC) policies and namespace scoping."
  }
]