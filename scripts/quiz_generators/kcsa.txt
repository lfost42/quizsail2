Which Kubernetes resource provides layer 7 (HTTP/HTTPS) routing rules for external access to cluster services while enabling path-based and host-based routing?
Ingress
Service
Endpoint
NetworkPolicy
LoadBalancer
Correct answer:Ingress
Explanation:Ingress resources define HTTP/HTTPS routing rules and integrate with Ingress controllers to expose services. Services (ClusterIP, NodePort, LoadBalancer) operate at layer 4, while NetworkPolicy controls network traffic flow. LoadBalancer is a Service type, not a separate resource.

Which kube-apiserver flag must be configured to disable anonymous authentication and prevent unauthenticated requests to the Kubernetes API?
--disable-anonymous-auth
--anonymous-auth=false
--enable-auth=false
--no-anonymous
--deny-anonymous
Correct answer:--anonymous-auth=false
Explanation:The '--anonymous-auth=false' flag explicitly disables anonymous requests to the API server, forcing authentication for all requests. This is critical for production clusters to prevent unauthorized access. The other options are either non-existent flags or use incorrect syntax for authentication configuration.

What is the primary benefit of applying the CIS Kubernetes Benchmark to production clusters?
It guarantees zero downtime for all microservices
It provides prescriptive security hardening recommendations to enhance cluster security and compliance
It enforces a rolling-update deployment strategy by default
It automatically encrypts data for stateful workloads
It replaces manual container orchestration with serverless functions
Correct answer:It provides prescriptive security hardening recommendations to enhance cluster security and compliance
Explanation:The CIS Kubernetes Benchmark offers detailed, prescriptive guidelines and best practices for securing Kubernetes clusters. Applying these recommendations helps organizations harden their production environments against security threats and meet compliance requirements. The benchmark does not guarantee zero downtime, enforce deployment strategies, provide automatic encryption, or replace orchestration with serverless functions.


What is the primary purpose of Open Policy Agent (OPA) Gatekeeper in Kubernetes?
To manage node scaling based on CPU usage
To provide an integrated container registry
To enforce policy-as-code by validating configurations during admission
To offer a threat feed for container vulnerabilities
To install an alternative container runtime in Kubernetes
Correct answer:To enforce policy-as-code by validating configurations during admission
Explanation:OPA Gatekeeper is a validating admission controller that enforces policies defined as code during resource creation or updates in Kubernetes. It ensures compliance by preventing non-compliant resources from being admitted to the cluster. Incorrect options, such as managing node scaling or providing a container registry, are unrelated to OPA Gatekeeper's functionality. Similarly, it does not handle threat feeds or runtime installation.


Which Kubernetes component is responsible for persisting the cluster's state?
kube-scheduler
etcd
kube-controller-manager
kube-proxy
kubelet
Correct answer:etcd
Explanation:etcd is a distributed key-value store that persists the Kubernetes cluster's state. It ensures that the cluster's configuration and data are consistent across all nodes.


In managed Kubernetes services (e.g., EKS, GKE, AKS), who is responsible for managing the etcd cluster?
The user manages etcd directly
The cloud provider manages etcd
etcd is not used in managed services
A third-party vendor manages etcd
The Kubernetes community manages etcd
Correct answer:The cloud provider manages etcd
Explanation:In managed Kubernetes services, the cloud provider is responsible for managing the etcd cluster, including backups, scaling, and availability. Users do not manage etcd directly. etcd is a core component of Kubernetes and is always used, but its management is abstracted away in managed services. The Kubernetes community develops etcd but does not manage individual clusters.


Which of the following controllers are included in the Kubernetes kube-controller-manager? (Select all that apply)
Node Controller
ReplicaSet Controller
Ingress Controller
Cloud Controller Manager
Service Account Controller
Correct answer:Node Controller, ReplicaSet Controller, Service Account Controller
Explanation:The kube-controller-manager runs several core controllers including the Node Controller, which manages node status; the ReplicaSet Controller, which ensures the desired number of pod replicas; and the Service Account Controller, which manages service account tokens. The Ingress Controller is typically deployed separately as an add-on and is not part of the kube-controller-manager. The Cloud Controller Manager is a separate component responsible for cloud-specific control loops and is not included in the kube-controller-manager.


Why would you disable automounting of ServiceAccount tokens in a Kubernetes Pod?
To reduce memory usage of the Pod
To prevent the Pod from having unnecessary or unauthorized access to the Kubernetes API
To improve the application's runtime performance
To enable network policies enforcement
To allow the Pod to use multiple ServiceAccounts simultaneously
Correct answer:To prevent the Pod from having unnecessary or unauthorized access to the Kubernetes API
Explanation:Disabling automounting of ServiceAccount tokens prevents the Pod from automatically receiving credentials that grant access to the Kubernetes API. This reduces the attack surface by limiting the Pod's ability to interact with the cluster unless explicitly required. The other options are incorrect because automounting tokens does not significantly affect memory usage or application performance, does not directly enable network policies, and Pods cannot use multiple ServiceAccounts simultaneously.


Which Kubernetes resource is commonly used to integrate Open Policy Agent (OPA) for policy enforcement through admission control?
ValidatingWebhookConfiguration
MutatingWebhookConfiguration
AdmissionController
CustomResourceDefinition
PolicyController
Correct answer:ValidatingWebhookConfiguration
Explanation:The 'ValidatingWebhookConfiguration' resource is used to register admission webhooks that validate requests to the Kubernetes API server. Open Policy Agent (OPA) leverages this mechanism to enforce custom policies by intercepting and validating API requests. 'MutatingWebhookConfiguration' is used for modifying requests, 'AdmissionController' is a general concept, 'CustomResourceDefinition' defines new resource types, and 'PolicyController' is not a standard Kubernetes resource.


How do you scale a Kubernetes deployment named 'my-deployment' to 5 replicas using the CLI?
kubectl scale deployment my-deployment --replicas=5
kubectl update deployment my-deployment --replicas=5
kubectl set deployment my-deployment replicas=5
kubectl resize deployment my-deployment 5
kubectl deploy my-deployment --replicas=5
Correct answer:kubectl scale deployment my-deployment --replicas=5
Explanation:The 'kubectl scale' command is used to adjust the number of replicas in a deployment. In this case, 'kubectl scale deployment my-deployment --replicas=5' will scale the deployment to 5 replicas.


How do Kubernetes Secrets provide improved security compared to ConfigMaps?
Secrets are encrypted by default in etcd
Secrets are stored in a separate database from ConfigMaps
Secrets are base64-encoded and can be encrypted at rest, whereas ConfigMaps are stored in plain text
Secrets provide built-in versioning
Secrets can only be accessed by cluster administrators
Correct answer:Secrets are base64-encoded and can be encrypted at rest, whereas ConfigMaps are stored in plain text
Explanation:Kubernetes Secrets are base64-encoded and can be configured to be encrypted at rest in etcd, providing better protection for sensitive data than ConfigMaps, which are stored as plain text in etcd. Secrets are not encrypted by default unless encryption at rest is enabled. They do not provide built-in versioning, and access controls depend on RBAC policies rather than restricting access solely to cluster admins.


What is the role of the 'cluster-admin' ClusterRole?
Read-only access to cluster resources
Admin access limited to one namespace
Full control over all resources in the cluster
Access to manage nodes but not pods
Limited to managing storage resources
Correct answer:Full control over all resources in the cluster
Explanation:The 'cluster-admin' ClusterRole grants full cluster-wide administrative permissions. When bound via a ClusterRoleBinding, it provides full control over all resources in the cluster. When bound via a RoleBinding, its permissions are limited to the namespace specified in the binding.


What is the primary purpose of Role-Based Access Control (RBAC) in Kubernetes?
To manage network policies for pods
To control user and process access to Kubernetes resources
To schedule pods efficiently across nodes
To monitor cluster performance metrics
To provide logging and audit capabilities
Correct answer:To control user and process access to Kubernetes resources
Explanation:RBAC in Kubernetes is designed to control and manage access permissions for users and processes to Kubernetes resources, ensuring that only authorized entities can perform specific actions. It does not manage network policies, scheduling, monitoring, or logging directly, although these areas may have their own mechanisms.


What critical security objectives are achieved through regular vulnerability scanning of container images in Kubernetes environments?
Optimizes container runtime performance metrics
Reduces container image layer count
Identifies and remediates known software vulnerabilities
Ensures compliance with open-source licensing
Accelerates container deployment pipelines
Correct answer:Identifies and remediates known software vulnerabilities
Explanation:Regular image scanning detects vulnerabilities in base images and dependencies, enabling remediation before deployment. This practice addresses CVE management and reduces attack surfaces, forming a crucial part of DevSecOps pipelines. Other options describe unrelated benefits: performance (option 1), licensing (option 4), and deployment speed (option 5) require different tooling and processes.


In a Kubernetes audit policy, which 'level' setting logs only metadata about requests but excludes the request and response bodies?
None
Metadata
Request
RequestResponse
Minimal
Correct answer:Metadata
Explanation:The 'Metadata' audit level records request metadata such as request method, resource, user, and timestamp but does not log the request or response bodies. 'None' disables logging. 'Request' logs the request body but not the response. 'RequestResponse' logs both request and response bodies. 'Minimal' is not a standard audit level in Kubernetes.


What is an example of 'Information Disclosure' under the STRIDE threat model?
A user deletes all records from a database
A user reads sensitive data in a database without authorization
A user denies performing a destructive action
A user overflows a buffer to gain root access
A user floods a network to make services unavailable
Correct answer:A user reads sensitive data in a database without authorization
Explanation:Information Disclosure refers to unauthorized access to sensitive data. This can occur when a user reads confidential information without proper authorization. Other options do not fit this category because they involve different types of threats: data deletion (Tampering), denial of actions (Denial of Service), privilege escalation (Elevation of Privileges), and network disruption (Denial of Service).


How do you configure a Kubernetes audit policy rule to log events for all resources within a specific namespace?
Set 'namespace: <namespace>' in the policy rule
Use 'namespaces: ["<namespace>"]' under the rule's 'namespaces' field
Add 'resourceNames: ["<namespace>"]' to the rule
Set 'level: Namespace' in the policy
Specify 'namespaceSelector: {matchNames: ["<namespace>"]}'
Correct answer:Use 'namespaces: ["<namespace>"]' under the rule's 'namespaces' field
Explanation:In Kubernetes audit policies, the 'namespaces' field in a rule specifies the namespaces to which the rule applies, allowing you to log events for all resources within those namespaces. The other options are incorrect because 'namespace' is not a valid field, 'resourceNames' filters specific resource names rather than namespaces, 'level' defines log verbosity not scope, and 'namespaceSelector' is not used in audit policies.


Which Kubernetes resource is used to enforce Pod Security Standards within a namespace?
ReplicaSet
ConfigMap
ServiceAccount
Pod Security Admission Controller
Correct answer:Pod Security Admission Controller
Explanation:The Pod Security Admission Controller is responsible for enforcing Pod Security Standards in Kubernetes. It ensures that pods comply with predefined security policies, enhancing cluster security.


Which kube-apiserver configuration flag properly enables the ImagePolicyWebhook admission controller in modern Kubernetes versions (v1.10+)?
--enable-admission-plugins=ImagePolicyWebhook
--admission-control=ImagePolicyWebhook
--admission-plugins=ImagePolicyWebhook
--enable-image-policy
--image-policy-webhook=true
Correct answer:--enable-admission-plugins=ImagePolicyWebhook
Explanation:In Kubernetes v1.10+, admission controllers are enabled using '--enable-admission-plugins'. The '--admission-control' flag was deprecated in favor of this new syntax. The ImagePolicyWebhook controller enables image verification through external webhooks, crucial for enforcing image registry policies.


What is the effect of executing the command 'kubectl drain <node-name>' on a Kubernetes node?
Deletes the node from the cluster
Marks the node as unschedulable and evicts all pods safely
Restarts the node
Upgrades the node's Kubernetes version
Cleans up unused container images on the node
Correct answer:Marks the node as unschedulable and evicts all pods safely
Explanation:'kubectl drain' prepares a node for maintenance by marking it unschedulable to prevent new pods from being scheduled and safely evicting all existing pods. It does not delete the node, restart it, upgrade Kubernetes, or clean images. This ensures workloads are gracefully moved before maintenance.


According to the CIS Kubernetes Benchmark, which setting should be disabled on the kube-apiserver for security reasons?
Anonymous authentication
RBAC authorization
TLS encryption
Admission controllers
Audit logging
Correct answer:Anonymous authentication
Explanation:Anonymous authentication should be disabled on the kube-apiserver to enhance security, as recommended by the CIS Kubernetes Benchmark. Enabling anonymous authentication allows unauthorized access to cluster resources, which is a significant security risk. Disabling it ensures that all interactions with the API server require proper authentication.


In a Kubernetes audit policy, which log level should be set to capture the full content of both requests and responses?
None
Metadata
Request
RequestResponse
Content
Correct answer:RequestResponse
Explanation:The 'RequestResponse' audit log level records both the metadata and the full content of requests and responses, providing comprehensive audit information. 'None' disables logging, 'Metadata' logs only metadata without content, 'Request' logs request content but not responses, and 'Content' is not a valid audit log level in Kubernetes.


In Kubernetes Pod specifications, which field explicitly defines the container runtime class that should be used for pod execution?
runtime
runtimeClassName
containerRuntime
runtimeClass
containerRuntimeClass
Correct answer:runtimeClassName
Explanation:The 'runtimeClassName' field in Pod specifications references a RuntimeClass object that defines container runtime configurations. This allows administrators to control runtime security parameters and isolation mechanisms. Other options like 'runtimeClass' or 'containerRuntimeClass' are invalid field names in the Kubernetes API.


Which STRIDE threat category primarily addresses threats related to data integrity?
Spoofing
Tampering
Repudiation
Information Disclosure
Denial of Service
Correct answer:Tampering
Explanation:The 'Tampering' category in STRIDE focuses on threats that compromise data integrity by unauthorized modification of data. Spoofing relates to identity, repudiation to denial of actions, information disclosure to confidentiality breaches, and denial of service to availability issues.


What is the recommended method for storing sensitive data, such as passwords or tokens, in a Kubernetes environment?
Hardcode them in application code
Store them in ConfigMaps
Use Kubernetes Secrets
Store them in environment variables
Include them in container images
Correct answer:Use Kubernetes Secrets
Explanation:Kubernetes Secrets are specifically designed to securely store sensitive data. They provide a secure way to manage and distribute sensitive information to pods, reducing the risk of data exposure compared to other methods like hardcoding or using environment variables.


What is the correct kubectl command syntax to create a Role named 'pod-reader' with get/watch/list permissions on Pods in the current namespace?
kubectl apply role
kubectl create role pod-reader --verb=get,list,watch --resource=pods
kubectl generate role
kubectl new role
kubectl init role
Correct answer:kubectl create role pod-reader --verb=get,list,watch --resource=pods
Explanation:The 'kubectl create role' command with proper flags creates RBAC Roles. The full syntax requires specifying verbs (--verb) and resources (--resource). This command creates non-namespaced Roles; for cluster-wide permissions, use 'kubectl create clusterrole' instead.


Which Kubernetes control plane component is exclusively responsible for evaluating scheduling constraints and binding Pods to appropriate worker nodes?
kube-controller-manager
kube-scheduler
kube-apiserver
kubelet
etcd
Correct answer:kube-scheduler
Explanation:The kube-scheduler evaluates Pod specifications against node resources, taints/tolerations, and affinity/anti-affinity rules to select optimal nodes. The kube-controller-manager handles node lifecycle controllers, while kubelets manage Pod execution on worker nodes.


Which kubectl command lists all resource types within a specific namespace?
kubectl get all --namespace=<namespace>
kubectl get resources --namespace=<namespace>
kubectl describe namespace <namespace>
kubectl list namespace <namespace>
kubectl get all <namespace>
Correct answer:kubectl get all --namespace=<namespace>
Explanation:The command 'kubectl get all --namespace=<namespace>' retrieves all resource types (pods, services, deployments, etc.) within the specified namespace. The other options are either invalid commands or do not list all resources. 'kubectl describe namespace' provides details about the namespace itself, not its resources.


Which command is used to remove the 'apache2' package from a Debian-based Linux system?
sudo apt-get install apache2
sudo yum remove apache2
sudo apt-get remove apache2
sudo rpm -e apache2
sudo dnf erase apache2
Correct answer:sudo apt-get remove apache2
Explanation:On Debian-based systems (such as Ubuntu), the package manager 'apt-get' is used to manage packages. The command 'sudo apt-get remove apache2' uninstalls the 'apache2' package but retains configuration files. 'sudo apt-get install apache2' installs the package. 'sudo yum remove apache2' and 'sudo dnf erase apache2' are used on Red Hat-based systems, not Debian-based. 'sudo rpm -e apache2' is also for RPM-based distributions and not applicable to Debian-based systems.


What is an effective mitigation technique for 'Information Disclosure' threats in a Kubernetes environment?
Implementing audit logging
Encrypting data at rest and in transit
Using rate limiting
Implementing CAPTCHA
Using prepared SQL statements
Correct answer:Encrypting data at rest and in transit
Explanation:Encrypting data at rest and in transit is crucial for protecting against Information Disclosure threats. This ensures that even if unauthorized access occurs, the data remains confidential and unreadable.


What is the purpose of the '--allow-privileged' flag in the Kubernetes API server configuration?
Allows pods to run privileged containers with elevated permissions
Enables unauthenticated access to the API server
Grants cluster-admin rights to all users
Disables security contexts on pods
Controls enforcement of network policies
Correct answer:Allows pods to run privileged containers with elevated permissions
Explanation:The '--allow-privileged' flag on the Kubernetes API server enables or disables the ability to create privileged containers, which have elevated permissions on the host and can perform sensitive operations. This flag does not affect authentication, user permissions, security contexts broadly, or network policy enforcement. Running privileged containers increases security risks and should be carefully controlled.


What is Kyverno's primary function in a Kubernetes environment?
A container scanning tool for malware detection
A platform for automating cost optimizations
An admission controller that enables writing and enforcing policies as Kubernetes resources
An event streaming system for logs
A vulnerability database maintained by CIS
Correct answer:An admission controller that enables writing and enforcing policies as Kubernetes resources
Explanation:Kyverno is a Kubernetes-native policy engine that functions as an admission controller. It allows administrators to define, validate, and enforce policies using Kubernetes Custom Resource Definitions (CRDs), making policy management declarative and integrated into the Kubernetes API. It is not a container scanning tool, cost optimization platform, log streaming system, or a vulnerability database. Its design simplifies policy enforcement without requiring external policy languages or frameworks.


Upon identifying a vulnerable Docker image in your Kubernetes cluster, what is the recommended immediate action to mitigate the risk?
Ignore the vulnerability
Update the image tag to 'latest'
Delete the pod using the vulnerable image
Restart the Kubernetes cluster
Rebuild the image without changes
Correct answer:Delete the pod using the vulnerable image
Explanation:The recommended immediate action is to delete the pod running the vulnerable image. This action helps mitigate the risk by removing the vulnerable container from your environment.


How do you create a Secret from literal values in Kubernetes?
kubectl create secret generic my-secret --from-literal=key1=value1
kubectl create secret generic my-secret key1=value1
kubectl create secret my-secret --literal key1=value1
kubectl create secret tls my-secret --key1 value1
kubectl secret create my-secret key1=value1
Correct answer:kubectl create secret generic my-secret --from-literal=key1=value1
Explanation:To create a Secret from literal values, you use the command `kubectl create secret generic my-secret --from-literal=key1=value1`. This command allows you to define key-value pairs directly in the command line, which are then stored as a Secret in Kubernetes.


Which kubectl command is used to delete a deployment named 'my-app' in Kubernetes?
kubectl remove deployment my-app
kubectl delete deployment my-app
kubectl destroy deployment my-app
kubectl erase deployment my-app
kubectl terminate deployment my-app
Correct answer:kubectl delete deployment my-app
Explanation:The correct command to delete a deployment in Kubernetes is 'kubectl delete deployment my-app'. This command removes the deployment resource and all associated pods. The other options are incorrect as they are not valid kubectl commands for deleting resources.


Which methodology involves visualizing application components and interactions to identify potential security threats?
Scrum methodology
Data Flow Diagram (DFD) approach
Waterfall model
Incident Response Cycle
Serverless microservices design
Correct answer:Data Flow Diagram (DFD) approach
Explanation:The Data Flow Diagram (DFD) approach is a visual representation technique used to map out data paths and interactions within systems, facilitating the identification and mitigation of security threats.


What is the main function of the kubelet in a Kubernetes node?
Managing pod networking
Running containers on each node
Storing cluster configuration
Scheduling pods to nodes
Managing the control plane
Correct answer:Running containers on each node
Explanation:The kubelet is responsible for running and managing containers on each node in a Kubernetes cluster. It ensures that the pods are running as expected and reports back to the control plane.


How do you label a Kubernetes node with the key 'env' and value 'production'?
kubectl label node <node-name> env:production
kubectl label nodes <node-name> env=production
kubectl annotate node <node-name> env=production
kubectl set label node <node-name> env=production
kubectl tag node <node-name> env=production
Correct answer:kubectl label nodes <node-name> env=production
Explanation:To label a Kubernetes node with the key 'env' and value 'production', you use the command `kubectl label nodes <node-name> env=production`. This command adds a label to the specified node, which can be used for filtering or selecting nodes for specific tasks.


Which statement best describes the role of container scanning tools like Aqua Security or Clair?
They manage multi-cluster ingress controllers
They automate vulnerability detection in container images, typically before deployment
They provide a database of open-source container licenses
They specialize in high-availability cluster provisioning
They replace Kubernetesâ€™ default scheduler
Correct answer:They automate vulnerability detection in container images, typically before deployment
Explanation:Container scanning tools such as Aqua Security and Clair analyze container images to identify known security vulnerabilities before these images are deployed. This process is a critical part of securing the container supply chain. They do not manage ingress controllers, provide license databases, handle cluster provisioning, or replace Kubernetes schedulers. Their focus is on vulnerability assessment to prevent deploying insecure containers.


What command is used to update an image in a Kubernetes deployment?
kubectl set image deployment/my-deployment my-container=my-image:tag
kubectl update image deployment/my-deployment my-container=my-image:tag
kubectl replace image deployment/my-deployment my-container=my-image:tag
kubectl change image deployment/my-deployment my-container=my-image:tag
kubectl edit deployment my-deployment
Correct answer:kubectl set image deployment/my-deployment my-container=my-image:tag
Explanation:The `kubectl set image` command is used to update the image for a specified container in a Kubernetes deployment. This command modifies the deployment configuration to use the new image, which triggers a rollout of the updated pods.


How do you enable Pod Security Admission (PSA) in a Kubernetes cluster?
Install the PSA plugin via kubectl
Add 'PodSecurity' to the '--enable-admission-plugins' flag in the API server
Apply a custom resource definition for PSA
Use a third-party tool to enforce PSA
Enable it in the kubelet configuration
Correct answer:Add 'PodSecurity' to the '--enable-admission-plugins' flag in the API server
Explanation:To enable Pod Security Admission (PSA), you need to add 'PodSecurity' to the '--enable-admission-plugins' flag when starting the API server. This ensures that the PodSecurity admission controller is active and enforcing pod security standards.


What is the primary role of the kube-proxy component in Kubernetes?
Managing network policies
Providing service discovery and routing
Scheduling pods to nodes
Storing cluster state
Monitoring node health
Correct answer:Providing service discovery and routing
Explanation:kube-proxy is responsible for maintaining network rules on each node to ensure service discovery and routing. It does not manage network policies or schedule pods.


Which kubectl command provides detailed information about a specific Kubernetes node, including its status, capacity, and allocated resources?
kubectl get node <node-name>
kubectl describe node <node-name>
kubectl inspect node <node-name>
kubectl info node <node-name>
kubectl logs node <node-name>
Correct answer:kubectl describe node <node-name>
Explanation:The command 'kubectl describe node <node-name>' shows detailed information about the node, such as labels, annotations, resource capacity, allocated resources, conditions, and events. 'kubectl get node' provides a summary list of nodes but not detailed info. 'kubectl inspect' and 'kubectl info' are not valid kubectl commands for nodes. 'kubectl logs' is used for retrieving logs from pods, not nodes.


Which Kubernetes pod specification field prevents automatic mounting of the default ServiceAccount token?
mountServiceAccountToken: false
automountServiceAccountToken: false
serviceAccountToken: disabled
disableServiceAccountMount: true
serviceAccountMountPolicy: none
Correct answer:automountServiceAccountToken: false
Explanation:automountServiceAccountToken: false in the pod spec prevents automatic mounting of the service account token, reducing attack surface. This security hardening measure is recommended when pods don't need Kubernetes API access, as noted in the Kubernetes service account documentation and security best practices guides.


Is there a Kubernetes object specifically designed to limit the number of concurrent requests to the API server?
ResourceQuota
LimitRange
PodDisruptionBudget
PriorityClass
There is no such object
Correct answer:There is no such object
Explanation:Kubernetes does not have an object specifically for limiting concurrent API server requests. Instead, this is typically controlled through API server configuration flags.


What is a common use case for a Kubernetes CronJob?
Running a database
Serving web traffic
Scheduling regular, recurring tasks
Managing network policies
Providing persistent storage
Correct answer:Scheduling regular, recurring tasks
Explanation:Kubernetes CronJobs are designed to schedule and run Jobs at specified times or intervals, similar to cron jobs in Unix-like systems. They are ideal for automating repetitive tasks such as backups, report generation, or periodic maintenance. Other options like running a database, serving web traffic, managing network policies, or providing persistent storage are outside the scope of CronJobs' functionality.


What is the primary function of the Kubernetes 'LimitRange' resource?
To limit the number of namespaces
To set default resource requests and limits for pods in a namespace
To restrict network access between pods
To control access to the Kubernetes API
To define storage classes
Correct answer:To set default resource requests and limits for pods in a namespace
Explanation:A LimitRange in Kubernetes is used to enforce constraints on resource usage within a namespace. It sets default resource requests and limits for pods, ensuring that they do not exceed specified thresholds. This helps in preventing resource over-allocation and maintaining cluster stability.


What components are necessary to verify the integrity and authenticity of a container image?
A checksum and the image manifest
A digital signature, public key, and verification tool
The Dockerfile used to build the image
Access to the container registry logs
The image's pull secret
Correct answer:A digital signature, public key, and verification tool
Explanation:To verify the integrity and authenticity of a container image, you need a digital signature, a public key to verify the signature, and a verification tool. This ensures that the image has not been tampered with and comes from a trusted source.


How do you delete a Kubernetes namespace and all its associated resources?
kubectl delete all --namespace=<namespace>
kubectl delete namespace <namespace>
kubectl remove namespace <namespace>
kubectl clean namespace <namespace>
kubectl purge namespace <namespace>
Correct answer:kubectl delete namespace <namespace>
Explanation:Deleting a namespace with `kubectl delete namespace <namespace>` removes the namespace and all resources within it. This includes pods, services, deployments, and other objects defined within that namespace.


Which of the following are Kubernetes security best practices to follow during the Deploy phase? (Select all that apply)
Implement network policies
Run containers as root
Use image tags like 'latest'
Use the ImagePolicyWebhook admission controller
Apply security contexts to pods and containers
Correct answer:Implement network policies, Use the ImagePolicyWebhook admission controller, Apply security contexts to pods and containers
Explanation:During deployment, implementing network policies restricts pod communication to only necessary traffic, reducing attack surfaces. The ImagePolicyWebhook admission controller enforces image security policies to prevent untrusted images from running. Applying security contexts defines permissions and restrictions for pods and containers, enhancing security. Running containers as root and using mutable tags like 'latest' are discouraged as they increase security risks and reduce traceability.


When implementing Kubernetes NetworkPolicies, what security implication should administrators consider when using an empty podSelector field?
Restricts Access to Only Specific Pods
Only Applies to Ingress Traffic
Enhances Network Security by Default
Applies the policy to all pods in the specified namespace
Correct answer:Applies the policy to all pods in the specified namespace
Explanation:An empty podSelector in a NetworkPolicy selects all pods in the namespace, meaning the policy applies to all pods in that namespace. The effect on traffic depends on the policy's ingress and egress rules; it does not by itself create a default-allow or default-deny behavior. Administrators should carefully design policies with empty podSelectors to avoid unintended broad application. Other options misrepresent NetworkPolicy mechanics: validation errors (option 3) do not occur due to empty selectors, scope is not limited to new pods (option 4), and cross-namespace communication (option 5) requires explicit policy rules.


How can you update the container image of a Kubernetes deployment without modifying other deployment configurations?
Manually edit the deployment YAML file and apply changes
Delete the existing deployment and recreate it with the new image
Use the 'kubectl set image' command to update the image
Scale the deployment down to zero replicas, update the image, then scale back up
Update the image directly in the container registry
Correct answer:Use the 'kubectl set image' command to update the image
Explanation:The 'kubectl set image' command allows you to update the container image of a deployment directly without changing other configuration parameters. This command triggers a rolling update, ensuring minimal downtime. Manually editing the YAML is error-prone and may unintentionally alter other settings. Deleting and recreating the deployment causes downtime and loss of state. Scaling down to zero is unnecessary and disruptive. Updating the image in the container registry alone does not affect running deployments.


Why is it recommended to use image digests instead of tags in Kubernetes manifests?
Digests are shorter than tags
Tags can be mutable, but digests ensure image immutability
Using digests is required by Kubernetes
Tags are not supported in private registries
Digests allow for automatic updates
Correct answer:Tags can be mutable, but digests ensure image immutability
Explanation:Image digests are recommended because they refer to a specific, immutable version of an image. This ensures consistency and predictability in deployments, unlike mutable tags.


What security risk is associated with mounting the Docker socket ('/var/run/docker.sock') into a container?
No risk; it's a common practice
The container can control the Docker daemon and other containers
It improves container performance
It provides secure access to host resources
It isolates the container from the host
Correct answer:The container can control the Docker daemon and other containers
Explanation:Mounting the Docker socket into a container allows the container to control the host's Docker daemon, potentially leading to unauthorized access or manipulation of other containers and host resources. This practice should be avoided unless absolutely necessary and properly secured.


Which of the following are best practices for securing etcd in a Kubernetes cluster? (Select all that apply)
Enable TLS encryption for all communication with etcd
Limit access to etcd endpoints to trusted networks only
Use authentication and authorization mechanisms for etcd access
Expose etcd endpoints publicly to facilitate monitoring
Store etcd backups in a secure and access-controlled location
Correct answer:Enable TLS encryption for all communication with etcd, Limit access to etcd endpoints to trusted networks only, Use authentication and authorization mechanisms for etcd access, Store etcd backups in a secure and access-controlled location
Explanation:Securing etcd is critical as it stores the cluster state and sensitive data. Best practices include enabling TLS encryption to protect data in transit, restricting access to trusted networks to prevent unauthorized access, implementing authentication and authorization to control who can access etcd, and securely storing backups to prevent data loss or compromise. Exposing etcd endpoints publicly is strongly discouraged as it poses a significant security risk.


Which built-in Kubernetes authentication method is generally not recommended for production environments?
Static Token File
OpenID Connect (OIDC)
Service Accounts
Client Certificates
Integrating with cloud provider IAM
Correct answer:Static Token File
Explanation:Static Token File authentication is not recommended for production due to security concerns. It lacks the robustness and flexibility of other methods like OIDC or Service Accounts.


Which of the following is NOT a valid Kubernetes Service type?
ClusterIP
NodePort
LoadBalancer
ExternalName
InternalPort
Correct answer:InternalPort
Explanation:Kubernetes defines several Service types to expose applications: ClusterIP, NodePort, LoadBalancer, and ExternalName are valid types. 'InternalPort' is not a recognized Service type in Kubernetes and does not exist in the official API. ClusterIP exposes the service on a cluster-internal IP, NodePort exposes the service on each node's IP at a static port, LoadBalancer provisions an external load balancer, and ExternalName maps the service to a DNS name. Therefore, 'InternalPort' is invalid.


How can you create a ConfigMap from a file in Kubernetes?
kubectl create configmap my-config --file=config.yaml
kubectl apply configmap my-config --from-file=config.yaml
kubectl create configmap my-config --from-file=config.yaml
kubectl generate configmap my-config config.yaml
kubectl configmap my-config --import=config.yaml
Correct answer:kubectl create configmap my-config --from-file=config.yaml
Explanation:To create a ConfigMap from a file, you use the command `kubectl create configmap my-config --from-file=config.yaml`. This command allows you to import configuration data from a file into a ConfigMap, which can then be used by applications running in Kubernetes.


What is the recommended method to restrict access to the Kubernetes kubelet API securely?
Disable the kubelet service entirely
Configure kubelet with '--authorization-mode=Webhook' and '--authentication-token-webhook=true' flags
Remove the kubelet binary from all nodes
Access kubelet only via SSH tunnels
Set '--allow-privileged=false' to restrict privileged containers
Correct answer:Configure kubelet with '--authorization-mode=Webhook' and '--authentication-token-webhook=true' flags
Explanation:The kubelet API should be secured by enabling authentication and authorization mechanisms. Using the '--authorization-mode=Webhook' flag enables authorization via an external webhook, typically the API server, while '--authentication-token-webhook=true' enables token-based authentication against the API server. This combination ensures that only authenticated and authorized requests can access the kubelet API. Disabling the kubelet or removing it is impractical as it is essential for node management. Accessing kubelet only via SSH does not inherently secure the API itself. Setting '--allow-privileged=false' restricts privileged containers but does not control API access.


Which of the following best practices are recommended to secure the Kubernetes scheduler (kube-scheduler)? (Select all that apply.)
Bind the scheduler to 0.0.0.0 to ensure it is accessible from all network interfaces
Use Role-Based Access Control (RBAC) to restrict access to the scheduler API
Run the scheduler as a non-root user to minimize privilege escalation risks
Enable anonymous authentication to simplify access for debugging purposes
Configure network policies to restrict network access to and from the scheduler
Correct answer:Use Role-Based Access Control (RBAC) to restrict access to the scheduler API, Run the scheduler as a non-root user to minimize privilege escalation risks, Configure network policies to restrict network access to and from the scheduler
Explanation:The recommended security measures for securing the kube-scheduler include: using Role-Based Access Control (RBAC) to enforce least privilege, ensuring only authorized entities can interact with the scheduler's API; running the kube-scheduler as a non-root user to reduce potential risks of privilege escalation in case of a compromise; and configuring network policies to restrict unauthorized network access to or from the kube-scheduler, thereby enhancing its security. Binding the scheduler to 0.0.0.0 increases exposure and is not recommended. Similarly, enabling anonymous authentication weakens security by allowing unauthenticated access.


Which NIST Special Publication provides comprehensive guidelines on security and privacy controls specifically for federal information systems?
NIST SP 800-53 Rev. 5
NIST SP 800-190
NIST SP 800-63
NIST SP 800-171
NIST SP 800-30
Correct answer:NIST SP 800-53 Rev. 5
Explanation:NIST SP 800-53 Rev. 5 is the primary publication that provides guidelines on security and privacy controls for federal information systems. It outlines a comprehensive set of controls that are crucial for protecting the confidentiality, integrity, and availability of federal information systems. NIST SP 800-190 focuses on cloud computing security, NIST SP 800-63 deals with digital identity guidelines, NIST SP 800-171 provides guidelines for protecting controlled unclassified information in nonfederal systems, and NIST SP 800-30 is about risk management.


What is the outcome of setting 'imagePullPolicy: Never' in a Kubernetes pod specification?
The image will always be pulled from the registry
The pod will fail to start if the image is not present locally
The image will be pulled only if not present
The pod will ignore image updates in the registry
The kubelet will crash
Correct answer:The pod will fail to start if the image is not present locally
Explanation:Setting 'imagePullPolicy: Never' in a Kubernetes pod specification means that the image will not be pulled from the registry. The pod will only start if the image is already present locally. This policy is useful for environments where network connectivity is limited or unreliable.


When configuring encryption at rest for Kubernetes secrets using etcd, which Kubernetes component's configuration must be updated to enable this encryption?
kube-scheduler
kube-controller-manager
kubelet
kube-apiserver
etcd
Correct answer:kube-apiserver
Explanation:Encryption at rest for Kubernetes secrets is configured by updating the kube-apiserver with an encryption configuration file. The kube-apiserver handles requests and encrypts secrets before storing them in etcd. The other components do not manage encryption configuration for secrets.


What is the primary benefit of using multistage Docker builds?
Faster build times by reusing intermediate stages
Smaller and more secure final images by excluding build-time dependencies
Compatibility with older Docker versions for broader deployment
Simplified deployment scripts for easier automation
Enhanced network performance during container communication
Correct answer:Smaller and more secure final images by excluding build-time dependencies
Explanation:The primary advantage of multistage Docker builds is the ability to create smaller and more secure final images. By separating the build and runtime stages, unnecessary build-time dependencies (e.g., compilers, libraries) are excluded from the final image. This reduces the image size, minimizes the attack surface, and enhances security. While multistage builds can indirectly improve build times by optimizing layers, their main focus is on producing leaner and safer images. They do not specifically address network performance or deployment script simplification.


What is a common reason why a Kubernetes Network Policy might not be enforced as expected in a cluster?
Network Policies are enabled by default in all clusters
The installed CNI plugin does not support Network Policies
The Network Policy YAML contains syntax errors
The Kubernetes API server is unavailable
Network Policies only apply to traffic from outside the cluster
Correct answer:The installed CNI plugin does not support Network Policies
Explanation:Network Policies in Kubernetes rely on the underlying Container Network Interface (CNI) plugin to enforce rules. If the CNI plugin does not support Network Policies, then the policies will not be enforced regardless of their correctness. While syntax errors in the YAML or API server issues can cause problems, the primary reason Network Policies might not work is lack of CNI support. Also, Network Policies affect pod-to-pod traffic within the cluster, not just external traffic.


Which kubectl command lists all the nodes currently registered in a Kubernetes cluster?
kubectl get nodes
kubectl describe cluster
kubectl list nodes
kubectl cluster-info
kubectl get cluster-nodes
Correct answer:kubectl get nodes
Explanation:'kubectl get nodes' is the standard command to list all nodes in the cluster along with their status and other summary information. 'kubectl describe cluster' and 'kubectl get cluster-nodes' are not valid commands. 'kubectl list nodes' is not a valid kubectl command. 'kubectl cluster-info' provides cluster endpoint information but does not list nodes.


Which directories on a client machine contain sensitive information related to accessing Kubernetes clusters? (Select all that apply)
/var/log/
~/.kube/config
/etc/hosts
~/.ssh/
/tmp/
Correct answer:~/.kube/config, ~/.ssh/
Explanation:The ~/.kube/config file stores Kubernetes cluster access credentials and configuration, making it sensitive. The ~/.ssh/ directory contains SSH keys used for secure access to nodes or clusters. Other directories like /var/log/, /etc/hosts, and /tmp/ do not typically contain sensitive Kubernetes access information.


What is the purpose of the '--service-account-key-file' flag in the kube-apiserver?
To specify the private key file used to sign service account tokens
To define the service account used by the API server
To store service account credentials
To encrypt service account Secrets
To disable service accounts
Correct answer:To specify the private key file used to sign service account tokens
Explanation:The '--service-account-key-file' flag in the kube-apiserver specifies the path to the private key file used to sign service account tokens. This key is critical for token authentication and validation. The API server uses this key to cryptographically sign tokens issued to service accounts, ensuring their authenticity. Other options are incorrect: the flag does not define which service account the API server uses, nor does it store credentials or encrypt Secrets. It also does not disable service accounts.


What is an effective and consistent approach to enforce policies across multiple Kubernetes clusters?
Manually applying policies individually on each cluster
Using policy-as-code tools such as Open Policy Agent (OPA) or Kyverno
Relying solely on default Kubernetes security settings
Implementing different policies tailored for each environment
Enforcing policies only at the application layer
Correct answer:Using policy-as-code tools such as Open Policy Agent (OPA) or Kyverno
Explanation:Using policy-as-code tools like OPA or Kyverno enables automated, consistent, and scalable enforcement of policies across multiple Kubernetes clusters. Manual application is error-prone and inconsistent. Default Kubernetes settings are minimal and insufficient for comprehensive policy enforcement. Tailoring different policies per environment can lead to inconsistencies. Enforcing policies only at the application layer misses cluster-level security controls.


Which RBAC component links a ClusterRole to all authenticated users across the entire Kubernetes cluster?
ClusterRoleBinding
RoleBinding
ClusterRole
ServiceAccount
GroupBinding
Correct answer:ClusterRoleBinding
Explanation:ClusterRoleBinding associates ClusterRoles with subjects (users/groups/serviceaccounts) cluster-wide. This is critical for security as it affects all namespaces. Best practice recommends using RoleBinding with namespaced Roles for least-privilege access.


How can you retrieve the value of a secret key 'username' from the secret 'db-secret' in the namespace 'prod'?
kubectl get secret db-secret -n prod -o jsonpath='{.data.username}' | base64 --decode
kubectl describe secret db-secret -n prod
kubectl get secret db-secret -n prod -o yaml
kubectl read secret db-secret -n prod --key=username
kubectl decode secret db-secret -n prod --field=username
Correct answer:kubectl get secret db-secret -n prod -o jsonpath='{.data.username}' | base64 --decode
Explanation:To extract and decode the secret value, you use `kubectl get` with `jsonpath` to specify the key and then decode the base64 encoded value. This method is efficient for retrieving specific secret values.


What is the default service type in Kubernetes if not explicitly specified?
ClusterIP
NodePort
LoadBalancer
ExternalName
Ingress
Correct answer:ClusterIP
Explanation:If not specified, the default service type in Kubernetes is ClusterIP. This means the service is only accessible within the cluster. Other types like NodePort or LoadBalancer are used for external access.


Which of the following restrictions does the 'baseline' Pod Security Standard enforce? (Select all that apply)
Disallows privileged containers
Allows hostPath volumes
Blocks host networking and ports
Requires running as non-root
Allows all Linux capabilities
Correct answer:Disallows privileged containers, Blocks host networking and ports
Explanation:The 'baseline' Pod Security Standard disallows privileged containers and blocks host networking and ports. This ensures that pods are less vulnerable to security risks by limiting their capabilities.


In Kubernetes, which securityContext setting ensures that a container runs as a non-root user to enhance security?
runAsUser: 0
runAsNonRoot: true
runAsGroup: 0
allowPrivilegeEscalation: false
privileged: false
Correct answer:runAsNonRoot: true
Explanation:The 'runAsNonRoot: true' setting enforces that the container must run as a non-root user, preventing it from running with UID 0 (root). This enhances security by limiting container privileges. 'runAsUser: 0' explicitly sets the user to root, which is insecure. 'runAsGroup: 0' sets the group ID but doesn't enforce non-root user. 'allowPrivilegeEscalation: false' prevents privilege escalation but does not enforce non-root user. 'privileged: false' disables privileged mode but does not guarantee a non-root user.


What is the primary function of a Kubernetes Service of type 'NodePort'?
Exposes the service on a static port on each node's IP address
Load balances traffic across multiple services
Exposes the service externally using a cloud provider's load balancer
Maps the service to an external DNS name
Provides internal cluster DNS resolution

Correct answer:Exposes the service on a static port on each node's IP address
Explanation:A Kubernetes Service of type 'NodePort' exposes the service on the same static port across all nodes in the cluster, allowing external traffic to access the service via <NodeIP>:<NodePort>. It does not provide load balancing across multiple services (that is handled by ClusterIP or LoadBalancer types), nor does it map to external DNS names or provide internal DNS resolution. The LoadBalancer type is used to expose services externally via cloud provider load balancers.


Which security context setting ensures that a container runs as a non-root user in Kubernetes?
privileged: false
allowPrivilegeEscalation: false
runAsNonRoot: true
readOnlyRootFilesystem: true
capabilities: []
Correct answer:runAsNonRoot: true
Explanation:Setting 'runAsNonRoot: true' in a pod's security context ensures that the container is not run as the root user. This setting helps prevent unnecessary privilege escalation and improves container security.


In Kubernetes, which resource allows multiple containers to share the same network stack, enabling them to communicate using 'localhost'?

Correct answer:Pod
Explanation:A Pod in Kubernetes is the smallest deployable unit that can host one or more containers. Containers within the same Pod share the same network stack, including the same IP address and port space. This allows them to communicate with each other using 'localhost'. Other resources like Deployment, DaemonSet, Service, and StatefulSet are higher-level abstractions that manage Pods but do not define such shared networking behavior directly.


Which API server flag is used to specify the audit policy file that defines what events are recorded in Kubernetes audit logs?
--audit-log-path
--audit-policy-file
--enable-audit
--audit-log-maxage
--audit-log-format
Correct answer:--audit-policy-file
Explanation:The '--audit-policy-file' flag is used to specify the path to the audit policy file, which controls the granularity and types of events that are logged by the Kubernetes API server. Other flags like '--audit-log-path' specify where to write the logs, '--audit-log-maxage' controls log retention, and '--audit-log-format' defines the log format. There is no '--enable-audit' flag; audit logging is enabled by configuring these flags properly.


Which Kubernetes resource enables automatic horizontal scaling of Pods based on observed CPU utilization?
HorizontalPodAutoscaler
VerticalPodAutoscaler
ResourceQuota
LimitRange
Deployment
Correct answer:HorizontalPodAutoscaler
Explanation:The HorizontalPodAutoscaler (HPA) automatically adjusts the number of pod replicas in a deployment or replica set based on observed CPU utilization or other select metrics. VerticalPodAutoscaler adjusts resource requests and limits for containers rather than scaling pod count. ResourceQuota and LimitRange control resource usage limits but do not perform scaling. Deployment manages pod lifecycle but does not scale automatically based on CPU.


Which commands can be used to list all loaded AppArmor profiles on a Linux node?

Correct answer:sudo apparmor_status, sudo aa-status
Explanation:Both `sudo apparmor_status` and `sudo aa-status` can be used to list all loaded AppArmor profiles on a Linux node. These commands provide detailed information about AppArmor, including the number of loaded profiles, their modes (enforce or complain), and any unconfined processes. Other options are incorrect for the following reasons: 1. `sudo aa-enforce`: This command is used to set an AppArmor profile to enforce mode, not to list profiles. 2. `sudo apparmor_parser -L`: This command is used for loading AppArmor profiles but does not list them. 3. `sudo systemctl status apparmor`: This command checks the status of the AppArmor service but does not provide a list of loaded profiles. Using either `sudo apparmor_status` or `sudo aa-status` ensures you can monitor and manage AppArmor profiles effectively.


What is the purpose of the 'allowPrivilegeEscalation' field in a Kubernetes pod's security context?
Allows the container to run as root
Controls whether a process can gain more privileges than its parent process
Enables privileged mode for the container
Allows mounting of host directories
Disables all capabilities for the container
Correct answer:Controls whether a process can gain more privileges than its parent process
Explanation:The 'allowPrivilegeEscalation' field in a Kubernetes pod's security context controls whether a process can gain more privileges than its parent process. This setting is crucial for security as it prevents potential privilege escalation attacks by limiting the capabilities of processes within a container.


What is the primary function of Open Policy Agent (OPA) in Kubernetes?
To serve as a container runtime
To enforce policies and make authorization decisions
To provide logging and monitoring capabilities
To manage network routing
To handle storage management
Correct answer:To enforce policies and make authorization decisions
Explanation:Open Policy Agent (OPA) is a general-purpose policy engine that evaluates inputs against defined policies to make authorization decisions. In Kubernetes, OPA is commonly used to enforce security and compliance policies on cluster resources. Incorrect options, such as serving as a container runtime, logging, or network management, describe functionalities unrelated to OPA's role.


In the STRIDE threat modeling framework, what does 'Repudiation' refer to?
Unauthorized access
Denial of an action or event
Data leakage
Service unavailability
Privilege escalation
Correct answer:Denial of an action or event
Explanation:'Repudiation' in STRIDE refers to the ability of an attacker or user to deny having performed an action or event, which can hinder accountability and auditing. It is distinct from unauthorized access (spoofing), data leakage (information disclosure), service unavailability (denial of service), and privilege escalation.


What is the MITRE ATT&CK framework, and how is it used in cybersecurity?
A set of compliance requirements for cloud providers
A vulnerability scanning tool
A knowledge base of adversary tactics and techniques used in cyberattacks
An incident response guide for organizations
A network security protocol for secure communication
Correct answer:A knowledge base of adversary tactics and techniques used in cyberattacks
Explanation:The MITRE ATT&CK framework is a comprehensive knowledge base that catalogs adversary tactics, techniques, and procedures (TTPs) observed in real-world cyberattacks. It is widely used by cybersecurity professionals to understand attacker behavior, improve threat detection, and enhance defense strategies. Other options are incorrect because they describe unrelated tools or concepts.


Which field in the Pod spec can you use to disable privilege escalation for all containers in the Pod?
securityContext.allowPrivilegeEscalation: false
spec.containers.securityContext.allowPrivilegeEscalation: false
podSecurityContext.allowPrivilegeEscalation: false
spec.securityContext.allowPrivilegeEscalation: false
metadata.securityContext.allowPrivilegeEscalation: false
Correct answer:spec.containers.securityContext.allowPrivilegeEscalation: false
Explanation:The correct field to disable privilege escalation for all containers in a Pod is 'spec.containers.securityContext.allowPrivilegeEscalation: false'. This must be set individually for each container within the Pod, as there is no global 'allowPrivilegeEscalation' setting at the Pod level.


Which Kubernetes resource is used to request persistent storage for a Pod?
PersistentVolume
PersistentVolumeClaim
StorageClass
VolumeMount
ConfigMap
Correct answer:PersistentVolumeClaim
Explanation:A PersistentVolumeClaim (PVC) is used by a Pod to request persistent storage resources. The PVC is matched with a PersistentVolume (PV), which provides the actual storage. StorageClasses are used to dynamically provision PersistentVolumes.


What is a primary security risk associated with running a container in privileged mode?
Increased memory usage
Limited network access
Container gaining unrestricted access to host resources, posing security risks
Reduced application performance
Inability to use persistent volumes
Correct answer:Container gaining unrestricted access to host resources, posing security risks
Explanation:Running a container in privileged mode grants it almost the same access to the host as the root user, including direct access to host devices and kernel capabilities. This significantly increases the risk of container breakout and host compromise. The other options, such as increased memory usage or reduced performance, are not typical consequences of privileged mode, and privileged containers can still use persistent volumes and network access normally.


In a Kubernetes Pod specification, which field is used to define Linux capabilities for an individual container?
securityContext.capabilities
spec.capabilities
container.securityContext.capabilities
podSecurityContext.capabilities
linuxOptions.capabilities
Correct answer:securityContext.capabilities
Explanation:Linux capabilities for containers are specified under the 'securityContext.capabilities' field within the container's specification. This allows fine-grained control over the capabilities added or dropped for that specific container.


Which methods can be used to isolate resources effectively in a multi-tenant Kubernetes environment? (Select all that apply)
Deploying separate Kubernetes clusters for each tenant
Using Kubernetes namespaces combined with Role-Based Access Control (RBAC)
Applying Kubernetes Network Policies to restrict traffic
Sharing service accounts among tenants to simplify access
Disabling resource quotas to allow unlimited resource usage
Correct answer:Deploying separate Kubernetes clusters for each tenant, Using Kubernetes namespaces combined with Role-Based Access Control (RBAC), Applying Kubernetes Network Policies to restrict traffic
Explanation:Effective resource isolation in multi-tenant Kubernetes environments can be achieved by deploying separate clusters, using namespaces with RBAC to control access, and applying network policies to restrict communication. Sharing service accounts among tenants reduces isolation and is insecure. Disabling resource quotas removes limits on resource consumption, which can lead to resource contention and is not recommended.


What is the main purpose of an Ingress Controller in Kubernetes?
To expose services outside the cluster using HTTP/HTTPS
To manage internal pod communication
To store and manage secrets
To schedule pods to nodes
To provide persistent storage
Correct answer:To expose services outside the cluster using HTTP/HTTPS
Explanation:Ingress Controllers in Kubernetes manage external access to cluster services via HTTP/HTTPS. They act as entry points for incoming HTTP requests and route them to appropriate services within the cluster, allowing for load balancing, SSL termination, and path-based routing.


Which of the following are key advantages of implementing a Service Mesh in Kubernetes? (Select all that apply)
Built-in observability through metrics, logs, and traces
Simplifies application code by offloading cross-cutting concerns
Enhanced security through mutual TLS encryption
Adds significant latency to all communications
Requires minimal operational expertise to implement
Correct answer:Built-in observability through metrics, logs, and traces, Simplifies application code by offloading cross-cutting concerns, Enhanced security through mutual TLS encryption
Explanation:Service Meshes provide three primary benefits: 1) Comprehensive observability through automatic collection of communication metrics and distributed tracing. 2) Offloading of cross-cutting concerns like retries, timeouts, and circuit breaking from application code. 3) Security enhancements through automatic mutual TLS and fine-grained access controls. While they add some overhead, modern implementations minimize latency impact through optimized data planes.


When creating a NetworkPolicy to implement default deny egress traffic for Kubernetes pods, which policyTypes value must be specified?
Ingress only
Egress only
Both Ingress and Egress
DenyAll policy type
Egress with explicit deny rules
Correct answer:Egress only
Explanation:To create default deny egress, policyTypes must include Egress, and no egress rules should be defined. This combination blocks all outgoing traffic while allowing explicit exceptions through subsequent allow rules. The Kubernetes NetworkPolicy documentation emphasizes this pattern for implementing zero-trust network policies.


In a Kubernetes container's securityContext, which field allows you to add specific Linux capabilities to the container?
addCapabilities
linuxCapabilities
capabilities.add
securityOptions
privilegedCaps
Correct answer:capabilities.add
Explanation:The correct field is 'capabilities.add', which is a list under the container's securityContext that specifies which Linux capabilities to add to the container's default set. 'addCapabilities' and 'linuxCapabilities' are incorrect field names. 'securityOptions' and 'privilegedCaps' are not valid Kubernetes securityContext fields.


When an attacker gains access to a Kubernetes pod, which of the following attack scenarios is typically not persistent after the pod restarts?
Modifying the container image stored in the registry
Installing malware inside the pod's ephemeral filesystem
Exfiltrating data from the pod during its runtime
Altering data stored in a mounted PersistentVolume
Changing configurations stored in a ConfigMap
Correct answer:Installing malware inside the pod's ephemeral filesystem
Explanation:The pod's filesystem is ephemeral, meaning any changes such as malware installation inside the container's filesystem are lost when the pod restarts. Modifications to the container image in the registry, persistent volumes, or ConfigMaps are persistent because they exist outside the pod lifecycle. Data exfiltration is a runtime activity and does not persist but can have lasting impact.


How do you port-forward a local port to a port on a Kubernetes pod?
kubectl port-forward <pod-name> <local-port>:<pod-port>
kubectl forward-port <pod-name> <local-port>:<pod-port>
kubectl tunnel <pod-name> <local-port>:<pod-port>
kubectl proxy <pod-name> --port=<local-port>
kubectl connect <pod-name> --port=<local-port>
Correct answer:kubectl port-forward <pod-name> <local-port>:<pod-port>
Explanation:To port-forward a local port to a port on a Kubernetes pod, you use the command 'kubectl port-forward <pod-name> <local-port>:<pod-port>'. This command allows you to access the pod's port from your local machine.


Which guidance document provides best practices for mitigating supply chain risks in Kubernetes environments?
TOGAF Enterprise Architecture Framework
OWASP Top 10 Security Risks
NSA/CISA Kubernetes Hardening Guidance
ITIL Service Management Framework
SRE (Site Reliability Engineering) Handbook
Correct answer:NSA/CISA Kubernetes Hardening Guidance
Explanation:The NSA/CISA Kubernetes Hardening Guidance outlines strategies to mitigate supply chain risks in Kubernetes environments. It includes recommendations for securing container images, implementing role-based access control (RBAC), and ensuring secure configurations for clusters.


What is the primary function of a Horizontal Pod Autoscaler (HPA) in Kubernetes?
Automatically scales nodes
Scales pods based on CPU utilization
Schedules pods to nodes
Balances network traffic
Manages storage volumes
Correct answer:Scales pods based on CPU utilization
Explanation:A Horizontal Pod Autoscaler (HPA) in Kubernetes automatically adjusts the number of replicas of a pod based on observed CPU utilization or other custom metrics. This helps ensure that the application has sufficient resources to handle the current workload without over-allocating resources when demand is low.


Which Kubernetes resource type allows cluster administrators to define and enforce the use of specific container runtimes like gVisor or Kata Containers?
Containers?
Runtime
RuntimeClass
PodSecurityPolicy
SecurityContext
ContainerRuntime
Correct answer:RuntimeClass
Explanation:RuntimeClass is a first-class Kubernetes resource that specifies container runtime configurations. It enables security-conscious runtime selection (like gVisor's sandboxed environment) while maintaining portability across different container runtimes. PodSecurityPolicy (deprecated in v1.21) handled security policies but not runtime selection.


What are the key principles of the 4 Cs of cloud-native security?
Encrypting data at rest only
Applying security at Code, Container, Cluster, and Cloud levels
Relying solely on cloud provider security
Using containers to bypass security checks
Limiting security to the network layer
Correct answer:Applying security at Code, Container, Cluster, and Cloud levels
Explanation:The 4 Cs of cloud-native security emphasize the importance of applying security measures at multiple levels: Code (secure coding practices), Container (secure containerization), Cluster (secure Kubernetes clusters), and Cloud (secure cloud infrastructure). This layered approach ensures comprehensive security.


What are the four key areas of focus for cloud-native security, often referred to as the '4 Cs'?
Code, Container, Cluster, Cloud
Compute, Connectivity, Compliance, Cost
Cloud, Core, Control, Compliance
Code, Continuous Integration, Cloud, Compliance
Containerization, Coordination, Configuration, Control
Correct answer:Code, Container, Cluster, Cloud
Explanation:The '4 Cs' of cloud-native security are Code, Container, Cluster, and Cloud. These represent the layers where security should be applied to ensure comprehensive protection across the entire cloud-native stack.


How can you enable debug-level logging for the Kubernetes kubelet component?
Set the verbosity level to 4 by adding '--v=4' to the kubelet startup arguments
Run the command 'kubectl debug kubelet'
Modify the kubelet configuration file to set 'logLevel: debug'
Restart the kubelet with the flag '--debug=true'
Debug logging cannot be enabled for the kubelet
Correct answer:Set the verbosity level to 4 by adding '--v=4' to the kubelet startup arguments
Explanation:Debug logging in kubelet is enabled by increasing the verbosity level through the '--v' flag, with '--v=4' commonly used to enable debug-level logs. The other options are incorrect: 'kubectl debug kubelet' is not a valid command; kubelet configuration does not use a 'logLevel' field; '--debug=true' is not a recognized flag; and debug logging is indeed possible and commonly used for troubleshooting.


Which command is used to apply configuration changes defined in 'deployment.yaml' to a Kubernetes resource?
kubectl create -f deployment.yaml
kubectl apply -f deployment.yaml
kubectl set -f deployment.yaml
kubectl update -f deployment.yaml
kubectl replace -f deployment.yaml
Correct answer:kubectl apply -f deployment.yaml
Explanation:The 'kubectl apply -f deployment.yaml' command applies configuration changes to a Kubernetes resource defined in the YAML file. It uses declarative management, ensuring that the resource's current state matches the desired state specified in the file. Other commands like 'kubectl create' are used for creating resources but do not update existing ones, while 'kubectl replace' replaces the entire resource instead of merging changes.


What is the recommended approach to secure the Kubernetes Dashboard?
Expose it publicly without authentication
Use Role-Based Access Control (RBAC) and restrict access
Grant it cluster-admin privileges
Disable it entirely
Run it as a privileged container
Correct answer:Use Role-Based Access Control (RBAC) and restrict access
Explanation:Securing the Kubernetes Dashboard with Role-Based Access Control (RBAC) is crucial to limit exposure and ensure that only authorized users can access and manage cluster resources. This approach helps prevent unauthorized access and reduces the attack surface by enforcing strict access controls. For guidance on securing the Dashboard, refer to Kubernetes security best practices and RBAC documentation[1][3].


Which Kubernetes Pod specification field allows you to inject environment variables from a ConfigMap into containers?
VolumeMount
envFrom
Secret
Annotation
Label
Correct answer:envFrom
Explanation:The 'envFrom' field in a Pod specification enables injecting all key-value pairs from a ConfigMap as environment variables into the container. 'VolumeMount' is used for mounting volumes, 'Secret' is a separate object for sensitive data, 'Annotation' and 'Label' are metadata and do not inject environment variables.


How can you ensure that only signed images are run in your Kubernetes cluster?
Use imagePullSecrets
Configure admission controllers to verify image signatures
Manually inspect images before deployment
Disable image caching on nodes
Use a private container registry
Correct answer:Configure admission controllers to verify image signatures
Explanation:To ensure only signed images are run in a Kubernetes cluster, you can configure admission controllers like Gatekeeper or Kyverno to enforce policies that verify image signatures. This ensures that only trusted images are deployed.


Which Kubernetes admission controller runs first during the admission control process?
ValidatingAdmissionWebhook
MutatingAdmissionWebhook
ResourceQuota
NamespaceLifecycle
AlwaysPullImages
Correct answer:MutatingAdmissionWebhook
Explanation:The MutatingAdmissionWebhook runs first in the Kubernetes admission control process. This is because mutating admission controllers are designed to modify the incoming request before it is validated by validating admission controllers. Other options, such as ValidatingAdmissionWebhook, ResourceQuota, NamespaceLifecycle, and AlwaysPullImages, either run later in the process or serve different purposes.


In which scenarios is soft multi-tenancy preferred over hard multi-tenancy in cloud-native environments?
When strict tenant isolation is mandatory
For workloads from untrusted tenants requiring strong isolation
To maximize resource utilization efficiency in trusted tenant environments
When compliance with strict regulatory requirements is necessary
When deploying workloads across multiple Kubernetes clusters
Correct answer:To maximize resource utilization efficiency in trusted tenant environments
Explanation:Soft multi-tenancy is preferred when tenants are trusted and strict isolation is not required, allowing for more efficient sharing of resources. Hard multi-tenancy, by contrast, enforces strict isolation suitable for untrusted tenants or compliance-driven environments. Therefore, soft multi-tenancy optimizes resource usage in trusted settings but is not suitable where strong isolation or regulatory compliance is mandatory.


What is the primary role of Public Key Infrastructure (PKI) in IT security?
Managing network configurations
Handling storage volumes
Issuing and managing digital certificates and encryption keys
Maintaining container images
Collecting and analyzing application logs
Correct answer:Issuing and managing digital certificates and encryption keys
Explanation:Public Key Infrastructure (PKI) is a framework that manages digital certificates and encryption keys to enable secure communication and authentication over networks. It does not handle network configurations, storage volumes, container images, or application logs. PKI ensures trust by issuing certificates that verify identities and encrypt data.


Which kubectl command is used to create a pod directly from a container image?
kubectl create pod <pod-name> --image=<image>
kubectl run <pod-name> --image=<image>
kubectl new pod <pod-name> --image=<image>
kubectl pod <pod-name> --image=<image>
kubectl deploy pod <pod-name> --image=<image>
Correct answer:kubectl run <pod-name> --image=<image>
Explanation:The 'kubectl run' command is used to create a pod or deployment from a specified container image. It is the standard way to quickly start a pod with a given image. The other options are invalid commands or syntaxes that do not exist in kubectl.


What is the default Kubernetes behavior when a container exceeds its configured memory limit?
The container is throttled
The container is terminated
The pod is moved to another node
Kubernetes does nothing
Additional memory is allocated
Correct answer:The container is terminated
Explanation:When a container exceeds its memory limit, the Kubernetes kubelet kills the container to prevent it from affecting other workloads. This is known as an Out Of Memory (OOM) kill. The container is terminated and may be restarted depending on the pod's restart policy. CPU limits result in throttling, but memory limits cause termination. Kubernetes does not move pods automatically to other nodes or allocate additional memory beyond the specified limit.


What is the primary function of the Open Policy Agent (OPA) in Kubernetes environments?
A tool for monitoring and analyzing cluster performance metrics
A general-purpose policy engine that enables defining and enforcing custom policies
A built-in Kubernetes admission controller for validating resources
A network policy enforcement tool for controlling pod communication
A secret management system for storing sensitive data
Correct answer:A general-purpose policy engine that enables defining and enforcing custom policies
Explanation:Open Policy Agent (OPA) is a flexible, general-purpose policy engine that allows administrators to define and enforce custom policies across Kubernetes and other systems. It integrates with Kubernetes admission controllers but is not itself built-in. OPA is not a monitoring tool, network policy enforcer, or secret management system, although it can be used to enforce policies related to these areas.


Which kubectl command displays the Kubernetes client and server versions for the cluster?
kubectl version
kubectl get version
kubectl cluster-info
kubectl describe cluster
kubectl info
Correct answer:kubectl version
Explanation:The command 'kubectl version' shows both the client and server (cluster) Kubernetes versions, which is useful for verifying compatibility and troubleshooting. Other commands like 'kubectl get version' or 'kubectl info' are invalid or do not provide version details. 'kubectl cluster-info' provides cluster endpoint information but not version details.


In Kubernetes Role-Based Access Control (RBAC), what is the purpose of a RoleBinding?
Defines permissions within a namespace
Associates a Role with users, groups, or service accounts within a namespace
Creates a new role with cluster-wide permissions
Manages network policies for a namespace
Sets resource quotas for a project
Correct answer:Associates a Role with users, groups, or service accounts within a namespace
Explanation:A RoleBinding in Kubernetes RBAC binds a Role to one or more subjects (users, groups, or service accounts) within a specific namespace, granting them the permissions defined in that Role. Roles themselves define permissions, but RoleBindings associate those permissions with subjects. ClusterRoles and ClusterRoleBindings are used for cluster-wide permissions. Network policies and resource quotas are managed by different Kubernetes objects unrelated to RoleBindings.


What is the primary difference between MicroVM and User-Space Kernel approaches in cloud native security?
MicroVMs are larger in size
User-space kernels provide hardware virtualization
MicroVMs run directly on hardware without a host OS
User-space kernels intercept system calls in user space
There is no difference; they are the same
Correct answer:User-space kernels intercept system calls in user space
Explanation:The primary difference lies in how they operate. User-space kernels, like gVisor, run in user space and intercept system calls, providing a lightweight sandboxing mechanism. MicroVMs, on the other hand, are full-fledged virtual machines that run directly on hardware but require a host OS for management.


Which tool is specifically designed to perform static security analysis of Kubernetes manifests to identify potential security issues?
kube-bench
kube-hunter
kube-score
kubectl describe
kubesec
Correct answer:kubesec
Explanation:Kubesec is a static analysis tool that scans Kubernetes manifests for security risks and best practices violations before deployment. 'kube-bench' checks cluster nodes against CIS benchmarks, 'kube-hunter' performs active scanning for vulnerabilities, 'kube-score' provides general manifest validation but is less focused on security, and 'kubectl describe' is a CLI command for inspecting resources.


What are the potential impacts of enabling detailed auditing of request responses in a Kubernetes cluster?

Correct answer:Performance overhead and increased storage usage due to detailed logs
Explanation:Enabling detailed auditing of request responses in Kubernetes increases the volume and detail of audit logs generated, leading to higher storage consumption and potential performance overhead on the API server. While detailed auditing improves security visibility, it must be balanced against these resource impacts.


How do Kubernetes NetworkPolicies enhance cluster security when properly configured?
Enable automatic TLS certificate rotation
Enforce least-privilege communication between pods
Manage persistent volume encryption
Provide application auto-scaling capabilities
Enable cluster-wide logging aggregation
Correct answer:Enforce least-privilege communication between pods
Explanation:NetworkPolicies implement microsegmentation by controlling pod-to-pod communication through label selectors, effectively enforcing zero-trust networking principles. They prevent lateral movement attacks by restricting traffic flows between services. Other options describe unrelated features: TLS (option 1), storage (option 3), scaling (option 4), and logging (option 5) require different configurations.


Which command calculates the SHA256 checksum of the file '/usr/bin/kubelet' on a Linux system?
sha1sum /usr/bin/kubelet
md5sum /usr/bin/kubelet
checksum -sha256 /usr/bin/kubelet
sha256sum /usr/bin/kubelet
hash -a sha256 /usr/bin/kubelet
Correct answer:sha256sum /usr/bin/kubelet
Explanation:The command 'sha256sum /usr/bin/kubelet' computes the SHA256 checksum of the specified file, which is commonly used to verify file integrity. 'sha1sum' and 'md5sum' calculate different hash algorithms (SHA1 and MD5 respectively). 'checksum -sha256' and 'hash -a sha256' are not standard Linux commands for checksum calculation.


What is the primary function of a 'RoleBinding' in Kubernetes RBAC?
Defines cluster-wide permissions
Binds a ClusterRole to a namespace
Binds a Role to users or groups within a namespace
Creates a new ServiceAccount
Defines network policies
Correct answer:Binds a Role to users or groups within a namespace
Explanation:A RoleBinding in Kubernetes assigns a Role to specific users or groups within a namespace, granting them the permissions defined by that Role.


What is a significant security risk associated with not restricting egress traffic in a Kubernetes cluster?
It complicates the debugging process for network-related issues.
It leads to reduced latency in network communications within the cluster.
It creates a potential pathway for data exfiltration from compromised pods to external, unauthorized destinations.
It enhances and simplifies pod-to-pod communication within the cluster.
It simplifies network configuration, reducing the complexity of network policies.
Correct answer:It creates a potential pathway for data exfiltration from compromised pods to external, unauthorized destinations.
Explanation:Failing to restrict egress traffic in Kubernetes can expose the cluster to significant security risks, most notably data exfiltration. Without proper egress controls, a compromised pod can freely communicate with external servers, potentially leaking sensitive data to attackers. While unrestricted egress might simplify initial network configurations, the security implications far outweigh any convenience gained. Restricting egress traffic is a critical security measure to limit the attack surface and prevent unauthorized communication from within the cluster.


Which command lists all installed packages on a Debian-based Linux system using the apt package manager?
apt list --installed
dpkg -l
rpm -qa
yum list installed
pkg info
Correct answer:apt list --installed
Explanation:The command 'apt list --installed' displays all packages installed via the apt package manager on Debian-based systems. While 'dpkg -l' also lists installed packages, it shows lower-level package information and is not specific to apt. 'rpm -qa' and 'yum list installed' are commands used on RPM-based systems like Red Hat or CentOS, and 'pkg info' is used in BSD-based systems, making them incorrect for Debian-based systems.


Which Kubernetes object specifically controls inbound/outbound network traffic between Pods at the IP address and port level?
NetworkPolicy
Ingress
Service
Endpoint
FirewallRule
Correct answer:NetworkPolicy
Explanation:NetworkPolicy objects define granular rules for Pod-to-Pod communication, including allowed ingress/egress traffic. While Services enable network access to Pods and Ingress manages external HTTP(S) routing, NetworkPolicy provides critical microsegmentation capabilities for zero-trust security architectures.


In the STRIDE threat model, which category best describes a Trojan horse that compromises a build server?
Spoofing
Repudiation
Information Disclosure
Denial of Service
Tampering
Correct answer:Tampering
Explanation:A Trojan horse compromising a build server is an example of tampering because it involves unauthorized modification of system components or data. Tampering refers to malicious alterations that can affect the integrity of software or systems. Spoofing involves impersonation, repudiation relates to denial of actions, information disclosure concerns unauthorized data exposure, and denial of service targets availability, none of which precisely describe this scenario.


Can you enforce more than one Pod Security Admission (PSA) policy level concurrently within a single namespace?
Yes, by applying multiple labels
No, only one policy level per namespace
Yes, but only with custom configurations
Only if the namespace is partitioned
It depends on the Kubernetes version
Correct answer:No, only one policy level per namespace
Explanation:PSA policies are applied at the namespace level. Only one PSA policy level (privileged, baseline, or restricted) can be enforced per namespace for each mode (enforce, audit, or warn). This ensures clear and consistent policy enforcement.


When you run the command 'kubectl apply', which Kubernetes component processes the request first?
etcd
kube-scheduler
kube-controller-manager
kube-apiserver
kubelet
Correct answer:kube-apiserver
Explanation:All kubectl commands interact first with the kube-apiserver, which is the central management entity of the Kubernetes control plane. The API server authenticates and validates the request, then persists the desired state in etcd. Other components like the scheduler and controller manager act later based on the updated state.


How can you expose a Kubernetes deployment as a service?
kubectl expose deployment my-deployment
kubectl service deployment my-deployment
kubectl create service my-deployment
kubectl generate service my-deployment
kubectl map service my-deployment
Correct answer:kubectl expose deployment my-deployment
Explanation:The `kubectl expose` command creates a Service that exposes the deployment, allowing access to the pods within the deployment from outside the cluster.


What command can you use to edit a Kubernetes resource directly in your default editor?
kubectl change <resource>
kubectl update <resource>
kubectl edit <resource>
kubectl modify <resource>
kubectl adjust <resource>
Correct answer:kubectl edit <resource>
Explanation:The 'kubectl edit' command is used to edit a Kubernetes resource directly in your default editor. This command opens the resource's configuration file in your editor, allowing you to make changes before saving and applying them.


Which Kubernetes resource is used to assign permissions within a namespace to a user or group?
ClusterRole
Role
ClusterRoleBinding
RoleBinding
ServiceAccount
Correct answer:RoleBinding
Explanation:A RoleBinding is used to grant permissions defined in a Role to users or groups within a specific namespace. This is essential for fine-grained access control in Kubernetes.


What is the primary function of the Kubernetes scheduler in a cluster?
To monitor the overall health of the cluster
To assign pods to nodes based on resource availability and scheduling policies
To manage service discovery within the cluster
To enforce network policies between pods
To control user access to the Kubernetes API server
Correct answer:To assign pods to nodes based on resource availability and scheduling policies
Explanation:The Kubernetes scheduler is responsible for selecting the most suitable node for each pod to run on, based on resource availability, constraints, and scheduling policies. It does not monitor cluster health, manage service discovery, enforce network policies, or control API server access. Those responsibilities belong to other components like the kube-controller-manager, CoreDNS, network plugins, and the API server's authentication/authorization mechanisms.


How can you retrieve the digest (content hash) of the Docker image 'nginx:1.19' using the Docker CLI?
docker images nginx:1.19 --digests
docker inspect nginx:1.19 --format='{{.Id}}'
docker pull nginx@sha256
docker inspect --format='{{index .RepoDigests 0}}' nginx:1.19
docker tag nginx:1.19 nginx:sha256
Correct answer:docker inspect --format='{{index .RepoDigests 0}}' nginx:1.19
Explanation:The command 'docker inspect --format='{{index .RepoDigests 0}}' nginx:1.19' extracts the image digest from the image's metadata, showing the content-addressable identifier (digest) of the image. Option 1 lists digests for all images but may not show the specific digest for the tag. Option 2 shows the image ID, which is different from the digest. Option 3 is incomplete and incorrect syntax. Option 5 is unrelated to obtaining the digest, as it tags images but does not display digests.


Which command is recommended to check the readiness and status of Kubernetes cluster components?
kubectl get components
kubectl get --raw='/readyz?verbose'
kubectl get cs
kubectl get componentstatuses
kubectl describe components
Correct answer:kubectl get --raw='/readyz?verbose'
Explanation:The command `kubectl get --raw='/readyz?verbose'` is the recommended way to check the readiness and status of Kubernetes cluster components. This approach provides detailed and up-to-date information about the health of the cluster. Other commands, such as `kubectl get cs` (deprecated shorthand) and `kubectl get componentstatuses` (deprecated endpoint), are no longer reliable in newer Kubernetes versions.


To enable audit logging in Kubernetes, which flag must be added to the API server configuration to specify the log file path?
--audit-log-path
--audit-policy-file
--enable-audit
--audit-log-maxage
--audit-log-format
Correct answer:--audit-log-path
Explanation:The '--audit-log-path' flag is crucial for enabling audit logging by specifying the path where audit logs will be stored. This allows for the collection and analysis of API requests and responses, which is essential for security auditing and compliance.


In Kubernetes, how can you apply an AppArmor profile to all containers within a Pod?
Set the profile in the Pod's securityContext
Annotate each container with the AppArmor profile
Use the 'appArmorProfile' field in the container spec
Specify the profile in the Deployment's metadata
Set the profile in the node's AppArmor configuration
Correct answer:Annotate each container with the AppArmor profile, Use the 'appArmorProfile' field in the container spec
Explanation:To apply an AppArmor profile to all containers in a Pod, you can use one of two methods: 1. **Annotations**: Use the annotation `container.apparmor.security.beta.kubernetes.io/<container_name>: <profile_ref>` for each container in the Pod. This method has been traditionally used and is backward-compatible. 2. **`appArmorProfile` field in `securityContext`**: Starting with Kubernetes v1.30, you can specify the AppArmor profile directly in the `securityContext` of a container using the `appArmorProfile` field. This method is more intuitive and avoids relying on annotations. Other options, such as setting it in the Deployment metadata or node-level configuration, are not valid methods for applying AppArmor profiles to specific containers.


Which statement best describes the purpose of the CIS Controls in the context of enterprise cybersecurity?
They define licensing restrictions for enterprise software
They specify hardware requirements for data center appliances
They provide a prioritized set of cybersecurity best practices to defend against common cyber attacks
They offer guidelines for AI-based container scheduling
They focus exclusively on physical security measures
Correct answer:They provide a prioritized set of cybersecurity best practices to defend against common cyber attacks
Explanation:The CIS Controls are a set of prioritized cybersecurity best practices designed to help organizations defend against the most common and pervasive cyber threats. They provide actionable guidance for improving security posture. The other options are incorrect because CIS Controls do not deal with software licensing, hardware specifications, AI scheduling, or solely physical security.


What is the primary purpose of audit logging in Kubernetes?
To monitor application performance
To track and record API server requests for security and compliance auditing
To manage network policies
To automatically scale applications based on load
To store container images
Correct answer:To track and record API server requests for security and compliance auditing
Explanation:Audit logging in Kubernetes is designed to record all requests made to the API server, capturing details about who did what and when. This information is crucial for security auditing, compliance monitoring, and forensic analysis. It is not intended for monitoring application performance, managing network policies, scaling applications, or storing container images, which are handled by other Kubernetes components or tools.


Which best defines PCI DSS in a containerized environment?
A software license for open-source container platforms
A set of security standards for systems handling cardholder data, applicable to container-based workflows
A Kubernetes admission controller for preventing configuration drift
A recommended approach to container performance tuning
A zero-trust compliance framework for data science workloads
Correct answer:A set of security standards for systems handling cardholder data, applicable to container-based workflows
Explanation:PCI DSS in a containerized environment refers to the application of its security standards to workflows that handle cardholder data within containers. This includes ensuring compliance with requirements such as network segmentation, access control, and real-time monitoring. Other options are incorrect because they either mischaracterize PCI DSS or describe unrelated concepts like software licenses or Kubernetes-specific tools.


In a Dockerfile, which instruction is used to specify that the container should run as a non-root user?
FROM nonroot
USER nobody
RUN chmod 777 /app
EXPOSE 80
ENTRYPOINT ["/app"]
Correct answer:USER nobody
Explanation:The 'USER' instruction in a Dockerfile sets the user under which the container process runs. Using 'USER nobody' ensures the application runs as a non-root user, enhancing container security. 'FROM nonroot' is not a valid instruction, 'RUN chmod 777 /app' changes permissions but does not change the user, 'EXPOSE' declares ports, and 'ENTRYPOINT' specifies the executable.


Why is a ConfigMap not suitable for storing sensitive information such as secrets in Kubernetes?
ConfigMaps cannot be mounted as volumes in pods
ConfigMaps do not support key-value pairs
Data stored in ConfigMaps is kept in plain text and not encrypted
ConfigMaps are deprecated in recent Kubernetes versions
ConfigMaps have strict size limitations that prevent storing secrets
Correct answer:Data stored in ConfigMaps is kept in plain text and not encrypted
Explanation:ConfigMaps are designed to store non-sensitive configuration data as key-value pairs and store data in plain text within etcd. They do not provide encryption or access controls suitable for sensitive information. Secrets, on the other hand, are specifically designed to store sensitive data and can be encrypted at rest. ConfigMaps can be mounted as volumes and are not deprecated. While ConfigMaps have size limits, the primary reason they are unsuitable for secrets is the lack of security.


Why is it crucial to restrict access to etcd in a Kubernetes cluster?
Because etcd stores logs that can be tampered with
Because etcd contains all cluster data, including secrets, and access can lead to cluster compromise
Because etcd runs the application code
Because etcd controls network policies
Because etcd is not important and can be ignored
Correct answer:Because etcd contains all cluster data, including secrets, and access can lead to cluster compromise
Explanation:Restricting access to etcd is vital because it stores sensitive data, including cluster secrets. Unauthorized access to etcd can compromise the entire Kubernetes cluster.


What does the '--anonymous-auth=false' flag do when set on the kube-apiserver?
Disables anonymous requests to the API server
Disables authentication entirely
Allows all requests without authentication
Enables anonymous authentication
Forces all clients to use tokens
Correct answer:Disables anonymous requests to the API server
Explanation:Setting '--anonymous-auth=false' on the kube-apiserver ensures that all requests to the API server must be authenticated. This enhances security by preventing unauthorized access.


What is the correct 'kind' value for an object that associates a Role with a user or group?
RoleBinding
ClusterRole
User
Group
RoleAssignment
Correct answer:RoleBinding
Explanation:A RoleBinding is the Kubernetes object that binds a Role to a user or group within a namespace, enabling them to perform specific actions.


What is the primary function of a Service Mesh in Kubernetes architecture?
A network overlay for pod communication
An infrastructure layer for handling service-to-service communication
A type of storage solution
A container runtime interface
A logging mechanism
Correct answer:An infrastructure layer for handling service-to-service communication
Explanation:A Service Mesh is a dedicated infrastructure layer that manages service-to-service communication through sidecar proxies, providing features like traffic management, service discovery, and security policies without requiring application code changes. While pod communication occurs through the mesh, it's not merely a network overlay but rather a comprehensive communication management layer.


What is the main objective of Microsoft's Security Development Lifecycle (SDL)?
To provide a compliance checklist for healthcare data
To outline an encryption standard for IoT devices
To incorporate threat modeling and mitigation throughout the software development process
To define data storage formats for container logs
To guide zero-downtime deployment strategies
Correct answer:To incorporate threat modeling and mitigation throughout the software development process
Explanation:Microsoft's Security Development Lifecycle (SDL) is a comprehensive process that integrates security and privacy best practices into every phase of software development. Its primary focus is on identifying potential threats early through threat modeling and implementing mitigations to reduce vulnerabilities. It is not a compliance checklist, encryption standard, logging format, or deployment strategy guide.


Which statement best describes the Kubernetes Ingress resource?
It defines internal networking rules between pods
It manages external HTTP and HTTPS access to services
It is used for storing configuration data
It schedules pods to nodes
It provides persistent storage to pods
Correct answer:It manages external HTTP and HTTPS access to services
Explanation:Kubernetes Ingress is a resource that manages external access to services, typically HTTP and HTTPS traffic. It provides routing rules to direct external requests to the appropriate backend services within the cluster. It does not define internal pod networking (that is handled by Services and network plugins), nor is it used for storing configuration data (ConfigMaps/Secrets), scheduling pods (handled by the scheduler), or providing persistent storage (handled by PersistentVolumes).


Which strace command-line option provides a summary of the time spent in each system call during program execution?
-c
-p
-t
-e trace=%time
-s
Correct answer:-c
Explanation:The '-c' option in strace outputs a summary report showing the count, total time, and average time spent in each system call, helping analyze performance bottlenecks. The '-p' option attaches strace to an existing process by PID, '-t' prefixes each line with a timestamp, '-e trace=%time' is not a valid option, and '-s' sets the maximum string size to print, so they do not provide a time summary.


Which Kubernetes component serves as the entry point for the control plane and exposes the Kubernetes API?
kubelet
kube-scheduler
kube-apiserver
kube-proxy
etcd
Correct answer:kube-apiserver
Explanation:The kube-apiserver acts as the front end of the control plane, handling incoming API requests and serving as the primary interface for Kubernetes cluster management. It is responsible for authenticating and authorizing all requests to the API server, ensuring secure access to cluster resources. For more information, refer to the official Kubernetes documentation on components and architecture[1][3].


What are the key best practices for hardening container images to enhance security?
Use a minimal base image to reduce the attack surface.
Run containers as root to simplify privilege management.
Remove unnecessary packages and dependencies to minimize potential vulnerabilities.
Expose all ports for maximum connectivity and flexibility.
Regularly scan images for known vulnerabilities and apply necessary patches.
Correct answer:Use a minimal base image to reduce the attack surface., Remove unnecessary packages and dependencies to minimize potential vulnerabilities., Regularly scan images for known vulnerabilities and apply necessary patches.
Explanation:To effectively harden container images, it is crucial to minimize the attack surface and potential vulnerabilities. Using minimal base images ensures that only essential components are included, reducing the number of potential security flaws. Removing unnecessary packages further decreases the likelihood of exploitable vulnerabilities. Regularly scanning images for known vulnerabilities allows for proactive identification and remediation of security risks. Running containers as root is discouraged because it gives the process elevated privileges that it does not need and exposes the host system to vulnerabilities. Exposing all ports creates unnecessary entry points for attackers.


Which configuration in a Kubernetes container's securityContext is used to drop all Linux capabilities, effectively removing extra privileges?
capabilities: {drop: ['ALL']}
capabilities: {add: ['NONE']}
privileged: false
allowPrivilegeEscalation: false
runAsNonRoot: true
Correct answer:capabilities: {drop: ['ALL']}
Explanation:To remove all Linux capabilities from a container, the 'capabilities' field under the container's securityContext should specify 'drop: ['ALL']'. This explicitly drops all added capabilities, minimizing the container's privileges.


Which kubectl command allows you to view the current resource usage (CPU and memory) of a specific pod?
kubectl describe pod <pod-name>
kubectl top pod <pod-name>
kubectl get pod <pod-name> --resources
kubectl logs <pod-name>
kubectl inspect pod <pod-name>
Correct answer:kubectl top pod <pod-name>
Explanation:The 'kubectl top pod <pod-name>' command displays the current CPU and memory usage of the specified pod, provided that the Metrics Server is installed and running in the cluster. 'kubectl describe' shows detailed pod information but not real-time resource usage. The other commands do not provide resource consumption data.


What is a common cause for failing to pull the latest version of a container image from the 'k8s.gcr.io' registry?
The image registry has been deprecated or is unavailable
Specifying an incorrect image name or tag in the pull command
Network policies blocking outbound traffic from the node
The Kubernetes node lacks sufficient CPU or memory resources
The kube-proxy component is not running on the node
Correct answer:Specifying an incorrect image name or tag in the pull command
Explanation:A frequent reason for image pull failures is specifying an incorrect image name or tag, which leads to the registry not finding the requested image. While registry deprecation or network policies can also cause issues, the most common and easily overlooked cause is a typo or mismatch in the image reference. Insufficient node resources or kube-proxy issues typically do not directly cause image pull failures.


Which of the following actions in Kubernetes cross trust boundaries and potentially introduce security risks? (Select all that apply)
Accessing the Kubernetes API server
Communicating between pods within the same namespace
Mounting hostPath volumes into pods
Using service accounts across different namespaces
Pulling container images from public registries
Correct answer:Mounting hostPath volumes into pods, Using service accounts across different namespaces, Pulling container images from public registries
Explanation:Mounting hostPath volumes allows pods to access the host filesystem, crossing the boundary between container and host, which poses significant security risks. Using service accounts across namespaces can bypass namespace isolation, potentially escalating privileges. Pulling images from public registries introduces risks from untrusted or malicious images. Accessing the Kubernetes API is a controlled and authenticated action, while pod-to-pod communication within the same namespace is generally within the same trust boundary and less risky.


Which of the following options is NOT a category in the STRIDE threat model?
Spoofing
Tampering
Replication
Information Disclosure
Denial of Service
Correct answer:Replication
Explanation:Replication is not one of the categories in the STRIDE threat model. The STRIDE model includes Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, and Elevation of Privileges.


Why is integrating TLS certificates critical for supply chain security in Kubernetes environments?
It ensures faster application deployment via automation
It facilitates multi-cloud resource allocation
It secures communication between admission controllers and the API server, preventing man-in-the-middle attacks
It helps in container orchestration on legacy systems
It extends the clusterâ€™s node pool automatically
Correct answer:It secures communication between admission controllers and the API server, preventing man-in-the-middle attacks
Explanation:TLS certificate integration is essential in Kubernetes supply chain security because it encrypts and authenticates communication between components such as admission controllers and the API server. This prevents attackers from intercepting or tampering with requests, thereby mitigating man-in-the-middle attacks and ensuring the integrity of the supply chain. The other options do not relate to TLS's role in securing communication or supply chain integrity.


Which Kubernetes component is responsible for enforcing Pod Security Standards through admission control?
kube-scheduler
kube-apiserver with the PodSecurity admission plugin
kube-controller-manager
kubelet
etcd
Correct answer:kube-apiserver with the PodSecurity admission plugin
Explanation:The kube-apiserver enforces Pod Security Standards by using the PodSecurity admission plugin, which validates and enforces security policies on pods during creation or update. The kube-scheduler schedules pods to nodes, kube-controller-manager manages controllers, kubelet runs on nodes to manage pods, and etcd is the cluster data store; none of these enforce Pod Security Standards directly.


Which statement accurately describes how Kubernetes Network Policies control pod-to-pod communication within a cluster?
By default, they block all traffic between pods.
They use iptables rules (via the CNI plugin) to control pod communication.
They are enforced by the kube-scheduler.
They manage access to the Kubernetes API.
They control storage access for pods.
Correct answer:They use iptables rules (via the CNI plugin) to control pod communication.
Explanation:Kubernetes Network Policies define how groups of pods are allowed to communicate with each other and with other network endpoints. These policies are enforced by the Container Network Interface (CNI) plugin used in the cluster. Most CNI plugins implement network policies using iptables or similar mechanisms to control traffic at the network level. By default, if no Network Policy is applied, all pods can communicate freely. Network Policies do not block all traffic by default, nor are they enforced by the kube-scheduler. They do not manage API or storage access.


Why is it advisable to avoid running containers with root privileges in a Kubernetes environment?
It increases resource consumption
It can lead to security risks by granting unnecessary permissions
It reduces application performance
It prevents containers from accessing the network
It is required by Kubernetes policies
Correct answer:It can lead to security risks by granting unnecessary permissions
Explanation:Running containers as root increases the risk of privilege escalation and other security attacks. By running containers as non-root users, you reduce the attack surface and improve the overall security posture of your Kubernetes environment.


Which tool is commonly used for real-time compliance monitoring and alerting in Kubernetes environments?
Sysdig Secure
NTP daemon
CoreDNS
Kubernetes Dashboard
etcd
Correct answer:Sysdig Secure
Explanation:Sysdig Secure is a tool designed for real-time compliance monitoring, anomaly detection, and security enforcement in Kubernetes environments. It helps ensure that clusters adhere to security standards and best practices.


What is the role of the 'cluster-admin' ClusterRole?

Correct answer:Full control over all resources in the cluster
Explanation:The 'cluster-admin' ClusterRole grants full cluster-wide administrative permissions. When bound via a ClusterRoleBinding, it provides full control over all resources in the cluster. When bound via a RoleBinding, its permissions are limited to the namespace specified in the binding.


What admission controller should be used to enforce Pod Security Standards in Kubernetes versions 1.25 and later?
PodSecurityPolicy
Pod Security Admission Controller
NodeRestriction
ResourceQuota
LimitRanger
Correct answer:Pod Security Admission Controller
Explanation:The Pod Security Admission Controller is the recommended method for enforcing Pod Security Standards in Kubernetes versions 1.25 and above. This controller replaces the deprecated PodSecurityPolicy and provides a more flexible and efficient way to manage pod security.


Which Kubernetes component is responsible for securely storing and managing all cluster data, including Secrets, ConfigMaps, and cluster state?
kube-apiserver
kube-scheduler
kubelet
etcd
kube-controller-manager
Correct answer:etcd
Explanation:etcd is the distributed key-value store that serves as Kubernetes' primary data store. It maintains the cluster's state, configuration data, and Secrets. While the kube-apiserver interacts with etcd, it doesn't store data directly. Proper etcd configuration (encryption, access controls, backups) is critical for cluster security.


How do you display the full YAML definition of a specific pod in Kubernetes using kubectl?
kubectl show pod <pod-name>
kubectl get pod <pod-name> -o yaml
kubectl describe pod <pod-name>
kubectl view pod <pod-name>
kubectl yaml pod <pod-name>
Correct answer:kubectl get pod <pod-name> -o yaml
Explanation:The command 'kubectl get pod <pod-name> -o yaml' outputs the complete YAML manifest of the specified pod, showing its configuration as stored in the cluster. 'kubectl describe pod <pod-name>' provides detailed runtime information but not the raw YAML definition. The other commands are not valid kubectl commands.


Which statement best describes the purpose of the CIS Kubernetes Benchmark?

Correct answer:It offers prescriptive configuration guidelines for hardening Kubernetes clusters
Explanation:The CIS Kubernetes Benchmark provides detailed, consensus-based best practices for securely configuring Kubernetes clusters. It focuses on hardening the cluster components and configurations to reduce security risks. It is not a software tool, nor does it focus exclusively on threat modeling or container image scanning. While zero-trust principles may be relevant to Kubernetes security, the benchmark itself specifically addresses configuration hardening.


How can you prevent pods from being scheduled on a Kubernetes node?
kubectl cordon <node-name>
kubectl drain <node-name>
kubectl taint nodes <node-name> key=value:NoSchedule
kubectl label nodes <node-name> unschedulable=true
kubectl delete node <node-name>
Correct answer:kubectl cordon <node-name>, kubectl taint nodes <node-name> key=value:NoSchedule
Explanation:Both cordoning and tainting a node with `kubectl taint nodes <node-name> key=value:NoSchedule` prevents pods without a matching toleration from being scheduled on it. This is a way to mark nodes as unsuitable for certain workloads without completely removing them from the cluster.


What is the primary benefit of applying the CIS Kubernetes Benchmark to production clusters?

Correct answer:It provides prescriptive security hardening recommendations to enhance cluster security and compliance
Explanation:The CIS Kubernetes Benchmark offers detailed, prescriptive guidelines and best practices for securing Kubernetes clusters. Applying these recommendations helps organizations harden their production environments against security threats and meet compliance requirements. The benchmark does not guarantee zero downtime, enforce deployment strategies, provide automatic encryption, or replace orchestration with serverless functions.


Why might a pod retain privileged access even after applying the 'restricted' Pod Security Standard (PSS) or Pod Security Admission (PSA) policy to its namespace?
The Pod Security Standard does not apply retroactively to existing pods
The namespace labels required for policy enforcement are misconfigured or missing
The Kubernetes API server does not support Pod Security Standards
The pod specification explicitly overrides the policy
Privileged access is always allowed regardless of policy
Correct answer:The Pod Security Standard does not apply retroactively to existing pods, The namespace labels required for policy enforcement are misconfigured or missing
Explanation:The 'restricted' Pod Security Standard or Pod Security Admission policy applies only to pods created or updated after the policy is enforced; existing pods are not automatically remediated. Enforcement also depends on correct namespace labeling (e.g., 'pod-security.kubernetes.io/enforce=restricted'). If these labels are missing or misconfigured, the policy will not be enforced on pods in that namespace.


What is the primary purpose of a PodDisruptionBudget in Kubernetes?

Correct answer:To prevent pods from being evicted during maintenance
Explanation:A PodDisruptionBudget ensures that a specified number of replicas of a pod are available at any time, preventing disruptions during maintenance or other events that might cause pod eviction.


What is the correct command to label a Kubernetes namespace named 'production' with the label 'env=prod'?
kubectl label namespace env=prod production
kubectl label namespace production env=prod
kubectl annotate namespace production env=prod
kubectl label namespaces env=prod production
kubectl set label namespace production env=prod
Correct answer:kubectl label namespace production env=prod
Explanation:To label a Kubernetes namespace, you use the `kubectl label` command. The correct syntax is `kubectl label namespace <namespace_name> <label_key>=<label_value>`. Therefore, to label the 'production' namespace with 'env=prod', you would use `kubectl label namespace production env=prod`. This command updates the namespace with the specified label, which can be useful for organizing and filtering resources within your cluster.


What is the effect of the 'kubectl config use-context' command in Kubernetes?
Switches the active namespace in the current context
Changes the current kubeconfig file being used
Modifies the cluster configuration in kubeconfig
Sets the current context to the specified one in kubeconfig
Updates the API server endpoint in the current context
Correct answer:Sets the current context to the specified one in kubeconfig
Explanation:The command 'kubectl config use-context <context-name>' sets the current context in the kubeconfig file to the specified context. This changes which cluster, user, and namespace kubectl commands operate against by default. It does not switch namespaces directly (that requires 'kubectl config set-context' or 'kubectl config set-namespace'), nor does it change the kubeconfig file itself or modify cluster details. It simply selects which predefined context is active.


During the build phase of a Kubernetes application, which practices are most effective for ensuring security?
Use minimal base images to reduce the attack surface.
Run containers as root to simplify privilege management.
Scan images for vulnerabilities to identify and remediate potential security flaws.
Include unnecessary packages to provide additional functionality.
Use only authorized images from trusted registries to prevent the introduction of malicious code.
Correct answer:Use minimal base images to reduce the attack surface., Scan images for vulnerabilities to identify and remediate potential security flaws., Use only authorized images from trusted registries to prevent the introduction of malicious code.
Explanation:In the build phase, security is best ensured by minimizing the image footprint with minimal base images, regularly scanning for vulnerabilities to catch issues early, and using only authorized images from trusted sources. Minimal base images reduce the attack surface. Vulnerability scanning identifies and allows remediation of security flaws before deployment. Using authorized images prevents the introduction of untrusted or malicious code. Running containers as root is a security risk, and including unnecessary packages increases the potential attack surface.


Which kubectl command is used to retrieve the logs of a pod named 'my-pod'?
kubectl get logs my-pod
kubectl describe my-pod
kubectl logs my-pod
kubectl status my-pod
kubectl inspect my-pod
Correct answer:kubectl logs my-pod
Explanation:The correct command to view the logs of a pod named 'my-pod' is 'kubectl logs my-pod'. This command fetches the standard output and error logs from the pod's containers. 'kubectl describe' provides detailed resource information but not logs. The other commands are invalid or do not exist.


If the Kubernetes API server is not responding, which configuration file should you check for possible misconfigurations?
/var/log/kube-apiserver.log
/etc/kubernetes/manifests/kube-scheduler.yaml
/etc/kubernetes/manifests/kube-apiserver.yaml
/etc/kubernetes/config/apiserver.conf
/var/lib/kubelet/config.yaml
Correct answer:/etc/kubernetes/manifests/kube-apiserver.yaml
Explanation:The Kubernetes API server's configuration is typically defined in its static pod manifest, which is usually located at `/etc/kubernetes/manifests/kube-apiserver.yaml`. This file contains the configuration for the API server, including any custom settings or overrides that might be causing issues. Checking this file can help identify misconfigurations that could be preventing the API server from responding.


How does the underlying cloud infrastructure impact the security of a Kubernetes cluster?
No impact, as Kubernetes abstracts infrastructure entirely
Yes, infrastructure vulnerabilities can compromise cluster security
Only if using on-premises hardware
It depends on the Kubernetes version
Only when running stateful applications
Correct answer:Yes, infrastructure vulnerabilities can compromise cluster security
Explanation:The security of the underlying cloud infrastructure directly impacts the security of a Kubernetes cluster. Vulnerabilities in the infrastructure can compromise the cluster, making it essential to ensure the infrastructure is secure.


What is a primary objective of supply chain compliance in Kubernetes environments?
To reduce container start-up times
To ensure all software components, including third-party container images, comply with security and integrity standards
To provide a universal logging format for microservices
To automatically scale nodes based on environmental sensor data
To monitor CPU resource usage for cost optimization
Correct answer:To ensure all software components, including third-party container images, comply with security and integrity standards
Explanation:Supply chain compliance in Kubernetes focuses on verifying the integrity, provenance, and security of all software components used throughout the application lifecycle, including third-party container images. This ensures that only trusted and compliant components are deployed, mitigating risks from vulnerabilities or malicious code. Other options, such as reducing container start-up times or scaling nodes based on sensor data, are unrelated to supply chain compliance objectives.


What command is used to scan a Docker image named 'myapp:latest' for HIGH and CRITICAL vulnerabilities using Trivy?
trivy myapp:latest
trivy image --severity HIGH,CRITICAL myapp:latest
trivy scan --critical myapp:latest
trivy image --vulnerabilities HIGH,CRITICAL myapp:latest
trivy inspect myapp:latest
Correct answer:trivy image --severity HIGH,CRITICAL myapp:latest
Explanation:The correct command to scan for HIGH and CRITICAL vulnerabilities is 'trivy image --severity HIGH,CRITICAL myapp:latest'. This command specifically targets vulnerabilities of those severities in the Docker image.


Which tool is widely used to automate compliance checks against the CIS Kubernetes Benchmark?

Correct answer:Kube-bench
Explanation:Kube-bench is a specialized open-source tool designed to automate the assessment of Kubernetes clusters against the CIS Kubernetes Benchmark, which defines security best practices. Unlike generic tools such as Nmap or Grafana, Kube-bench runs checks that correspond directly to the CIS controls, providing detailed reports on compliance status. While Bash scripts can be used for automation, they lack the comprehensive and standardized checks that Kube-bench provides. Syslog-ng is a logging tool and unrelated to compliance scanning.


What is the primary objective of threat modeling in the context of Kubernetes security?
To define default CPU and memory limits for all workloads
To visualize data flows and identify potential attack vectors within cluster configurations
To enforce container image scanning during runtime
To conduct load testing on container orchestration systems
To accelerate pipeline deployments in CI/CD
Correct answer:To visualize data flows and identify potential attack vectors within cluster configurations
Explanation:Threat modeling in Kubernetes security involves creating a detailed representation of data flows and system components to identify potential vulnerabilities and attack vectors within cluster configurations. This proactive approach helps security teams anticipate and mitigate risks before exploitation. Defining resource limits, enforcing image scanning, load testing, or accelerating CI/CD pipelines are important operational tasks but do not constitute the core purpose of threat modeling.


What was the precursor to the Pod Security Standards (PSS) in Kubernetes?
Pod Security Admission (PSA)
Kubernetes Security Policies (KSP)
PodSecurityPolicy (PSP)
Network Policies
Role-Based Access Control (RBAC)
Correct answer:PodSecurityPolicy (PSP)
Explanation:PodSecurityPolicy (PSP) was the precursor to Pod Security Standards (PSS). PSP was deprecated and replaced by PSS and the PodSecurity admission controller to improve pod security management in Kubernetes clusters.


Which of the following statements about static pods in Kubernetes are true? (Select all that apply)
They are managed directly by the kubelet on a node
They are defined in the API server and stored in etcd
They are useful for running critical system components
They are automatically rescheduled on other nodes if the node fails
They can be updated using kubectl commands
Correct answer:They are managed directly by the kubelet on a node, They are useful for running critical system components
Explanation:Static pods are defined by placing pod manifest files directly on a nodeâ€™s filesystem and are managed by the kubelet on that node, not through the API server or etcd. They are useful for running critical system components that must run on a specific node. Static pods are not rescheduled automatically if the node fails, and they cannot be updated via kubectl since they are not managed through the Kubernetes API.


In Kubernetes security best practices, what is the primary security benefit of configuring a container's root filesystem as read-only?
Improved container startup performance
Reduced container image storage requirements
Enhanced security by preventing malicious filesystem modifications
Enables cross-container file sharing capabilities
Simplifies rolling updates for containerized applications
Correct answer:Enhanced security by preventing malicious filesystem modifications
Explanation:A read-only root filesystem (configured via securityContext.readOnlyRootFilesystem) prevents attackers from modifying system files, installing malware, or writing to sensitive directories, even if they gain shell access. This security hardening measure is recommended by CIS Kubernetes Benchmarks and Kubernetes security best practices.


How can you force delete a Kubernetes pod that is stuck in the 'Terminating' state?
Run 'kubectl delete pod <pod-name>' normally
Restart the kubelet service on the node
Run 'kubectl delete pod <pod-name> --force --grace-period=0'
Delete the node where the pod is running
Edit the pod's YAML to remove finalizers
Correct answer:Run 'kubectl delete pod <pod-name> --force --grace-period=0'
Explanation:A pod stuck in 'Terminating' state can be force deleted using the command 'kubectl delete pod <pod-name> --force --grace-period=0'. This command bypasses the graceful termination period and forcibly removes the pod from the API server, even if the pod's containers are still running. Restarting the kubelet or deleting the node can be disruptive and are not recommended first steps. Editing the pod's YAML to remove finalizers can help if finalizers are blocking deletion, but the force delete command is the standard immediate solution.


Select all that apply: Which Kubernetes object(s) allow you to define a set of rules for validating or mutating admission requests?
ValidatingWebhookConfiguration
MutatingWebhookConfiguration
AdmissionController
CustomResourceDefinition
WebhookPolicy
Correct answer:ValidatingWebhookConfiguration, MutatingWebhookConfiguration
Explanation:`ValidatingWebhookConfiguration` and `MutatingWebhookConfiguration` are used to integrate admission webhooks that validate or mutate admission requests. Option 2 (`AdmissionController`) is a general term for the mechanism but not a specific Kubernetes object. Option 3 (`CustomResourceDefinition`) is used to define custom resources, and Option 4 (`WebhookPolicy`) is not a valid Kubernetes object.


What is the primary function of Kubernetes admission controllers in enforcing compliance within a cluster?
Scheduling pods onto nodes based on resource requirements
Managing persistent storage volumes for stateful applications
Intercepting API requests to validate and enforce policies before object creation or modification
Acting as a certificate authority for cluster nodes
Providing a graphical user interface for cluster configuration
Correct answer:Intercepting API requests to validate and enforce policies before object creation or modification
Explanation:Kubernetes admission controllers are plugins that intercept API requests to the Kubernetes API server before objects are persisted. They validate and enforce policies such as security, resource quotas, and compliance rules, ensuring that only compliant configurations are admitted into the cluster. Scheduling pods, managing storage, acting as a certificate authority, or providing GUIs are handled by other Kubernetes components and tools.


What is a common mitigation strategy for 'Spoofing' threats?
Implementing proper authentication mechanisms
Using encryption for data at rest
Implementing audit logging
Applying rate limiting
Running processes as root
Correct answer:Implementing proper authentication mechanisms
Explanation:Spoofing threats can be mitigated by implementing robust authentication mechanisms. These mechanisms help verify the identity of users or systems, reducing the risk of impersonation. While encryption (option 2) and audit logging (option 3) are important security practices, they do not directly address spoofing. Rate limiting (option 4) is more relevant to Denial of Service attacks, and running processes as root (option 5) increases security risks.


In Kubernetes RBAC, what does a Role define?
A set of users and their passwords
Permissions within a namespace
Network policies for pods
Global cluster-wide permissions
Resource quotas for a project
Correct answer:Permissions within a namespace
Explanation:A Role in Kubernetes RBAC defines a set of permissions that are applicable within a specific namespace. This allows for fine-grained control over resources within that namespace.


Which combination of pod configurations can allow a compromised Kubernetes pod to access and potentially modify the host system? (Select all that apply)
Running the pod in privileged mode
Mounting the host filesystem into the pod
Using host networking in the pod
Dropping all Linux capabilities from the pod
Running the pod as a non-root user
Correct answer:Running the pod in privileged mode, Mounting the host filesystem into the pod, Using host networking in the pod
Explanation:Running a pod in privileged mode grants it broad permissions, including the ability to access host resources and perform actions that can compromise the host system. Mounting the host filesystem into the pod exposes sensitive files and allows the pod to read or modify host data, which is a significant security risk. Using host networking gives the pod direct access to the host's network stack, increasing the risk of network-based attacks or eavesdropping. In contrast, dropping all Linux capabilities and running as a non-root user are security best practices that reduce the attack surface and limit the pod's ability to affect the host, making these options incorrect.


Which securityContext configuration field enables privileged container mode in Kubernetes pods?
allowPrivilegeEscalation: true
runAsPrivileged: true
privileged: true
capabilities.add: ["ALL"]
securityContext.privilegedMode: enabled
Correct answer:privileged: true
Explanation:The privileged: true setting gives the container full access to host devices and capabilities, equivalent to root privileges on the host. This dangerous configuration should be avoided in production, as emphasized in Kubernetes security documentation and CIS Benchmarks. Privileged containers bypass most security controls and namespace restrictions.


What is a primary benefit of using Namespaces in Kubernetes?
Improves application performance
Provides a mechanism for resource isolation and organization
Simplifies container image management
Automatically scales applications based on load
Eliminates the need for Pods
Correct answer:Provides a mechanism for resource isolation and organization
Explanation:Namespaces in Kubernetes provide a way to logically separate and isolate resources within a cluster, enabling multiple teams or projects to share the same cluster without resource conflicts. They help organize cluster resources and apply resource quotas or policies per namespace. Namespaces do not directly improve application performance, simplify container images, automatically scale applications, or replace Pods, which are fundamental units of deployment in Kubernetes.


Which of the following controllers is NOT managed by the kube-controller-manager in Kubernetes?
Node Controller
Endpoint Controller
Ingress Controller
Deployment Controller
Service Account Controller
Correct answer:Ingress Controller
Explanation:The Ingress Controller is not part of the kube-controller-manager; it is typically deployed separately as a pod or set of pods to manage external HTTP/S traffic routing. The kube-controller-manager manages controllers such as Node, Endpoint, Deployment, and Service Account Controllers internally.


What is the primary purpose of Grafana in IT operations?
Managing code version control
Automating continuous integration pipelines
Visualizing and monitoring metrics through dashboards
Enforcing network security policies
Managing user identities and access
Correct answer:Visualizing and monitoring metrics through dashboards
Explanation:Grafana is an open-source platform used primarily for creating dashboards that visualize metrics and monitoring data from various sources. It helps IT teams observe system performance and troubleshoot issues. It is not used for version control, continuous integration, network security enforcement, or identity management.


Which command lists all processes currently listening on TCP and UDP ports on a Linux system, including the associated process IDs?
sudo netstat -tulpn
sudo lsof -i
sudo ss -tulw
sudo ps aux | grep LISTEN
sudo netstat -an
Correct answer:sudo netstat -tulpn
Explanation:The command 'sudo netstat -tulpn' lists all listening TCP and UDP ports along with the process IDs and names that are using those ports. The flags mean: '-t' for TCP, '-u' for UDP, '-l' for listening sockets, '-p' to show process info, and '-n' to show numeric addresses. 'sudo lsof -i' also shows network connections but is less focused on listening ports specifically. 'sudo ss -tulw' shows listening sockets but may omit process names without additional flags. 'sudo ps aux | grep LISTEN' is incorrect because 'LISTEN' is not a process name but a socket state. 'sudo netstat -an' shows all connections but does not include process information.


What is the effect of applying a Kubernetes NetworkPolicy that does not select any pods in the cluster?
It has no effect on network traffic within the cluster
It denies all network traffic to and from all pods
It allows all network traffic by default
It causes an error in the network plugin
It only affects newly created pods after the policy is applied
Correct answer:It has no effect on network traffic within the cluster
Explanation:A NetworkPolicy that does not select any pods effectively applies to no pods and therefore has no impact on network traffic. It neither denies nor allows traffic beyond the cluster's default behavior. It does not cause errors in the network plugin, nor does it selectively affect only new pods. NetworkPolicies only affect pods that they select.


In a Kubernetes NetworkPolicy specification, which field defines the allowed egress destinations for Pods?
ingress
egress
to
from
destinations
Correct answer:egress
Explanation:The 'egress' field in a NetworkPolicy spec specifies the rules that allow outbound traffic from selected Pods to specified destinations. The 'ingress' field defines allowed inbound traffic. 'to' is a subfield inside 'egress' rules specifying destination peers but is not the top-level field defining egress rules. 'from' is used in ingress rules to specify source peers. 'destinations' is not a valid field in NetworkPolicy.


What command is used to check the version of the Kubernetes API server?
'kubectl version'
'kubectl get apiserver'
'kube-apiserver --version'
'kubectl cluster-info'
'kubectl describe componentstatus'
Correct answer:'kubectl version'
Explanation:The `kubectl version` command is used to display the client and server versions of Kubernetes. This is useful for ensuring compatibility and identifying potential version mismatches.


How can you restrict a Kubernetes user to create resources only within a specific namespace?
Assign the user the cluster-admin role
Create a Role and RoleBinding scoped to that namespace for the user
Modify the kube-apiserver configuration to limit user access
Create a NetworkPolicy that restricts user actions
Set a resource quota on the namespace to limit resource creation
Correct answer:Create a Role and RoleBinding scoped to that namespace for the user
Explanation:To restrict a user to create resources only within a specific namespace, you create a Role that defines the allowed permissions within that namespace and bind it to the user via a RoleBinding. Assigning cluster-admin grants full cluster-wide permissions, which is too broad. Modifying kube-apiserver configuration is not practical for per-user namespace restrictions. NetworkPolicies control pod network traffic, not user permissions. Resource quotas limit resource consumption but do not restrict user actions.


Which Kubernetes object is used to manage stateful applications that require persistent storage and network identities?
Deployment
StatefulSet
ReplicaSet
DaemonSet
Job
Correct answer:StatefulSet
Explanation:StatefulSets are used to manage stateful applications that require persistent storage and network identities. Unlike Deployments, StatefulSets maintain a stable network identity and storage for each pod, making them suitable for applications like databases.


What is a common mitigation strategy for 'Tampering' threats in Kubernetes?
Implementing strong authentication
Using digital signatures and checksums
Applying redundant servers
Implementing multi-factor authentication
Enforcing password complexity
Correct answer:Using digital signatures and checksums
Explanation:Using digital signatures and checksums is an effective way to mitigate Tampering threats. These mechanisms ensure data integrity by verifying that data has not been altered during transmission or storage.


After generating a Certificate Signing Request (CSR) and having it signed by the Kubernetes cluster Certificate Authority (CA), how do you configure kubectl to use the new client certificate and key for the user 'alice'?
kubectl config set-credentials alice --client-certificate=alice.crt --client-key=alice.key
kubectl create secret tls alice --cert=alice.crt --key=alice.key
kubectl config set-context alice-context --cluster=kubernetes --user=alice
kubectl apply -f alice.crt
kubectl certificate approve alice
Correct answer:kubectl config set-credentials alice --client-certificate=alice.crt --client-key=alice.key
Explanation:To configure kubectl to use a new client certificate for a user, you use the command 'kubectl config set-credentials' specifying the user name along with the paths to the client certificate and private key files. This updates the kubeconfig file with the user's credentials. The other options do not configure kubectl credentials: 'kubectl create secret tls' creates a TLS secret in Kubernetes but does not affect kubectl client config; 'kubectl config set-context' sets the context but does not set credentials; 'kubectl apply -f' applies Kubernetes resources and is unrelated; 'kubectl certificate approve' approves a CSR but does not configure kubectl.


What is the primary function of the ImagePolicyWebhook admission controller in Kubernetes?
To scan container images for vulnerabilities during runtime
To enforce custom policies on container images during admission to the cluster
To cache container images locally for faster deployment
To automatically update container images to the latest version
To log all image pull requests for auditing purposes
Correct answer:To enforce custom policies on container images during admission to the cluster
Explanation:The ImagePolicyWebhook admission controller intercepts Pod creation requests and enforces policies on container images before they are admitted into the cluster, such as validating image signatures or restricting images from untrusted registries. It does not perform runtime vulnerability scanning, caching, automatic updates, or logging image pulls, which are handled by other tools or controllers.


Which compliance framework is primarily recognized for emphasizing continuous policy review and network traffic monitoring to enhance security in cloud environments?
NIST Cybersecurity Framework
SOC 1 Type II
ISO/IEC 27017
FedRAMP
COBIT
Correct answer:NIST Cybersecurity Framework
Explanation:The NIST Cybersecurity Framework is widely adopted for managing cybersecurity risks and emphasizes continuous monitoring, including ongoing policy review and network traffic analysis, to effectively manage and mitigate risks in cloud and other environments. SOC 1 Type II focuses on financial controls, ISO/IEC 27017 provides guidelines for cloud security controls but does not emphasize continuous monitoring to the same extent, FedRAMP is a U.S. government program for cloud security authorization, and COBIT is a governance framework for IT management rather than specific continuous monitoring practices.


Which kubectl command correctly creates a generic secret named 'db-secret' with a key 'password' and the value 'S3cr3t!'?
kubectl create secret generic db-secret --password='S3cr3t!'
kubectl create secret db-secret --from-literal='password=S3cr3t!'
kubectl create secret generic db-secret --from-literal=password=S3cr3t!
kubectl create secret tls db-secret --key='S3cr3t!'
kubectl create secret docker-registry db-secret --password='S3cr3t!'
Correct answer:kubectl create secret generic db-secret --from-literal=password=S3cr3t!
Explanation:The correct command uses 'kubectl create secret generic' with the '--from-literal' flag to specify a key-value pair for the secret. The syntax is: kubectl create secret generic db-secret --from-literal=password=S3cr3t!. The other options are incorrect because '--password' is not a valid flag for generic secrets, 'kubectl create secret' without 'generic' is incomplete, 'tls' secrets require certificate and key files, and 'docker-registry' secrets are for Docker credentials, not arbitrary key-value pairs.


Which kubectl command is used to check the health status and readiness of all nodes in a Kubernetes cluster?
kubectl get nodes
kubectl describe nodes
kubectl health nodes
kubectl check nodes
kubectl status nodes
Correct answer:kubectl get nodes
Explanation:'kubectl get nodes' lists all nodes in the cluster along with their status, including whether they are Ready or NotReady, which indicates their health and availability. While 'kubectl describe nodes' provides detailed information about each node, including conditions and events, the primary command to quickly check node health is 'kubectl get nodes'. The other commands are not valid kubectl commands.


What is the role of the Service Account Controller in Kubernetes?
Manages the creation and lifecycle of service accounts and their associated authentication tokens
Controls access permissions to external services from the cluster
Assigns network policies to service accounts for traffic control
Manages the lifecycle and scaling of Kubernetes services
Handles automatic scaling of deployments based on load
Correct answer:Manages the creation and lifecycle of service accounts and their associated authentication tokens
Explanation:The Service Account Controller, part of the kube-controller-manager, is responsible for creating service accounts and generating the associated authentication tokens used by pods to interact securely with the Kubernetes API. It does not control external service access, assign network policies, manage service lifecycles, or handle deployment scaling.


Which command is used to approve a CertificateSigningRequest (CSR) in Kubernetes?
kubectl sign csr <csr-name>
kubectl create csr <csr-name>
kubectl certificate approve <csr-name>
kubectl approve csr <csr-name>
kubectl csr approve <csr-name>
Correct answer:kubectl certificate approve <csr-name>
Explanation:The correct command to approve a CertificateSigningRequest (CSR) in Kubernetes is 'kubectl certificate approve <csr-name>'. This command instructs the certificate signing controller to approve the CSR, allowing the requested certificate to be issued. Other options like 'kubectl create' are used for creating resources, while 'kubectl sign', 'kubectl approve csr', and 'kubectl csr approve' are invalid commands.


Which Kubernetes Secret type is required when configuring TLS termination for an Ingress resource?
Opaque
kubernetes.io/tls
Docker Registry
Basic Auth
SSH Key
Correct answer:kubernetes.io/tls
Explanation:For configuring TLS termination in an Ingress resource, a Secret of type 'kubernetes.io/tls' is required. This type of Secret must contain 'tls.crt' and 'tls.key' entries with PEM-encoded certificates.


Which kubectl command allows you to view the events occurring in a Kubernetes cluster, such as pod lifecycle changes and errors, using the most current recommended method?
kubectl get events
kubectl describe events
kubectl list events
kubectl events
kubectl get logs
Correct answer:kubectl events
Explanation:'kubectl events' is the newer and recommended command for viewing events in a Kubernetes cluster, including pod lifecycle changes, warnings, and errors. It provides enhanced filtering and output options compared to the traditional 'kubectl get events'. 'kubectl describe events' is not a valid command; 'kubectl describe' is used with specific resource types but not directly with 'events'. 'kubectl list events' is not a valid command. 'kubectl get logs' is used to fetch logs from pods, not cluster events.


Why is Infrastructure as Code (IaC) important for maintaining compliance in Kubernetes environments?
It replaces the need for container registries
It enables the manual application of security patches
It provides a script-free approach to deployment
It ensures repeatable and auditable deployments aligned with security best practices
It automatically detects vulnerabilities without scanning
Correct answer:It ensures repeatable and auditable deployments aligned with security best practices
Explanation:Infrastructure as Code (IaC) tools like Terraform, Ansible, or CloudFormation enable automated, repeatable, and auditable provisioning of infrastructure and Kubernetes resources. This consistency helps enforce security best practices, reduces human error, and supports compliance requirements by maintaining version-controlled infrastructure definitions. IaC does not replace container registries, nor does it provide script-free deployment or automatic vulnerability detection without scanning.


How can you verify that Pod Security Admission (PSA) is actively enforcing security policies within a specific Kubernetes namespace?
Check the API server logs for PSA-related entries
Attempt to create a pod that violates the PSA policy and observe the outcome
Inspect the kubelet configuration on the nodes
Review the scheduler's event logs for pod scheduling issues
Use the command 'kubectl get psa' to check enforcement status
Correct answer:Attempt to create a pod that violates the PSA policy and observe the outcome
Explanation:The most direct way to verify that Pod Security Admission is enforcing policies is to try creating a pod that violates the defined PSA policy in the target namespace. If the pod creation is denied, it confirms that PSA is active and enforcing the policies. Checking API server logs or scheduler events may provide indirect clues but are less reliable for verification. The kubelet configuration does not control PSA enforcement, and 'kubectl get psa' is not a valid command for checking PSA status.


In Kubernetes NetworkPolicy configuration, what podSelector configuration creates a default-deny-all policy that applies to all pods in a namespace?
Empty selector: {}
Wildcard selector: '*'
Omitted podSelector field
Null value: podSelector: null
Label-based exclusion selector
Correct answer:Empty selector: {}
Explanation:An empty podSelector ({}) matches all pods in the namespace, while omitting the field would make the policy ineffective. This configuration is critical for implementing namespace-wide default-deny policies, as documented in Kubernetes network policy best practices and the CIS Kubernetes Benchmark.


Which open-source tool specializes in static security analysis of Kubernetes manifests through vulnerability scanning and policy checks?
kube-hunter (penetration testing tool)
kubesec (security risk analysis)
kubectl (cluster management CLI)
kubelet (node agent)
etcdctl (key-value store client)
Correct answer:kubesec (security risk analysis)
Explanation:Kubesec analyzes Kubernetes manifests for security misconfigurations, providing risk scores and remediation guidance. It checks for common issues like privileged containers, missing security contexts, and insecure capabilities. Other tools serve different purposes: kube-hunter (option 1) tests live clusters, kubectl (option 3) manages resources, kubelet (option 4) runs pods, and etcdctl (option 5) interacts with etcd.


Which of the following is a recommended best practice when configuring container registries to ensure security?
Use HTTP instead of HTTPS for performance
Allow anonymous access
Use authenticated and encrypted connections (HTTPS)
Disable TLS verification
Expose the registry publicly without restrictions
Correct answer:Use authenticated and encrypted connections (HTTPS)
Explanation:Using HTTPS with authentication ensures that communication with the container registry is encrypted and access is controlled, preventing unauthorized access and tampering. Using HTTP or disabling TLS verification exposes the registry to interception and attacks. Allowing anonymous or unrestricted public access increases the risk of unauthorized image uploads or downloads.


Which command is used to generate a 2048-bit RSA private key for a new Kubernetes user?
openssl genrsa -out user.key 2048
openssl rsa -in user.key -out user.key
openssl req -newkey rsa:2048 -nodes -keyout user.key -out user.csr
kubectl create secret tls user.key
ssh-keygen -t rsa -b 2048 -f user.key
Correct answer:openssl genrsa -out user.key 2048
Explanation:The command 'openssl genrsa -out user.key 2048' generates a 2048-bit RSA private key and saves it to 'user.key'. The second command attempts to process an existing key but does not generate a new one. The third command generates a new private key and a certificate signing request (CSR), not just the key. 'kubectl create secret tls' is for creating TLS secrets, not generating keys. 'ssh-keygen' generates SSH keys, which are different from the keys used for Kubernetes user certificates.


How do you create a Kubernetes namespace named 'dev'?
kubectl create namespace dev
kubectl apply namespace dev
kubectl generate namespace dev
kubectl make namespace dev
kubectl new namespace dev
Correct answer:kubectl create namespace dev
Explanation:To create a Kubernetes namespace named 'dev', you use the command 'kubectl create namespace dev'. This command directly creates a new namespace in your cluster.


Which of the following steps are necessary to enable audit logging in Kubernetes? (Select all that apply)
Create an audit policy file
Configure the kubelet with audit flags
Add '--audit-policy-file' flag to API server
Restart the kube-controller-manager
Specify '--audit-log-path' in the API server configuration
Correct answer:Create an audit policy file, Add '--audit-policy-file' flag to API server, Specify '--audit-log-path' in the API server configuration
Explanation:To enable audit logging in Kubernetes, you must create an audit policy file, specify this file using the '--audit-policy-file' flag in the API server configuration, and define the log path using '--audit-log-path'. These steps ensure that audit logs are properly configured and stored.


Which compliance standard is specifically relevant for organizations handling Protected Health Information (PHI) in the healthcare sector?
HIPAA
SOX
ISO 9001
GDPR
MITRE ATT&CK
Correct answer:HIPAA
Explanation:HIPAA is crucial for healthcare organizations as it contains security and privacy rules that protect PHI. It is particularly relevant when deploying healthcare solutions on cloud platforms like Kubernetes, ensuring compliance with PHI handling regulations.


Which authentication mechanisms are commonly used by kubeadm during Kubernetes cluster bootstrapping? (Select all that apply)
TLS certificates
Token-based authentication
OAuth tokens
Static passwords
Biometric authentication
Correct answer:TLS certificates, Token-based authentication
Explanation:kubeadm primarily uses TLS certificates and token-based authentication mechanisms to secure communication and authenticate components during cluster bootstrapping. TLS certificates are used for API server and client authentication, while bootstrap tokens facilitate node joining.


Why are 'distroless' container images recommended for use in production environments?
They include a shell for debugging
They have a larger attack surface
They are minimal images that reduce vulnerabilities
They support all Linux distributions
They are required by Kubernetes
Correct answer:They are minimal images that reduce vulnerabilities
Explanation:'Distroless' images contain only the application and its runtime dependencies, excluding package managers, shells, and other unnecessary tools. This minimalism reduces the attack surface and potential vulnerabilities. They do not include shells, which can make debugging harder but improves security. They are not required by Kubernetes and do not inherently support all Linux distributions.


What is the primary purpose of the NIST Cybersecurity Framework (CSF)?
A universal law for international data privacy
A set of risk management guidelines to identify, protect, detect, respond to, and recover from cyber threats
A standard for container registry licensing
A government mandate exclusively for financial institutions
A platform for automating software supply chain security
Correct answer:A set of risk management guidelines to identify, protect, detect, respond to, and recover from cyber threats
Explanation:The NIST Cybersecurity Framework (CSF) is designed as a voluntary framework to help organizations manage and reduce cybersecurity risk. It provides a comprehensive set of guidelines and best practices structured around five core functions: Identify, Protect, Detect, Respond, and Recover. This framework is not a law or mandate but a flexible tool to improve cybersecurity posture across industries. The other options are incorrect because they either misrepresent the framework's scope or confuse it with unrelated standards or platforms.


Which Kubernetes Admission Controller was deprecated and replaced by Pod Security Admission in Kubernetes version 1.25?
PodSecurityPolicy
NodeRestriction
AlwaysPullImages
NamespaceLifecycle
LimitRanger
Correct answer:PodSecurityPolicy
Explanation:PodSecurityPolicy was deprecated in Kubernetes version 1.25 and replaced by the Pod Security Admission (PSA) controller. The PSA controller provides a simpler and more flexible way to enforce pod security standards, aligning with Kubernetes' evolving security model. Other options, such as NodeRestriction, AlwaysPullImages, NamespaceLifecycle, and LimitRanger, are not related to this deprecation.


Which tool is specifically designed to benchmark a Kubernetes cluster against the Center for Internet Security (CIS) Kubernetes Benchmark best practices?
kube-bench
kube-hunter
kubesec
kube-score
kube-linter
Correct answer:kube-bench
Explanation:kube-bench is a tool that runs checks against the CIS Kubernetes Benchmark, which is a set of best practices for securing Kubernetes clusters. It audits cluster components and configuration to identify security issues. Other tools like kube-hunter focus on penetration testing, kubesec and kube-score analyze resource configurations but do not perform CIS benchmark compliance checks, and kube-linter is a static analysis tool for Kubernetes manifests.


In a Kubernetes container's securityContext, which field prevents processes from gaining elevated privileges through privilege escalation?
runAsUser: 0
privileged: false
allowPrivilegeEscalation: false
runAsNonRoot: false
readOnlyRootFilesystem: true
Correct answer:allowPrivilegeEscalation: false
Explanation:The 'allowPrivilegeEscalation' field, when set to false, prevents a process from gaining more privileges than its parent process, effectively blocking privilege escalation attacks. Setting 'privileged' to false disables privileged mode but does not specifically prevent privilege escalation. 'runAsUser: 0' runs the container as root, which does not prevent privilege escalation. 'runAsNonRoot: false' allows running as root, so it doesn't prevent privilege escalation. 'readOnlyRootFilesystem: true' restricts filesystem writes but does not control privilege escalation.


How do you configure Kubernetes to use a specific container runtime, such as containerd, on a node?
Specify the container runtime in the pod specification
Set the '--container-runtime-endpoint' flag in the kubelet configuration
Configure the container runtime in the kube-proxy settings
Rely on automatic detection; no manual configuration is required
Set an environment variable on the master node to specify the runtime
Correct answer:Set the '--container-runtime-endpoint' flag in the kubelet configuration
Explanation:The kubelet is responsible for managing the container runtime on each node. To specify a container runtime like containerd, you configure the kubelet with the '--container-runtime-endpoint' flag, which points to the runtime's socket endpoint. This setting ensures kubelet communicates with the correct container runtime. The pod specification does not control the runtime used by the node. Kube-proxy manages networking and is unrelated to container runtimes. Automatic detection is not reliable for runtime selection. Environment variables on the master node do not affect node-level runtime configuration.


What is the primary purpose of the 'kubectl config' command in Kubernetes?
To configure Kubernetes cluster settings
To manage kubeconfig files and contexts
To update deployment configurations
To set node configurations
To modify pod specifications
Correct answer:To manage kubeconfig files and contexts
Explanation:'kubectl config' is used to view and modify kubeconfig files, which store cluster connection information, user credentials, and contexts. This command helps manage multiple clusters and user access configurations. It does not directly configure cluster settings, deployments, nodes, or pods.


Which Kubernetes object defines cluster-wide permissions and roles that can be assigned to users or service accounts?
Role
ClusterRole
RoleBinding
ClusterRoleBinding
ServiceAccount
Correct answer:ClusterRole
Explanation:'ClusterRole' defines permissions that apply across the entire Kubernetes cluster, allowing for cluster-wide access control. In contrast, 'Role' defines permissions scoped to a specific namespace. 'RoleBinding' and 'ClusterRoleBinding' are used to assign Roles or ClusterRoles to users or service accounts but do not define permissions themselves. 'ServiceAccount' represents an identity for processes running in Pods, not permissions.


Why is it critical to verify the checksums of Kubernetes binaries after downloading them?
To ensure they are the latest version
To verify the integrity and authenticity of the binaries
To improve their performance
To check for syntax errors
To enable automatic updates
Correct answer:To verify the integrity and authenticity of the binaries
Explanation:Verifying the checksums of Kubernetes binaries ensures that the files have not been tampered with or corrupted during download, confirming their integrity and authenticity. This protects against malicious modifications or accidental corruption. Checking for the latest version, performance improvements, syntax errors, or enabling automatic updates are unrelated to checksum verification.


What command is used to create a Kubernetes namespace named 'production'?

Correct answer:kubectl create namespace production
Explanation:The command 'kubectl create namespace production' is used to create a new namespace in a Kubernetes cluster. Namespaces provide a way to divide cluster resources between multiple applications or teams. They are essential for organizing and isolating resources within a cluster.


What measures can you take to prevent a container from running as the root user in Kubernetes?
Set 'runAsUser: 0' in the security context
Use a Pod Security Admission to enforce non-root user requirements
It is not possible to prevent this
Modify the container image to exclude root user privileges
Set 'allowPrivilegeEscalation: true' in the security context
Correct answer:Use a Pod Security Admission to enforce non-root user requirements
Explanation:To enhance security, you can use Pod Security Admission to enforce that containers run as non-root users. This prevents potential privilege escalation attacks. Option 1 ('runAsUser: 0') explicitly allows running as root, which is insecure. Option 3 is incorrect because Kubernetes provides mechanisms to enforce non-root users. Option 4 may reduce root privileges but does not enforce non-root execution. Option 5 ('allowPrivilegeEscalation: true') enables privilege escalation, which contradicts the goal of preventing root access.


Select all that apply: Which command(s) can be used to list all ServiceAccounts in the 'dev' namespace?
kubectl get sa -n dev
kubectl get serviceaccount -A
kubectl get serviceaccounts --namespace=dev
kubectl describe serviceaccounts -n dev
kubectl list sa dev
Correct answer:kubectl get sa -n dev, kubectl get serviceaccounts --namespace=dev, kubectl describe serviceaccounts -n dev
Explanation:The commands `kubectl get sa -n dev`, `kubectl get serviceaccounts --namespace=dev`, and `kubectl describe serviceaccounts -n dev` all list ServiceAccounts in the 'dev' namespace. The first two provide a summary list, while `kubectl describe` provides detailed information about each ServiceAccount. Option 1 (`kubectl get serviceaccount -A`) lists ServiceAccounts across all namespaces, and Option 4 (`kubectl list sa dev`) is not a valid `kubectl` command.


In the STRIDE threat model, which category best describes an attacker exploiting a buffer overflow to gain root access?

Correct answer:Elevation of Privileges
Explanation:Exploiting a buffer overflow to gain root access is classified as an Elevation of Privileges threat because it involves escalating an attacker's privileges to access sensitive resources. This is a critical threat as it can lead to full system compromise.


What is the primary focus of the NSA/CISA Kubernetes Hardening Guidance?
Using insecure container registries for testing purposes
Skipping vulnerability scanning to reduce operational overhead
Securing supply chain components and minimizing container privileges
Disabling TLS to accelerate deployment processes
Automatically approving all configuration changes to enhance agility
Correct answer:Securing supply chain components and minimizing container privileges
Explanation:The NSA/CISA Kubernetes Hardening Guidance emphasizes securing the software supply chain and minimizing container privileges to reduce attack surfaces. This includes practices like signing container images, scanning for vulnerabilities, and implementing least privilege access controls.


Which security development framework explicitly incorporates threat modeling and validation phases to ensure secure software development?
Microsoft Security Development Lifecycle (SDL)
Open Container Initiative (OCI) Standard
JWT Token Compliance Framework
HTTP Strict Transport Security (HSTS)
NIST Special Publication 800-63
Correct answer:Microsoft Security Development Lifecycle (SDL)
Explanation:The Microsoft Security Development Lifecycle (SDL) is a comprehensive framework that integrates security at every phase of software development, including explicit phases for requirements definition, threat modeling, mitigation strategies, and validation. This approach helps identify and address security risks early. Other options either focus on standards for container formats (OCI), token compliance, transport security policies (HSTS), or identity proofing guidelines (NIST SP 800-63), which do not specifically include threat modeling and validation phases within software development.


Which Kubernetes tool uses a webhook-based admission controller to enforce compliance policies?
Kube-proxy
Prometheus
Open Policy Agent (OPA) Gatekeeper
kubectl
MetalLB
Correct answer:Open Policy Agent (OPA) Gatekeeper
Explanation:Open Policy Agent (OPA) Gatekeeper integrates with Kubernetes as a webhook admission controller, allowing administrators to enforce custom policies on Kubernetes resources during creation or update. This enables automated compliance enforcement. Kube-proxy manages network proxying, Prometheus is for monitoring, kubectl is a CLI tool, and MetalLB provides load balancing; none of these enforce policies via admission webhooks.


What command is used to list all pods across all namespaces in a Kubernetes cluster?
'kubectl get pods'
'kubectl get pods --all'
'kubectl get pods -A'
'kubectl get pods --namespaces'
'kubectl get all-pods'
Correct answer:'kubectl get pods -A'
Explanation:The '-A' flag is used with 'kubectl get pods' to list resources in all namespaces. This is a shorthand for '--all-namespaces', which ensures that pods from every namespace are displayed.


Which Kubernetes resources, if compromised, could lead to significant security breaches and should be audited carefully? (Select all that apply)
Secrets
ConfigMaps
Pods
ServiceAccounts
PersistentVolumes
Correct answer:Secrets, ServiceAccounts
Explanation:Secrets and ServiceAccounts are considered sensitive Kubernetes resources because they often contain confidential information such as credentials, API keys, and tokens. If compromised, these resources can lead to unauthorized access, privilege escalation, or data breaches. ConfigMaps generally contain non-sensitive configuration data and are less critical from a security perspective. While Pods and PersistentVolumes are important, they are not typically audited for sensitive information unless they handle sensitive data explicitly.


What is the primary purpose of Botkube in a Kubernetes environment?
To provide an integrated container build system
To automate Slack-based alerts for compliance and security events
To serve as an API gateway for microservices
To orchestrate container autoscaling across clusters
To replace kubelet on worker nodes
Correct answer:To automate Slack-based alerts for compliance and security events
Explanation:Botkube is a Kubernetes monitoring tool that integrates with messaging platforms like Slack, Microsoft Teams, or Mattermost to send real-time alerts about cluster events, compliance issues, and security incidents. It helps teams stay informed without constantly monitoring dashboards. It is not a container build system, API gateway, autoscaling orchestrator, or a replacement for kubelet.


Which securityContext field makes a container's root filesystem read-only to prevent modifications?
readOnlyFileSystem
readOnlyRootFilesystem
immutableRoot
filesystemReadonly
noWriteFilesystem
Correct answer:readOnlyRootFilesystem
Explanation:The 'readOnlyRootFilesystem' field in a container's securityContext makes the root filesystem read-only, preventing any modifications and enhancing container security.


What does the term 'container breakout' refer to in the context of container security?
When a container fails to start properly
A container exceeding its allocated resource limits
An attack where an attacker escapes container isolation to gain access to the host system
Scaling a container beyond its maximum configured replicas
Migrating a container to a different node in the cluster
Correct answer:An attack where an attacker escapes container isolation to gain access to the host system
Explanation:A container breakout occurs when an attacker exploits vulnerabilities to escape the isolation boundaries of a container and gain unauthorized access to the underlying host system. This compromises the host's security and can lead to privilege escalation. Other options describe container lifecycle or resource management issues, which are unrelated to security breaches involving isolation escape.


What is the primary function of the 'kubeadm' tool in Kubernetes?
To manage container images
To bootstrap Kubernetes clusters
To monitor cluster health
To deploy applications to the cluster
To manage network policies
Correct answer:To bootstrap Kubernetes clusters
Explanation:The `kubeadm` tool is used to bootstrap a Kubernetes cluster, making it easier to set up and manage clusters. It automates the installation and configuration process, ensuring that all necessary components are properly initialized.


Which of the following lists the five core functions of the NIST Cybersecurity Framework?
Monitor, Map, Maintain, Minimise, and Mutate
Identify, Protect, Detect, Respond, and Recover
Review, Replace, Retract, Renew, and Reserve
Discover, Compare, Archive, Document, and Renew
Encrypt, Store, Backup, Alert, and Evaluate
Correct answer:Identify, Protect, Detect, Respond, and Recover
Explanation:The NIST Cybersecurity Framework (CSF) is structured around five core functions: Identify, Protect, Detect, Respond, and Recover. These functions provide a high-level, strategic view of the lifecycle of managing cybersecurity risk. The other options list unrelated or incorrect terms that do not correspond to the NIST CSF core functions.


Which compliance framework is mandatory for U.S. federal agencies or their contractors when hosting government data in cloud environments?
FedRAMP
COSO
ISO 20000
DMARC
SAML
Correct answer:FedRAMP
Explanation:FedRAMP is a government-wide program that provides a standardized approach to security assessment, authorization, and continuous monitoring for cloud products and services used by U.S. federal agencies. It ensures that cloud services meet specific security requirements.


Which Kubernetes resource object is used to request a certificate signing operation via the Kubernetes API?
CertificateRequest
CertificateSigningRequest
CertificateApproval
CertificateSigning
Certificate
Correct answer:CertificateSigningRequest
Explanation:The Kubernetes resource 'CertificateSigningRequest' (CSR) is the official API object used to request a certificate signing operation. Users or components create a CSR object containing a public key and metadata; cluster administrators or automated controllers then approve and sign it. The other options are not valid Kubernetes resource kinds: 'CertificateRequest' and 'CertificateSigning' do not exist as Kubernetes resources; 'CertificateApproval' is not a resource but an action; 'Certificate' is not a Kubernetes resource for CSRs.


Which STRIDE category is primarily concerned with service availability?
Spoofing
Tampering
Denial of Service
Information Disclosure
Elevation of Privileges
Correct answer:Denial of Service
Explanation:Denial of Service (DoS) is the STRIDE category focused on making services unavailable. This can be achieved through various means, such as overwhelming a system with requests or disrupting network connectivity. The other options involve different types of threats: impersonation (Spoofing), data modification (Tampering), unauthorized data access (Information Disclosure), and unauthorized privilege escalation (Elevation of Privileges).


If Kubernetes audit logs are stored at '/var/log/kubernetes/audit.log', which command can you use to view these logs in real time?
kubectl logs audit
sudo tail -f /var/log/kubernetes/audit.log
kubectl get events --audit
journalctl -u kube-apiserver
kubectl describe audit-logs
Correct answer:sudo tail -f /var/log/kubernetes/audit.log
Explanation:Audit logs written to a file such as '/var/log/kubernetes/audit.log' can be viewed in real time using the 'tail -f' command with appropriate permissions, hence 'sudo tail -f /var/log/kubernetes/audit.log'. The 'kubectl logs' command is used for container logs, not audit logs stored on the host. 'kubectl get events --audit' and 'kubectl describe audit-logs' are invalid commands. 'journalctl -u kube-apiserver' shows the kube-apiserver service logs but may not include audit logs if they are configured to a separate file.


Which Docker flag allows a container to share the PID namespace with another container named 'container1'?
--pid=host
--pid=container1
--pid=container:container1
--net=container:container1
--namespace=pid:container1
Correct answer:--pid=container:container1
Explanation:The correct flag to share the PID namespace is '--pid=container:container1'. This allows processes in one container to see and interact with processes in the other container.


In a Kubernetes cluster, which component is responsible for assigning pods to specific nodes based on resource requirements and constraints?
kube-apiserver
kube-scheduler
kubelet
kube-controller-manager
etcd
Correct answer:kube-scheduler
Explanation:The kube-scheduler is the component in Kubernetes responsible for scheduling pods onto nodes. It evaluates the resource requirements of the pods (e.g., CPU, memory) and matches them with the available resources on nodes. Other components, such as kube-apiserver, handle API requests; kubelet manages node-level operations; kube-controller-manager handles controllers; and etcd is the key-value store for cluster data.


In Kubernetes, what is the main reason for using namespaces?
To provide network isolation between different applications.
To group and logically isolate resources such as deployments, services, and pods.
To enforce security policies across the entire cluster.
To manage the lifecycle of persistent storage volumes.
To monitor the overall health and performance of the Kubernetes cluster.
Correct answer:To group and logically isolate resources such as deployments, services, and pods.
Explanation:Namespaces in Kubernetes are primarily used to logically divide a cluster into multiple virtual clusters. This allows teams or projects to operate in isolation from one another within the same physical cluster. While namespaces can be used in conjunction with network policies to provide network isolation, their primary purpose is logical grouping and isolation of Kubernetes resources like pods, services, and deployments. They do not inherently enforce security policies or manage storage volumes directly, nor are they primarily for monitoring cluster health.


What happens by default when a container in a Kubernetes pod crashes?
The pod is deleted
Kubernetes does nothing
The kubelet restarts the container
An alert is sent to the administrator
The node is drained
Correct answer:The kubelet restarts the container
Explanation:By default, when a container in a Kubernetes pod crashes, the kubelet will automatically restart it. This behavior can be configured using restart policies.


Which Kubernetes resource is used to run a one-time task?
Deployment
StatefulSet
DaemonSet
Job
ReplicaSet
Correct answer:Job
Explanation:In Kubernetes, a Job is used to run a one-time task. Jobs create one or more pods to perform a task and ensure they complete successfully. They are ideal for batch processing or running tasks that need to complete before the pods are terminated.


What is a significant security risk associated with using an insecure container registry?
Faster image downloads
Increased image caching
Man-in-the-middle attacks leading to compromised images
Improved image availability
Automatic image updates
Correct answer:Man-in-the-middle attacks leading to compromised images
Explanation:Using an insecure container registry exposes images to interception and tampering during transit, enabling man-in-the-middle attacks that can compromise container images. This can lead to running malicious or altered images in production. The other options describe benefits or neutral effects unrelated to security risks.


Which tool serves as a data source for visualizing Kubernetes cluster metrics in Grafana?
Prometheus
Elasticsearch
Kibana
Fluentd
Logstash
Correct answer:Prometheus
Explanation:Prometheus is a robust monitoring and alerting toolkit that collects metrics from Kubernetes clusters. These metrics can be integrated into Grafana as a data source to create dashboards for visualization. While Grafana handles the visualization, Prometheus provides the necessary data. Other options like Elasticsearch, Kibana, Fluentd, and Logstash are primarily used for logging and log analysis, not for collecting or serving metrics directly.


Which Kubernetes resource is designed to manage long-running, stateful applications that require stable network identities and persistent storage?
Deployment
Job
StatefulSet
DaemonSet
ReplicaSet
Correct answer:StatefulSet
Explanation:StatefulSets are used to manage stateful applications that require stable, unique network identifiers and persistent storage across pod restarts. Unlike Deployments or ReplicaSets, which are suited for stateless applications, StatefulSets ensure that pods are created in order and maintain persistent identities. Jobs are for batch or finite tasks, and DaemonSets ensure a pod runs on every node but do not provide stable identities or storage.


Which flag combination with the 'kubectl run' command generates a Pod manifest in YAML format without actually creating the Pod resource in the cluster?
--dry-run=server
--dry-run=client -o yaml
--output=yaml
--generate-only
--no-create
Correct answer:--dry-run=client -o yaml
Explanation:Using '--dry-run=client -o yaml' with 'kubectl run' simulates the creation of the Pod resource on the client side and outputs the manifest in YAML format without sending it to the API server, thus not creating the resource. '--dry-run=server' validates on the server side but does not output YAML by default. '--output=yaml' alone does not prevent creation. '--generate-only' and '--no-create' are deprecated or invalid flags.


Which of the following are the recognized Pod Security Standard levels in Kubernetes? (Select all that apply)
Privileged
Baseline
Restricted
Unrestricted
Default
Correct answer:Privileged, Baseline, Restricted
Explanation:The Pod Security Standards define three levels of security enforcement for pods: Privileged, Baseline, and Restricted. 'Privileged' allows the most permissions, 'Baseline' enforces a moderate security posture suitable for most applications, and 'Restricted' enforces the strictest security controls. 'Unrestricted' and 'Default' are not recognized Pod Security Standard levels.


What does 'Elevation of Privileges' mean in the context of STRIDE?
Gaining access to resources by posing as someone else
Modifying data in transit
Gaining unauthorized access rights that one should not have
Denial of actions performed
Accessing services during downtime
Correct answer:Gaining unauthorized access rights that one should not have
Explanation:Elevation of Privileges refers to the unauthorized acquisition of higher access rights than those originally granted. This can lead to increased capabilities to perform actions that were previously restricted. The other options describe different threats: impersonation (Spoofing), data tampering (Tampering), denial of actions (Denial of Service), and accessing services during maintenance (not a specific STRIDE category).


How can you retrieve a list of all contexts in your kubeconfig file?
kubectl config get-contexts
kubectl get contexts
kubectl config view
kubectl context list
kubectl list contexts
Correct answer:kubectl config get-contexts
Explanation:To list all contexts in your kubeconfig file, you use the command `kubectl config get-contexts`. This command displays all available contexts, which are used to manage different Kubernetes clusters or environments.


What is the default behavior of Kubernetes network traffic when no Network Policies are applied to a namespace?
All ingress and egress traffic is denied
All ingress traffic is denied; egress traffic is allowed
All ingress and egress traffic is allowed
All egress traffic is denied; ingress traffic is allowed
Traffic is allowed only within the namespace
Correct answer:All ingress and egress traffic is allowed
Explanation:By default, Kubernetes allows all ingress and egress traffic to pods if no Network Policies are applied. Network Policies are opt-in and must be explicitly created to restrict traffic. Without any policies, pods can send and receive traffic unrestricted. The other options describe behaviors that occur only when specific Network Policies are configured.


To prevent Pods from accessing the cloud provider's metadata API, which IP address should be blocked in a Kubernetes NetworkPolicy?
0.0.0.0/0
127.0.0.1/32
169.254.169.254/32
255.255.255.255/32
192.168.0.1/32
Correct answer:169.254.169.254/32
Explanation:The IP address 169.254.169.254 is the standard link-local address used by cloud providers (such as AWS, GCP, Azure) for their metadata service. Blocking this IP in a NetworkPolicy prevents Pods from querying sensitive metadata, mitigating risks like metadata service exploitation. Other IPs listed do not correspond to the cloud metadata service.


What is the effect of the 'kubectl rollout undo' command on a Kubernetes deployment?

Correct answer:Rolls back to the previous revision
Explanation:The 'kubectl rollout undo' command reverts a deployment to its previous revision, effectively rolling back any changes made in the most recent update. It does not delete, pause, scale, or update the deployment to a new version but restores the last known good state.


What is the primary purpose of a Cloud Workload Protection Platform (CWPP)?
Monitor network traffic
Secure workloads across various environments
Manage cloud costs
Provide identity and access management
Automate infrastructure provisioning
Correct answer:Secure workloads across various environments
Explanation:CWPPs are designed to protect workloads in any environment.

Which Kubernetes feature enables encryption of Secrets data at rest within the cluster?
Enabling TLS on the API server
Using the etcd encryption provider for at-rest encryption
Storing Secrets in ConfigMaps
Encrypting data at the application layer
Using third-party encryption tools outside Kubernetes
Correct answer:Using the etcd encryption provider for at-rest encryption
Explanation:Kubernetes supports encryption of Secrets at rest by enabling the etcd encryption provider, which encrypts Secret data stored in etcd, the cluster's backing store. This protects sensitive data from unauthorized access if etcd storage is compromised. TLS on the API server secures data in transit, not at rest. ConfigMaps do not provide encryption and are not intended for sensitive data. Application-layer encryption and third-party tools can add security but are not native Kubernetes features for Secrets encryption.


Which of the following are common CNI plugins that support Network Policies? (Select all that apply)
Flannel
Calico
Weave Net
AWS VPC CNI
Cilium
Correct answer:Calico, Weave Net, AWS VPC CNI, Cilium
Explanation:Calico, Weave Net, Cilium, and AWS VPC CNI are CNI plugins that support Network Policies. AWS VPC CNI supports network policies but requires them to be enabled and does not support them for Fargate or Windows containers. Flannel does not support Network Policies by default.


What is the primary function of Resource Quotas in a Kubernetes namespace?
Limit the number of namespaces in the cluster
Restrict access to the Kubernetes API server
Control the amount of resources consumed within a namespace
Schedule pods to specific nodes
Enforce network policies
Correct answer:Control the amount of resources consumed within a namespace
Explanation:Resource Quotas in Kubernetes are used to limit the total amount of compute resources (such as CPU, memory, and object counts) that can be consumed within a namespace. This helps prevent a single namespace from exhausting cluster resources. Resource Quotas do not limit namespaces themselves, control API server access, schedule pods, or enforce network policies, which are handled by other Kubernetes components.


Where in a Pod specification should you declare the use of a gVisor RuntimeClass to ensure all containers in the Pod use this secure runtime environment?

Correct answer:Set 'runtimeClassName: "gvisor"' at the Pod spec level
Explanation:The 'runtimeClassName' field must be specified directly in the Pod's spec section (pod.spec.runtimeClassName). This ensures all containers in the Pod use the specified runtime. SecurityContext handles security parameters but not runtime selection, and container-level runtime configuration isn't supported in this manner.


In Kubernetes security contexts, what specific security benefit does configuring 'readOnlyRootFilesystem: true' provide to containers?
Prevents container processes from modifying host network configurations
Enables root user privileges for container operations
Restricts container processes from writing to the root filesystem
Allows containers to bypass filesystem permission checks
Disables container logging capabilities
Correct answer:Restricts container processes from writing to the root filesystem
Explanation:Setting readOnlyRootFilesystem to true mounts the container's root filesystem as read-only, preventing malicious processes from writing to or modifying system files. This hardening measure significantly reduces attack surfaces by blocking persistence mechanisms and limiting damage from container escapes. Other options describe unrelated security mechanisms: network restrictions (option 1), privilege escalation (option 2/4), and logging (option 5) require separate configurations.


Which Kubernetes object is used to define a set of network access rules that control traffic to and from pods?
Service
Deployment
Ingress
NetworkPolicy
ConfigMap
Correct answer:NetworkPolicy
Explanation:NetworkPolicy objects in Kubernetes are used to specify rules that control the ingress and egress traffic to and from pods. Services manage access at a different layer, Ingress manages external access, Deployments manage pod lifecycle, and ConfigMaps store configuration data, none of which control pod-level network access rules.


In a Kubernetes NetworkPolicy, which selector is used to specify the Pods to which the policy applies?
podSelector
namespaceSelector
policySelector
matchLabels
appSelector
Correct answer:podSelector
Explanation:The 'podSelector' field in a NetworkPolicy defines the set of Pods that the policy applies to by selecting Pods based on labels. 'namespaceSelector' selects namespaces, not Pods. 'policySelector' is not a valid field in NetworkPolicy. 'matchLabels' is a label selector syntax used inside 'podSelector' but is not itself a selector field. 'appSelector' is not a standard Kubernetes selector field.


Which strace command attaches to an already running process with PID 1234 to trace its system calls?
strace 1234
strace -p 1234
strace -c 1234
sudo trace -pid 1234
strace --process 1234
Correct answer:strace -p 1234
Explanation:The correct command to attach strace to a running process with PID 1234 is 'strace -p 1234'. The '-p' option specifies the process ID to attach to. 'strace 1234' attempts to run a new process named '1234', which is invalid. 'strace -c 1234' runs strace with summary statistics on a new process named '1234'. 'sudo trace -pid 1234' is not a valid command, and 'strace --process 1234' is not a recognized option.


What is the correct kubectl command to set the default namespace for all subsequent operations in the current context?
kubectl config use-context <namespace>
kubectl set namespace <namespace>
kubectl config set-context --current --namespace=<namespace>
kubectl namespace set <namespace>
kubectl switch namespace <namespace>
Correct answer:kubectl config set-context --current --namespace=<namespace>
Explanation:The command 'kubectl config set-context --current --namespace=<namespace>' modifies the current context's namespace setting persistently. This differs from temporary namespace overrides using '-n' flag, and ensures all subsequent commands use the specified namespace by default. Other options either use incorrect syntax or modify different configuration aspects.


Which of the following are critical security hardening measures for the Kubernetes API server? (Select all that apply)
Disable anonymous authentication
Enable RBAC authorization
Allow all admission controllers
Enable etcd encryption for secrets
Use insecure port for API communication
Correct answer:Disable anonymous authentication, Enable RBAC authorization, Enable etcd encryption for secrets
Explanation:Disabling anonymous authentication prevents unauthorized access, RBAC enables granular permissions, and etcd encryption protects sensitive data. Allowing all admission controllers (including deprecated ones) and using insecure ports would reduce security. The insecure port (--insecure-port) is deprecated and should be disabled.


Which Kubernetes component is responsible for maintaining network rules on nodes for services?
kubelet
kube-proxy
kube-scheduler
kube-controller-manager
etcd
Correct answer:kube-proxy
Explanation:kube-proxy is the component that maintains network rules on nodes for services. It ensures that incoming traffic is properly routed to the correct service endpoints.


In the STRIDE threat modeling framework, what does the letter 'S' represent?
Spoofing
Scanning
Snooping
Spamming
Sniffing
Correct answer:Spoofing
Explanation:In STRIDE, a widely used threat modeling framework, 'S' stands for Spoofing, which refers to an attacker pretending to be someone or something else to gain unauthorized access. The other options like scanning, snooping, spamming, and sniffing are related to security but are not part of the STRIDE categories.


What is the primary function of a Kubernetes Ingress resource in managing network traffic?
To manage internal cluster networking
To define rules for routing external HTTP and HTTPS traffic to services
To provide persistent storage to pods
To schedule pods onto nodes
To configure network policies for pod communication
Correct answer:To define rules for routing external HTTP and HTTPS traffic to services
Explanation:A Kubernetes Ingress resource primarily manages external access to services within a cluster by defining rules for routing HTTP and HTTPS traffic. It acts as an entry point that controls how external clients reach services inside the cluster. Other options are incorrect because internal networking is handled by Services and CNI plugins, storage is managed by PersistentVolumes, pod scheduling is done by the scheduler, and network policies control pod-to-pod communication rather than external traffic.


In a Kubernetes Pod specification, which field is used to specify the ServiceAccount under which the Pod should run?
serviceAccount
serviceAccountName
accountName
saName
serviceAccountSpec
Correct answer:serviceAccountName
Explanation:The correct field is 'serviceAccountName', which defines the name of the ServiceAccount that the Pod uses for authentication and authorization. The other options are incorrect as they are not valid Pod spec fields. 'serviceAccount' and 'accountName' do not exist in the Pod spec. 'saName' and 'serviceAccountSpec' are not recognized fields.


What is the effect of disabling anonymous authentication on the kubelet?
Increased security by requiring authentication
Nodes cannot join the cluster
Pods fail to start
kube-proxy stops working
No effect; kubelet does not support anonymous access
Correct answer:Increased security by requiring authentication
Explanation:Disabling anonymous authentication on the kubelet enhances security by ensuring that only authenticated requests are accepted. This prevents unauthorized access and reduces the risk of attacks.


How can you enable Pod Security Admission (PSA) in a Kubernetes cluster to enforce pod security standards?
By applying security labels directly to pods
By configuring the API server to enable the PodSecurity admission controller
By setting environment variables on cluster nodes
By deploying a third-party admission webhook
By updating kubelet configurations on nodes
Correct answer:By configuring the API server to enable the PodSecurity admission controller
Explanation:Pod Security Admission (PSA) is enabled by configuring the Kubernetes API server to include the 'PodSecurity' admission controller in its '--enable-admission-plugins' flag. This admission controller enforces pod security standards based on namespace labels. Applying labels to pods or setting environment variables on nodes does not enable PSA. While third-party admission webhooks can enforce policies, PSA is a built-in admission controller. Kubelet configurations do not control PSA.


What is the primary function of Kubernetes labels in organizing resources?
To provide human-readable names for resources
To organize and select groups of objects
To store configuration data
To set permissions on resources
To define network policies
Correct answer:To organize and select groups of objects
Explanation:Kubernetes labels are key-value pairs attached to objects, such as pods or services, to facilitate identification and selection. They enable users to organize and filter resources based on specific criteria, making it easier to manage complex environments.


Which Kubernetes resource defines permissions within a specific namespace?
ClusterRole
ClusterRoleBinding
Role
RoleBinding
ServiceAccount
Correct answer:Role
Explanation:A Role in Kubernetes defines permissions within a namespace. It specifies what actions can be performed by users or service accounts within that namespace.


How does Kube-bench contribute to enhancing Kubernetes security?
By automating cluster scaling during high load
By auditing cluster configurations against CIS Kubernetes Benchmark recommendations
By providing a continuous integration pipeline for containers
By replacing default CNI plugins with a secure version
By encrypting container images at runtime
Correct answer:By auditing cluster configurations against CIS Kubernetes Benchmark recommendations
Explanation:Kube-bench is a tool that automates the evaluation of Kubernetes cluster configurations to ensure they align with the CIS Kubernetes Benchmark recommendations. This helps identify and address potential security vulnerabilities.


Which Kubernetes resource is used to enforce network segmentation between pods?
NetworkPolicy
PodSecurityPolicy
ResourceQuota
LimitRange
Ingress
Correct answer:NetworkPolicy
Explanation:NetworkPolicy defines rules that segment network traffic between pods, allowing you to control the flow of traffic and isolate pods from each other. This is essential for securing communication within a Kubernetes cluster.


After identifying an unwanted process listening on a network port, which command can you use to terminate that process by its process ID (PID)?
killall <process-name>
sudo stop <process-name>
sudo systemctl disable <process-name>
sudo kill <pid>
sudo service <process-name> remove
Correct answer:sudo kill <pid>
Explanation:The command 'sudo kill <pid>' sends a termination signal to the process with the specified PID, effectively stopping it. 'killall <process-name>' kills all processes matching the name but requires the exact process name and may affect multiple processes. 'sudo stop <process-name>' is used to stop services managed by Upstart, which is less common now. 'sudo systemctl disable <process-name>' disables a systemd service from starting on boot but does not stop a running process immediately. 'sudo service <process-name> remove' is not a valid command to stop processes.


What are the key characteristics of gVisor and Firecracker? (Select all that apply)
gVisor is a user-space kernel providing sandboxing
Firecracker uses lightweight microVMs with KVM
Both provide full hardware virtualization
Firecracker is a container runtime interface
gVisor offers better performance than traditional VMs
Correct answer:gVisor is a user-space kernel providing sandboxing, Firecracker uses lightweight microVMs with KVM, gVisor offers better performance than traditional VMs
Explanation:gVisor provides sandboxing by running in user space and intercepting system calls, which enhances security without the need for full hardware virtualization. Firecracker uses microVMs, leveraging KVM for efficient isolation. gVisor can offer better performance compared to traditional VMs due to its lightweight nature.


Which Kubernetes admission controller specifically restricts kubelets to only modify their own Node API objects and Pod objects bound to their node?
NodeRestriction
LimitRanger
NamespaceLifecycle
ResourceQuota
PodSecurityPolicy
Correct answer:NodeRestriction
Explanation:The NodeRestriction admission controller limits kubelet permissions to prevent node spoofing and privilege escalation. It ensures kubelets can only modify their own Node API object and Pod objects scheduled on their node, while LimitRanger and ResourceQuota manage resource constraints.


What command should you use to delete all pods within a Kubernetes namespace named 'test'?
kubectl delete pods --all -n test
kubectl delete pod -A
kubectl delete pods -n test
kubectl remove pods --namespace=test
kubectl delete pods * -n test
Correct answer:kubectl delete pods --all -n test
Explanation:To delete all pods in a specific namespace, you use the `kubectl delete pods` command with the `--all` flag to specify all pods, and the `-n` flag to specify the namespace. The correct command is `kubectl delete pods --all -n test`. This command will delete all pods in the 'test' namespace, which can be useful for cleaning up resources or resetting a namespace.


What is the purpose of the 'kubectl exec' command in Kubernetes?
Executes a command on the Kubernetes control plane
Runs a command inside a container in a pod
Creates a new pod in the cluster
Updates an existing deployment
Deletes a Kubernetes resource
Correct answer:Runs a command inside a container in a pod
Explanation:'kubectl exec' is used to execute a command inside a running container within a Kubernetes pod. This is particularly useful for debugging or interacting with applications running inside containers. For example, you can use it to access logs or run shell commands within the container. Other options are incorrect because: - Option 0: Commands are not executed on the control plane using 'kubectl exec'. - Option 2: It does not create new pods; 'kubectl run' or deployment manifests are used for that. - Option 3: Updating deployments is done using 'kubectl apply' or 'kubectl set'. - Option 4: Deleting resources is handled by 'kubectl delete'.


What is the primary purpose of a PersistentVolumeClaim (PVC) in Kubernetes?
To request storage resources from the cluster
To define storage classes
To monitor disk usage
To create a new volume
To delete unused volumes
Correct answer:To request storage resources from the cluster
Explanation:A PersistentVolumeClaim (PVC) is a request for storage by a user that binds to a PersistentVolume (PV) in the cluster. It abstracts the details of how storage is provided and allows pods to use storage resources without knowing the underlying storage implementation. PVCs do not define storage classes, monitor disk usage, create new volumes directly, or delete volumes; those tasks are handled by other Kubernetes components.


What is 'Threat Modeling' in the context of security?
A systematic process to identify and mitigate security risks
A method to design software architectures
A technique to improve application performance
A strategy for marketing products
An approach to project management
Correct answer:A systematic process to identify and mitigate security risks
Explanation:Threat Modeling is a structured approach to identifying and mitigating potential security threats. It involves analyzing systems to uncover vulnerabilities and developing strategies to address them. This process is crucial for ensuring the security and integrity of systems. The other options describe unrelated activities: software design, performance optimization, marketing, and project management.


In a Kubernetes Pod manifest, which annotation is used to specify an AppArmor profile for a container named 'nginx'?
apparmor.security.beta.kubernetes.io/nginx: 'localhost/nginx-profile'
security.alpha.kubernetes.io/apparmor/nginx: 'localhost/nginx-profile'
container.apparmor.security.beta.kubernetes.io/nginx: 'localhost/nginx-profile'
nginx.apparmor.kubernetes.io/profile: 'localhost/nginx-profile'
securityContext.apparmorProfile: 'localhost/nginx-profile'
Correct answer:container.apparmor.security.beta.kubernetes.io/nginx: 'localhost/nginx-profile'
Explanation:The correct annotation format to specify an AppArmor profile for a container named 'nginx' is 'container.apparmor.security.beta.kubernetes.io/nginx: "localhost/nginx-profile"'. This annotation applies the profile to the specific container. Other options are either incorrect prefixes, deprecated, or invalid Kubernetes annotation keys.


What is the primary effect of sharing the PID namespace between two Docker containers?
They share the same network interfaces
They can see and signal each other's processes
They share the same filesystem
They can access each other's environment variables
They share the same memory space
Correct answer:They can see and signal each other's processes
Explanation:Sharing the PID namespace allows containers to see and interact with each other's processes. This means they can send signals to processes running in the other container.


Which kubectl command correctly creates a TLS secret named 'tls-secret' using the certificate file 'tls.crt' and the key file 'tls.key'?
kubectl create secret generic tls-secret --from-file=tls.crt --from-file=tls.key
kubectl create secret tls tls-secret --cert=tls.crt --key=tls.key
kubectl create secret docker-registry tls-secret --docker-server=tls.crt --docker-username=tls.key
kubectl create tls-secret tls-secret --cert=tls.crt --key=tls.key
kubectl create secret tls-secret --type=tls --cert=tls.crt --key=tls.key
Correct answer:kubectl create secret tls tls-secret --cert=tls.crt --key=tls.key
Explanation:The correct command to create a TLS secret in Kubernetes is 'kubectl create secret tls' followed by the secret name and the paths to the certificate and key files using the --cert and --key flags.


Which Kubernetes or related object defines how to build and deploy an application from source code?

Correct answer:BuildConfig (OpenShift)
Explanation:While Kubernetes itself does not have a native object for building applications from source code, OpenShift uses the 'BuildConfig' object for this purpose. It defines how to build and deploy applications from source code into containers.


Which Kubernetes object is specifically designed to store sensitive information such as passwords, tokens, or keys?
ConfigMap
Secret
Volume
Pod Annotation
Deployment
Correct answer:Secret
Explanation:Kubernetes Secrets are intended to store sensitive data like passwords, OAuth tokens, and SSH keys securely. Unlike ConfigMaps, which store non-sensitive configuration data, Secrets provide mechanisms to protect this sensitive information, including base64 encoding and integration with encryption at rest. Volumes, Pod Annotations, and Deployments are not designed for securely storing sensitive data.


Which of the following practices help prevent container breakout vulnerabilities? (Select all that apply)
Running containers with root privileges
Using minimal base images to reduce attack surface
Applying the principle of least privilege to container permissions
Disabling security modules like SELinux or AppArmor
Regularly updating container runtimes and dependencies
Correct answer:Using minimal base images to reduce attack surface, Applying the principle of least privilege to container permissions, Regularly updating container runtimes and dependencies
Explanation:Preventing container breakouts involves minimizing the attack surface and restricting privileges. Using minimal base images reduces unnecessary software that could be exploited. Applying the principle of least privilege limits container capabilities to only what is necessary, reducing risk. Regularly updating container runtimes ensures known vulnerabilities are patched. Conversely, running containers as root increases risk, and disabling security modules like SELinux or AppArmor removes important security layers, increasing breakout potential.


How do multistage builds in Docker reduce image size?
By running multiple containers within a single image
By creating images compatible with multiple architectures
By separating build-time dependencies from runtime components in different stages
By enabling parallel builds across multiple stages
By deploying to multiple environments simultaneously
Correct answer:By separating build-time dependencies from runtime components in different stages
Explanation:Multistage builds in Docker allow developers to separate build-time dependencies (e.g., compilers, libraries) from runtime components by using multiple `FROM` instructions in a single Dockerfile. This ensures that only the necessary artifacts (e.g., binaries) are included in the final image, significantly reducing its size and improving security. While multistage builds can simplify workflows, they do not inherently enable parallel builds or support multi-environment deployments.


What is the primary function of a DaemonSet in Kubernetes?
A pod runs on all nodes or a subset of nodes
Only one pod runs in the cluster
Pods are automatically scaled based on load
Services are exposed externally
ConfigMaps are synchronized across namespaces
Correct answer:A pod runs on all nodes or a subset of nodes
Explanation:DaemonSets ensure that a copy of a pod runs on each node or a subset of nodes in a Kubernetes cluster. This is useful for running system daemons or monitoring agents.


If a user is granted the 'cluster-admin' ClusterRole through a RoleBinding, what level of access will they have?
Full administrative privileges limited to the namespace where the RoleBinding is applied
Full cluster-wide administrative privileges
Read-only access to all resources in the cluster
No permissions; ClusterRoles require ClusterRoleBindings to take effect
Access only to service accounts within the namespace
Correct answer:Full administrative privileges limited to the namespace where the RoleBinding is applied
Explanation:When a ClusterRole, such as 'cluster-admin', is assigned using a RoleBinding, it grants full administrative privileges but only within the namespace where the RoleBinding is applied. This is because RoleBindings are namespace-scoped, meaning they cannot grant cluster-wide permissions even if the associated role is a ClusterRole. To grant cluster-wide permissions, a ClusterRoleBinding must be used. Incorrect options: (1) Full cluster-wide privileges require a ClusterRoleBinding, not a RoleBinding. (2) Read-only access is not tied to this scenario. (3) The statement about 'no permissions' is incorrect because RoleBindings do apply within their namespace. (4) Access to service accounts is not exclusive in this context.


Which of the following are valid components of a Kubernetes audit policy? (Select all that apply)
Rules
Levels
Stages
Users
Verbs
Correct answer:Rules, Stages, Users, Verbs
Explanation:A Kubernetes audit policy is composed of 'Rules' that define what events to capture. Each rule can specify 'Stages' of the request lifecycle (such as RequestReceived, ResponseStarted). 'Users' can be specified to filter audit events by user identity. 'Verbs' define the types of API operations (e.g., get, create) to audit. 'Levels' is not a component of the policy structure but rather a field inside rules specifying the detail level of logging (e.g., None, Metadata).


What is the primary function of a ReplicaSet in Kubernetes?
To ensure that a specified number of pod replicas are running at all times
To expose services to external traffic using load balancing
To store persistent data for applications
To define and enforce network policies for pods
To schedule pods to specific nodes based on resource requirements
Correct answer:To ensure that a specified number of pod replicas are running at all times
Explanation:A ReplicaSet in Kubernetes ensures that a specified number of pod replicas are running at all times. It monitors existing pods and creates or deletes them as needed to maintain the desired state. Incorrect options: (1) Exposing services to external traffic is handled by Services, not ReplicaSets. (2) Persistent data storage is managed by PersistentVolumes and PersistentVolumeClaims. (3) Network policies are defined separately using NetworkPolicy resources. (4) Scheduling pods to specific nodes is handled by the Kubernetes Scheduler.


What types of data are stored inside the etcd key-value store in a Kubernetes cluster? (Select all that apply)
Kubernetes cluster state
Persistent application data
Pod logs
Secrets and ConfigMaps
Container images
Correct answer:Kubernetes cluster state, Secrets and ConfigMaps
Explanation:etcd stores the entire Kubernetes cluster state, including resource objects such as Secrets and ConfigMaps. It does not store persistent application data (which is stored in volumes), pod logs (which are stored on nodes or centralized logging systems), or container images (stored in container registries).


What is the role of the 'namespaceSelector' field in a Kubernetes NetworkPolicy?
To select namespaces where the policy is applied
To select Pods in specific namespaces for ingress or egress rules
To label namespaces
To deny traffic to certain namespaces
To enforce policies across all namespaces
Correct answer:To select Pods in specific namespaces for ingress or egress rules
Explanation:The 'namespaceSelector' in a NetworkPolicy is used to select Pods in specific namespaces as sources or destinations for ingress or egress traffic rules. It does not select the namespaces where the policy itself is applied; NetworkPolicies are always applied within the namespace they are defined. It also does not label namespaces, deny traffic directly, or enforce policies cluster-wide.


Which of the following securityContext fields are commonly applied at the Pod level in Kubernetes? (Select all that apply)
runAsUser
fsGroup
privileged
capabilities
seLinuxOptions
Correct answer:runAsUser, fsGroup, seLinuxOptions
Explanation:At the Pod level, 'runAsUser' specifies the user ID for all containers in the Pod, 'fsGroup' sets the group ID for mounted volumes, and 'seLinuxOptions' configures SELinux labels for the Pod. 'privileged' and 'capabilities' are container-level settings and cannot be set at the Pod level. Therefore, only 'runAsUser', 'fsGroup', and 'seLinuxOptions' are valid Pod-level securityContext fields.


In threat modeling using Data Flow Diagrams (DFDs), what key aspects of a system are primarily visualized?
Financial transaction records across global markets
Network latency metrics in high-availability clusters
Entry points, exit points, data flows, and potential threat vectors within the system
Container orchestration for microservices deployment
Source code management for Git-based repositories
Correct answer:Entry points, exit points, data flows, and potential threat vectors within the system
Explanation:Data Flow Diagrams (DFDs) are used in threat modeling to visually represent how data moves through a system, highlighting entry and exit points, data stores, processes, and trust boundaries. This visualization helps identify where threats could occur. The other options describe unrelated concepts such as financial data, network performance, container orchestration, or source code management, which are not the focus of DFDs in threat modeling.


What is the recommended method to rotate TLS certificates in a Kubernetes cluster managed by kubeadm?
Manually delete and recreate certificates
Use the 'kubeadm certs renew' command to renew certificates
TLS certificates cannot be rotated once issued
Restart the kubelet service to refresh certificates
Use a third-party certificate manager exclusively
Correct answer:Use the 'kubeadm certs renew' command to renew certificates
Explanation:Kubernetes clusters initialized with kubeadm provide the 'kubeadm certs renew' command to safely renew TLS certificates without manual deletion. Manually deleting certificates or restarting kubelet alone is not sufficient and can cause downtime. While third-party certificate managers can be used, kubeadm's built-in commands are the recommended approach for certificate rotation.


Which Kubernetes object is used to persist data across the lifecycle of a pod?
PersistentVolume
ConfigMap
Secret
PersistentVolumeClaim
EmptyDir
Correct answer:PersistentVolume
Explanation:A PersistentVolume (PV) is a Kubernetes resource that provides persistent storage for data that needs to be preserved across pod lifecycles. Unlike data stored in an EmptyDir or other ephemeral storage, data in a PersistentVolume remains available even if the pod is deleted or recreated. PersistentVolumeClaims (PVCs) are used to request storage resources from PersistentVolumes, but the PV itself is the resource that holds the data.


Which command is used to apply a label to a pod in Kubernetes?
kubectl label pods <pod-name> key=value
kubectl annotate pods <pod-name> key=value
kubectl tag pods <pod-name> key=value
kubectl set label pods <pod-name> key=value
kubectl edit pods <pod-name> --label key=value
Correct answer:kubectl label pods <pod-name> key=value
Explanation:The command `kubectl label pods <pod-name> key=value` is used to apply a label to a pod. This command updates the metadata of the pod with the specified key-value pair, allowing for easier management and filtering of resources.


Which of the following actions can improve the security of the Kubernetes kubelet? (Select all that apply)
Enable authentication and authorization on the kubelet API
Disable anonymous access to the kubelet
Expose the kubelet read-only port to all network interfaces
Use TLS certificates for kubelet communication
Run the kubelet process in privileged mode
Correct answer:Enable authentication and authorization on the kubelet API, Disable anonymous access to the kubelet, Use TLS certificates for kubelet communication
Explanation:Improving kubelet security involves enabling authentication and authorization to ensure only authorized users can access the API, disabling anonymous access to prevent unauthenticated requests, and using TLS certificates to encrypt communication between components. Exposing the read-only port publicly increases attack surface and is discouraged. Running kubelet in privileged mode is not a security best practice and can increase risk.


What is the impact on a Kubernetes cluster if the kube-proxy component enters a 'CrashLoopBackOff' state?
Pods will not be scheduled on any nodes
Network traffic between services may be disrupted or fail
The entire Kubernetes cluster will shut down
The kubelet service on nodes will stop functioning
Access to Kubernetes Secrets will be blocked
Correct answer:Network traffic between services may be disrupted or fail
Explanation:kube-proxy manages network rules on each node to enable service communication and load balancing. If kube-proxy crashes repeatedly (CrashLoopBackOff), network traffic between services can be disrupted, causing failures in service discovery and connectivity. However, pod scheduling, kubelet operation, cluster availability, and secret access are not directly affected by kube-proxy failures.


What is the primary purpose of signing container images in a cloud-native environment?
To reduce the image size for deployment
To verify the image's integrity and authenticity
To include metadata for deployment automation
To enforce runtime security policies
To speed up image pulling during deployment
Correct answer:To verify the image's integrity and authenticity
Explanation:The primary purpose of image signing is to ensure that a container image originates from a trusted source and has not been tampered with. This process involves cryptographically signing the image, allowing users to verify its integrity and authenticity before use. Incorrect options such as reducing image size or speeding up deployment do not relate to the security function of signing. Similarly, metadata inclusion and runtime policy enforcement are separate mechanisms unrelated to image signing.


How does Kubernetes ensure that a Deployment maintains the desired number of replicas?
Through the kube-scheduler
Using the ReplicaSet controller
Via the kubelet on each node
By the API server checking periodically
It does not ensure this automatically
Correct answer:Using the ReplicaSet controller
Explanation:Kubernetes Deployments use ReplicaSets to ensure that the desired number of pod replicas is maintained. ReplicaSets automatically adjust the number of replicas if any discrepancies are detected.


Which kubectl command provides detailed information about a specific Kubernetes resource, including its configuration and status?
kubectl get <resource>
kubectl describe <resource>
kubectl inspect <resource>
kubectl show <resource>
kubectl info <resource>
Correct answer:kubectl describe <resource>
Explanation:The 'kubectl describe <resource>' command outputs detailed information about a Kubernetes resource, including its configuration, status, events, and other metadata. In contrast, 'kubectl get <resource>' provides a summary list or status of resources, but not detailed information. The other commands such as 'inspect', 'show', and 'info' are not valid kubectl commands for this purpose.


What is the correct command to base64-encode the string 'admin' for Kubernetes Secret creation, including proper newline handling?

Correct answer:echo -n 'admin' | base64
Explanation:The '-n' flag prevents adding a trailing newline character, which is critical for accurate encoding. Kubernetes Secrets require precise base64 encoding without unexpected characters. The resulting output can be used in Secret manifests' data field.


In Kubernetes, what is the purpose of the Pod Security Standards?
A deprecated feature replaced by PodSecurityPolicy
A set of built-in policies that enforce best practices for pod security
A configuration for network policies
A type of storage class for pods
An admission controller for scheduling pods
Correct answer:A set of built-in policies that enforce best practices for pod security
Explanation:Pod Security Standards (PSS) are predefined policy levels provided by Kubernetes to enforce security best practices for pods. They replace the deprecated PodSecurityPolicy and provide three levelsâ€”Privileged, Baseline, and Restrictedâ€”to control pod permissions and capabilities. They are not related to network policies, storage classes, or pod scheduling admission controllers.


What happens when you set 'terminationGracePeriodSeconds' to zero in a Kubernetes pod spec?
The pod will terminate immediately without a graceful shutdown
The pod will never terminate
The pod will have infinite time to terminate
The setting is ignored by Kubernetes
The pod will terminate after 30 seconds
Correct answer:The pod will terminate immediately without a graceful shutdown
Explanation:Setting 'terminationGracePeriodSeconds' to zero forces the pod to terminate immediately without a graceful shutdown. This means any running processes will be forcefully stopped, which can lead to data corruption or other issues if not handled properly.


Does setting 'privileged: true' on a Kubernetes pod grant it access to Kubernetes Secrets?
Yes, it grants full access to all Secrets in the cluster
No, it only elevates the pod's privileges on the host system but does not affect Secrets access
Yes, but only to Secrets within the same namespace
No, it explicitly prevents access to Secrets
Access depends solely on RBAC permissions, regardless of privileged mode
Correct answer:No, it only elevates the pod's privileges on the host system but does not affect Secrets access, Access depends solely on RBAC permissions, egardless of privileged mode
Explanation:Setting 'privileged: true' on a pod grants the container elevated privileges on the host system, such as access to devices and kernel capabilities, but it does not inherently grant access to Kubernetes Secrets. Access to Secrets is controlled by Kubernetes Role-Based Access Control (RBAC) policies and namespace scoping.


